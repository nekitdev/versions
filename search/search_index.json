{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"versions Parsing, inspecting and specifying versions. Installing Python 3.7 or above is required. pip Installing the library with pip is quite simple: $ pip install versions Alternatively, the library can be installed from source: $ git clone https://github.com/nekitdev/versions.git $ cd versions $ python -m pip install . poetry You can add versions as a dependency with the following command: $ poetry add versions Or by directly specifying it in the configuration like so: [tool.poetry.dependencies] versions = \"^1.3.0\" Alternatively, you can add it directly from the source: [tool.poetry.dependencies.versions] git = \"https://github.com/nekitdev/versions.git\" Examples Versions parse_version is used to parse versions: from versions import parse_version version = parse_version ( \"1.0.0-dev.1+build.1\" ) print ( version ) # 1.0.0-dev.1+build.1 Segments All version segments can be fetched with their respective names: >>> print ( version . release ) 1.0.0 >>> version . release . parts ( 1 , 0 , 0 ) >>> print ( version . dev ) dev .1 >>> ( version . dev . phase , version . dev . value ) ( \"dev\" , 1 ) >>> print ( version . local ) build .1 >>> version . local . parts ( \"build\" , 1 ) Comparison Versions support total ordering: >>> v1 = parse_version ( \"1.0.0\" ) >>> v2 = parse_version ( \"2.0.0\" ) >>> v1 == v2 False >>> v1 != v2 True >>> v1 >= v2 False >>> v1 <= v2 True >>> v1 > v2 False >>> v1 < v2 True Specification versions also supports specifying version requirements and matching version against them. Since versions support total ordering, they can be checked using version sets (via parse_version_set ): >>> from versions import parse_version , parse_version_set >>> version_set = parse_version_set ( \"^1.0.0\" ) >>> version_set < VersionRange ( >= 1.0.0 , < 2.0.0 ) > >>> version = parse_version ( \"1.3.0\" ) >>> version < Version ( 1.3.0 ) > >>> version . matches ( version_set ) True >>> another = parse_version ( \"2.2.0\" ) >>> another . matches ( version_set ) False Documentation You can find the documentation here . Support If you need support with the library, you can send an email or refer to the official Discord server . Changelog You can find the changelog here . Security Policy You can find the Security Policy of versions here . Contributing If you are interested in contributing to versions , make sure to take a look at the Contributing Guide , as well as the Code of Conduct . License versions is licensed under the MIT License terms. See License for details.","title":"Index"},{"location":"#versions","text":"Parsing, inspecting and specifying versions.","title":"versions"},{"location":"#installing","text":"Python 3.7 or above is required.","title":"Installing"},{"location":"#pip","text":"Installing the library with pip is quite simple: $ pip install versions Alternatively, the library can be installed from source: $ git clone https://github.com/nekitdev/versions.git $ cd versions $ python -m pip install .","title":"pip"},{"location":"#poetry","text":"You can add versions as a dependency with the following command: $ poetry add versions Or by directly specifying it in the configuration like so: [tool.poetry.dependencies] versions = \"^1.3.0\" Alternatively, you can add it directly from the source: [tool.poetry.dependencies.versions] git = \"https://github.com/nekitdev/versions.git\"","title":"poetry"},{"location":"#examples","text":"","title":"Examples"},{"location":"#versions_1","text":"parse_version is used to parse versions: from versions import parse_version version = parse_version ( \"1.0.0-dev.1+build.1\" ) print ( version ) # 1.0.0-dev.1+build.1","title":"Versions"},{"location":"#segments","text":"All version segments can be fetched with their respective names: >>> print ( version . release ) 1.0.0 >>> version . release . parts ( 1 , 0 , 0 ) >>> print ( version . dev ) dev .1 >>> ( version . dev . phase , version . dev . value ) ( \"dev\" , 1 ) >>> print ( version . local ) build .1 >>> version . local . parts ( \"build\" , 1 )","title":"Segments"},{"location":"#comparison","text":"Versions support total ordering: >>> v1 = parse_version ( \"1.0.0\" ) >>> v2 = parse_version ( \"2.0.0\" ) >>> v1 == v2 False >>> v1 != v2 True >>> v1 >= v2 False >>> v1 <= v2 True >>> v1 > v2 False >>> v1 < v2 True","title":"Comparison"},{"location":"#specification","text":"versions also supports specifying version requirements and matching version against them. Since versions support total ordering, they can be checked using version sets (via parse_version_set ): >>> from versions import parse_version , parse_version_set >>> version_set = parse_version_set ( \"^1.0.0\" ) >>> version_set < VersionRange ( >= 1.0.0 , < 2.0.0 ) > >>> version = parse_version ( \"1.3.0\" ) >>> version < Version ( 1.3.0 ) > >>> version . matches ( version_set ) True >>> another = parse_version ( \"2.2.0\" ) >>> another . matches ( version_set ) False","title":"Specification"},{"location":"#documentation","text":"You can find the documentation here .","title":"Documentation"},{"location":"#support","text":"If you need support with the library, you can send an email or refer to the official Discord server .","title":"Support"},{"location":"#changelog","text":"You can find the changelog here .","title":"Changelog"},{"location":"#security-policy","text":"You can find the Security Policy of versions here .","title":"Security Policy"},{"location":"#contributing","text":"If you are interested in contributing to versions , make sure to take a look at the Contributing Guide , as well as the Code of Conduct .","title":"Contributing"},{"location":"#license","text":"versions is licensed under the MIT License terms. See License for details.","title":"License"},{"location":"changelog/","text":"Changelog 1.3.0 (2022-10-23) Changes OperatorType.DOUBLE_EQUAL and OperatorType.EQUAL are now considered equal. 1.2.1 (2022-09-17) No significant changes. 1.2.0 (2022-09-17) Features Add meta module with python and library versions. ( #3 ) 1.1.0 (2022-07-24) Changes Export type guards, allowing their usage in public API. ( #1 ) 1.0.0 (2022-07-24) Initial release.","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#130-2022-10-23","text":"","title":"1.3.0 (2022-10-23)"},{"location":"changelog/#changes","text":"OperatorType.DOUBLE_EQUAL and OperatorType.EQUAL are now considered equal.","title":"Changes"},{"location":"changelog/#121-2022-09-17","text":"No significant changes.","title":"1.2.1 (2022-09-17)"},{"location":"changelog/#120-2022-09-17","text":"","title":"1.2.0 (2022-09-17)"},{"location":"changelog/#features","text":"Add meta module with python and library versions. ( #3 )","title":"Features"},{"location":"changelog/#110-2022-07-24","text":"","title":"1.1.0 (2022-07-24)"},{"location":"changelog/#changes_1","text":"Export type guards, allowing their usage in public API. ( #1 )","title":"Changes"},{"location":"changelog/#100-2022-07-24","text":"Initial release.","title":"1.0.0 (2022-07-24)"},{"location":"code_of_conduct/","text":"Code of Conduct Our Pledge We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation. We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community. Our Standards Examples of behavior that contributes to a positive environment for our community include: Demonstrating empathy and kindness toward other people Being respectful of differing opinions, viewpoints, and experiences Giving and gracefully accepting constructive feedback Accepting responsibility and apologizing to those affected by our mistakes, and learning from the experience Focusing on what is best not just for us as individuals, but for the overall community Examples of unacceptable behavior include: The use of sexualized language or imagery, and sexual attention or advances of any kind Trolling, insulting or derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or email address, without their explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Enforcement Responsibilities Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful. Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate. Scope This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official email address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Enforcement Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement to conduct@nekit.dev . All complaints will be reviewed and investigated promptly and fairly. All community leaders are obligated to respect the privacy and security of the reporter of any incident. Enforcement Guidelines Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct: 1. Correction Community Impact : Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community. Consequence : A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested. 2. Warning Community Impact : A violation through a single incident or series of actions. Consequence : A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban. 3. Temporary Ban Community Impact : A serious violation of community standards, including sustained inappropriate behavior. Consequence : A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban. 4. Permanent Ban Community Impact : Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals. Consequence : A permanent ban from any sort of public interaction within the community. Attribution This Code of Conduct is adapted from the Contributor Covenant , version 2.1, available at https://contributor-covenant.org/version/2/1/code_of_conduct . Community Impact Guidelines were inspired by Mozilla's Code of Conduct enforcement ladder . For answers to common questions about this code of conduct, see the FAQ at https://contributor-covenant.org/faq . Translations are available at https://contributor-covenant.org/translations .","title":"Code of Conduct"},{"location":"code_of_conduct/#code-of-conduct","text":"","title":"Code of Conduct"},{"location":"code_of_conduct/#our-pledge","text":"We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation. We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.","title":"Our Pledge"},{"location":"code_of_conduct/#our-standards","text":"Examples of behavior that contributes to a positive environment for our community include: Demonstrating empathy and kindness toward other people Being respectful of differing opinions, viewpoints, and experiences Giving and gracefully accepting constructive feedback Accepting responsibility and apologizing to those affected by our mistakes, and learning from the experience Focusing on what is best not just for us as individuals, but for the overall community Examples of unacceptable behavior include: The use of sexualized language or imagery, and sexual attention or advances of any kind Trolling, insulting or derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or email address, without their explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"code_of_conduct/#enforcement-responsibilities","text":"Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful. Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.","title":"Enforcement Responsibilities"},{"location":"code_of_conduct/#scope","text":"This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official email address, posting via an official social media account, or acting as an appointed representative at an online or offline event.","title":"Scope"},{"location":"code_of_conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement to conduct@nekit.dev . All complaints will be reviewed and investigated promptly and fairly. All community leaders are obligated to respect the privacy and security of the reporter of any incident.","title":"Enforcement"},{"location":"code_of_conduct/#enforcement-guidelines","text":"Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:","title":"Enforcement Guidelines"},{"location":"code_of_conduct/#1-correction","text":"Community Impact : Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community. Consequence : A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.","title":"1. Correction"},{"location":"code_of_conduct/#2-warning","text":"Community Impact : A violation through a single incident or series of actions. Consequence : A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.","title":"2. Warning"},{"location":"code_of_conduct/#3-temporary-ban","text":"Community Impact : A serious violation of community standards, including sustained inappropriate behavior. Consequence : A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.","title":"3. Temporary Ban"},{"location":"code_of_conduct/#4-permanent-ban","text":"Community Impact : Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals. Consequence : A permanent ban from any sort of public interaction within the community.","title":"4. Permanent Ban"},{"location":"code_of_conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 2.1, available at https://contributor-covenant.org/version/2/1/code_of_conduct . Community Impact Guidelines were inspired by Mozilla's Code of Conduct enforcement ladder . For answers to common questions about this code of conduct, see the FAQ at https://contributor-covenant.org/faq . Translations are available at https://contributor-covenant.org/translations .","title":"Attribution"},{"location":"contributing/","text":"","title":"Contributing"},{"location":"security/","text":"Security Policy Reporting Thank you for taking the time to responsibly disclose any problems you find. Do not file public issues as they are open for everyone to see! All security vulnerabilities in versions should be reported by email to security@nekit.dev . Your report will be acknowledged within 24 hours, and you will receive a more detailed response within 48 hours indicating the next steps in handling your report. You can encrypt your report using our public key: BB2D8194464001E0B9B60EB8741A1EAD20FFDE8A . This key is also available on MIT's Key Server and reproduced below . After the initial reply to your report, the core team will try to keep you informed of the progress being made towards a fix and official announcement. These updates will be sent at least every five days. In reality, this is more likely to be every 24-48 hours. Disclosure Policy versions has a 5-step disclosure process: The security report is received and is assigned a primary handler. This person will coordinate the fix and release process. The problem is confirmed and a list of all affected versions is determined. Code is audited to find any potential similar problems. Fixes are prepared for all releases which are still under maintenance. These fixes are not committed to the public repository but rather held locally pending the announcement. On the embargo date, the changes are pushed to the public repository and new builds are deployed. This process can take some time, especially when coordination is required with maintainers of other projects. Every effort will be made to handle the issue in as timely a manner as possible, however it is important that we follow the release process above to ensure that the disclosure is handled in a consistent manner. Security Key -----BEGIN PGP PUBLIC KEY BLOCK----- mQINBGKJEuEBEAC37iPX5u8sN+DZQ8c4Of+85u/hboSqNLp7VtTGgr/d8RCFhGZk 25ZwqGWeJbhnlPuzT6u96CZFRe3TMHYJR+A2NZBVjAQQjDRGbIGgaS6/9lvMLcRx D+hFQNPgwUTfPhSHIan+9EuYK/Bz+jyyIplwTrIBq1Mo0NG+cUNvAB+he22xhBQ7 y/Xal+sapHfYedqywhYEQUgP94IGURIMiBlAB7nKW+qs7YiQBShBbfxxffMgK6W6 sNNSybUQDqjj1AWkOBj5uizkA6FLF80xULypbhe1gbqsIt4d1Lj/mxI5zvj84wy5 oQ6QOpYlBUQwl8kqfszYaqKCviflA+riAFMAE8NVL+5BuVN0QSvQb6cRzIV1SL0p MCA6s2+plK/9K+JyR5yyjY7FxvatYNLW5LsubmS+YeBdO4l4A7YEElOGMexUb61H 3ejlb/9UUrZ7hd09Hsi1J6nthrI26o0XBdB8UJ9QAdfoHWka3fgSgopBBcI+S3tU iWGngFrUhiXcBS+0xHjrk4USKwFyFr8fmL4Y8Yu31ViHRFj6gVjC/PHP0apCnakB UEEMHnAQfztodH9o2ew2kew77+q9VblDGpb3BYaiptl4c6h6WBcEULpRfWERfB8H St4L49Ob6CCNpVw9qgsDfNw2fFjUIsT6OGwJxhv9StIFW2JEhgxEvfHr1wARAQAB tC9OaWtpdGEgVGlraG9ub3YgKHNlY3VyaXR5KSA8c2VjdXJpdHlAbmVraXQuZGV2 PokCUgQTAQgAPAIbAwIXgAIeBxYhBLstgZRGQAHgubYOuHQaHq0g/96KBQJiiR6G BQsJCAcCAyICAQYVCgkICwIEFgIDAQAKCRB0Gh6tIP/einfmD/9y69eqwjRfdmnW s0ph8Rh99JHtgA+zm1akRl+eymiqLuJwmZge7PPFb68Wj4lI6s1M1dIkyRuYMtIM 3rEcMmGUlcVnPldx/wdcPyhYZDUXnYCK64dsloftrWFWoSr5a/AILyVh/L6Fkf+L RU9h3KPMXhLTyK127ZF5WuzpjSJms0hDMDV/idfiDeWn/VGaZz1Wiks4l8R9kisR LI3RKNR537f0KFS8jkqlI41Lj9XQTUdqMRp+eqi/zUMM7OZzKQg1ohDsLi4MR6wa bXIu7LeAp1M0XlB+MO09KOxR8i19ST89EapAp4gHprbG5hJyV3XHK4txcWHG0YjB g5/fOvytljf/ue5YGe5nQUcxucq6i4d6jsB66Gk/4nnKutlMG2ZtVyIZZZActPZ5 qKI64HQJOpag+ERXwrv0optEhTC7RHOFRuZ4pCKuVjdJE9W7ZpAIAi8yHeVvpgJY glo+DqZH1/kLD1u2Jb/8yUuMeCYc3aBlfZswO6IeMFeXbPaMtIHzY5q7blIdKIAb YxS5KCYn8VHG6Nz8lFMu2z4jpH4QY9vTaxZnG3Xp23uxbP0pznih4DMiHIACyCBP WgRReZTCVU6Z9FvBq8t/hcrwli33lTa5hkuuzqcojn80+1g9st7DOzxVFtR2MoSS Wkv8ss8apRyeLNZAM5M8v+AiiyVCrLkCDQRiiRLhARAApEJFgvQVDMYpuo754cRK WC/17DH1BQ9y78h/0MXmOOf/0MpzJBkPjn4++BdXQGoOCBleHrWmbtmfYLcQFmZ/ eiUzxFDS/pkC7aZUb+YA7JzcwZQP2yOhlMfFK0qCoQKw/45q+AkOUR+Z+VGExkM1 5+PAcQ+7cQRiyina6/MG7FHAOcvuEwjiyt/0zBm3izeWmXL0Gngisl1jvd8bGn4T bK68q2d09NNHdXJ9UDFdGJ+FVIqJCyLyBl0ZfWazSkD/4ZNchdjFcSOzTTMvqWWn 6i5awbVyMPZkKS88vRVwTtcjk4+hrzaIyNbTw7y55qQxFe0NEoj4SK+iMwCkax19 njGQeB8GqmieC+0WYUSt10xXZ6tDf6a9F2cg6zv1ZklOuYU9x8GYwU7zvhrGhvXU Un1ZtP/OaHoQsS/+AS7KJtm/NWHGsfjd8vwDirIoZ31D7X52QrN07NQ0H7+uqtDL c7BAhsLI1G/r9Kz0+P0nC/6bMWvQWiomB1BSwUTfXLkT0RoKZ3Yub8XMk46N9XKE RtTk5x0/rZ40uOg8wzT1GvwYFA4tpavAqLejOftE05lKXAb5tQhYRupZywzXM6HN DR7CbP1e26g0p8GAuz1aFny6cN8T3wTHHyYn7aQk7i1BboV8zFpVlF6EmoHNCZtG hkl28kYa0Yvu+9mw0SPNiIsAEQEAAYkCNgQYAQgAIBYhBLstgZRGQAHgubYOuHQa Hq0g/96KBQJiiRLhAhsMAAoJEHQaHq0g/96KeCoP/3i3A629wvjPn7m3y7pTcV8p riTlH5OeXhg4jCORgJrgL4PSoeFCITA0u0djtcvctmCrHMsZe0hyH5+X+/B9Bsf6 eFQKWXLidqkxD/M6lnE6t34d17DvaWCP27MsS/f0u0FsLom11TTFgp4wGKZfRBNH vX5xuhjoYXYwZwWqCYyEXFTbsUTDce2oaqc7Yw/GmM3fCodLX0/0eYh5u2fiKA57 7VuUWD74/TkgcEOMa/IZ/jPmJHuHOteaIJR0pYUvLQ1EJh3jI4LhmH8DqxoUrmKy 8z2VM0iLIiev86EXM+yzqTpRIFnm6Ts+47L18rb9D5IUo68gr5B2bMKPOfvMVzdN /vw2RKdCVJ70nh3qqRis5RsJrn/3T8H1CQtuPvsAd/oB86YGWPpWBtpTyI+VBp+x +XR434K8D9QXFst73wTCnQwSX6j0sIotQC5GsPJEKky2Wijg3BlxqTxtYjLhwKWg x3e63TEw7IgU+lE/ybzWLJ7EndbKsC7stZh+Lyh5b3YHgI3cfJUxjZNFpniKr/Fy 4EjjLZzFf3QRmNNJ/7VlYLYztGZsOWxRsLk7QfUPSZY4iHUr8aiwfL7IFwnAlzIo 36HDjJi80UakMlf45UcxRaJwWiaj7G4x3h1D1BZLtMiypiaw/mesrithmfHg+KYu 1oYi7ft0FnZ67Wnk5+E+ =VRe2 -----END PGP PUBLIC KEY BLOCK----- Attribution This Security Policy is adapted from Rust's Security Policy .","title":"Security"},{"location":"security/#security-policy","text":"","title":"Security Policy"},{"location":"security/#reporting","text":"Thank you for taking the time to responsibly disclose any problems you find. Do not file public issues as they are open for everyone to see! All security vulnerabilities in versions should be reported by email to security@nekit.dev . Your report will be acknowledged within 24 hours, and you will receive a more detailed response within 48 hours indicating the next steps in handling your report. You can encrypt your report using our public key: BB2D8194464001E0B9B60EB8741A1EAD20FFDE8A . This key is also available on MIT's Key Server and reproduced below . After the initial reply to your report, the core team will try to keep you informed of the progress being made towards a fix and official announcement. These updates will be sent at least every five days. In reality, this is more likely to be every 24-48 hours.","title":"Reporting"},{"location":"security/#disclosure-policy","text":"versions has a 5-step disclosure process: The security report is received and is assigned a primary handler. This person will coordinate the fix and release process. The problem is confirmed and a list of all affected versions is determined. Code is audited to find any potential similar problems. Fixes are prepared for all releases which are still under maintenance. These fixes are not committed to the public repository but rather held locally pending the announcement. On the embargo date, the changes are pushed to the public repository and new builds are deployed. This process can take some time, especially when coordination is required with maintainers of other projects. Every effort will be made to handle the issue in as timely a manner as possible, however it is important that we follow the release process above to ensure that the disclosure is handled in a consistent manner.","title":"Disclosure Policy"},{"location":"security/#security-key","text":"-----BEGIN PGP PUBLIC KEY BLOCK----- mQINBGKJEuEBEAC37iPX5u8sN+DZQ8c4Of+85u/hboSqNLp7VtTGgr/d8RCFhGZk 25ZwqGWeJbhnlPuzT6u96CZFRe3TMHYJR+A2NZBVjAQQjDRGbIGgaS6/9lvMLcRx D+hFQNPgwUTfPhSHIan+9EuYK/Bz+jyyIplwTrIBq1Mo0NG+cUNvAB+he22xhBQ7 y/Xal+sapHfYedqywhYEQUgP94IGURIMiBlAB7nKW+qs7YiQBShBbfxxffMgK6W6 sNNSybUQDqjj1AWkOBj5uizkA6FLF80xULypbhe1gbqsIt4d1Lj/mxI5zvj84wy5 oQ6QOpYlBUQwl8kqfszYaqKCviflA+riAFMAE8NVL+5BuVN0QSvQb6cRzIV1SL0p MCA6s2+plK/9K+JyR5yyjY7FxvatYNLW5LsubmS+YeBdO4l4A7YEElOGMexUb61H 3ejlb/9UUrZ7hd09Hsi1J6nthrI26o0XBdB8UJ9QAdfoHWka3fgSgopBBcI+S3tU iWGngFrUhiXcBS+0xHjrk4USKwFyFr8fmL4Y8Yu31ViHRFj6gVjC/PHP0apCnakB UEEMHnAQfztodH9o2ew2kew77+q9VblDGpb3BYaiptl4c6h6WBcEULpRfWERfB8H St4L49Ob6CCNpVw9qgsDfNw2fFjUIsT6OGwJxhv9StIFW2JEhgxEvfHr1wARAQAB tC9OaWtpdGEgVGlraG9ub3YgKHNlY3VyaXR5KSA8c2VjdXJpdHlAbmVraXQuZGV2 PokCUgQTAQgAPAIbAwIXgAIeBxYhBLstgZRGQAHgubYOuHQaHq0g/96KBQJiiR6G BQsJCAcCAyICAQYVCgkICwIEFgIDAQAKCRB0Gh6tIP/einfmD/9y69eqwjRfdmnW s0ph8Rh99JHtgA+zm1akRl+eymiqLuJwmZge7PPFb68Wj4lI6s1M1dIkyRuYMtIM 3rEcMmGUlcVnPldx/wdcPyhYZDUXnYCK64dsloftrWFWoSr5a/AILyVh/L6Fkf+L RU9h3KPMXhLTyK127ZF5WuzpjSJms0hDMDV/idfiDeWn/VGaZz1Wiks4l8R9kisR LI3RKNR537f0KFS8jkqlI41Lj9XQTUdqMRp+eqi/zUMM7OZzKQg1ohDsLi4MR6wa bXIu7LeAp1M0XlB+MO09KOxR8i19ST89EapAp4gHprbG5hJyV3XHK4txcWHG0YjB g5/fOvytljf/ue5YGe5nQUcxucq6i4d6jsB66Gk/4nnKutlMG2ZtVyIZZZActPZ5 qKI64HQJOpag+ERXwrv0optEhTC7RHOFRuZ4pCKuVjdJE9W7ZpAIAi8yHeVvpgJY glo+DqZH1/kLD1u2Jb/8yUuMeCYc3aBlfZswO6IeMFeXbPaMtIHzY5q7blIdKIAb YxS5KCYn8VHG6Nz8lFMu2z4jpH4QY9vTaxZnG3Xp23uxbP0pznih4DMiHIACyCBP WgRReZTCVU6Z9FvBq8t/hcrwli33lTa5hkuuzqcojn80+1g9st7DOzxVFtR2MoSS Wkv8ss8apRyeLNZAM5M8v+AiiyVCrLkCDQRiiRLhARAApEJFgvQVDMYpuo754cRK WC/17DH1BQ9y78h/0MXmOOf/0MpzJBkPjn4++BdXQGoOCBleHrWmbtmfYLcQFmZ/ eiUzxFDS/pkC7aZUb+YA7JzcwZQP2yOhlMfFK0qCoQKw/45q+AkOUR+Z+VGExkM1 5+PAcQ+7cQRiyina6/MG7FHAOcvuEwjiyt/0zBm3izeWmXL0Gngisl1jvd8bGn4T bK68q2d09NNHdXJ9UDFdGJ+FVIqJCyLyBl0ZfWazSkD/4ZNchdjFcSOzTTMvqWWn 6i5awbVyMPZkKS88vRVwTtcjk4+hrzaIyNbTw7y55qQxFe0NEoj4SK+iMwCkax19 njGQeB8GqmieC+0WYUSt10xXZ6tDf6a9F2cg6zv1ZklOuYU9x8GYwU7zvhrGhvXU Un1ZtP/OaHoQsS/+AS7KJtm/NWHGsfjd8vwDirIoZ31D7X52QrN07NQ0H7+uqtDL c7BAhsLI1G/r9Kz0+P0nC/6bMWvQWiomB1BSwUTfXLkT0RoKZ3Yub8XMk46N9XKE RtTk5x0/rZ40uOg8wzT1GvwYFA4tpavAqLejOftE05lKXAb5tQhYRupZywzXM6HN DR7CbP1e26g0p8GAuz1aFny6cN8T3wTHHyYn7aQk7i1BboV8zFpVlF6EmoHNCZtG hkl28kYa0Yvu+9mw0SPNiIsAEQEAAYkCNgQYAQgAIBYhBLstgZRGQAHgubYOuHQa Hq0g/96KBQJiiRLhAhsMAAoJEHQaHq0g/96KeCoP/3i3A629wvjPn7m3y7pTcV8p riTlH5OeXhg4jCORgJrgL4PSoeFCITA0u0djtcvctmCrHMsZe0hyH5+X+/B9Bsf6 eFQKWXLidqkxD/M6lnE6t34d17DvaWCP27MsS/f0u0FsLom11TTFgp4wGKZfRBNH vX5xuhjoYXYwZwWqCYyEXFTbsUTDce2oaqc7Yw/GmM3fCodLX0/0eYh5u2fiKA57 7VuUWD74/TkgcEOMa/IZ/jPmJHuHOteaIJR0pYUvLQ1EJh3jI4LhmH8DqxoUrmKy 8z2VM0iLIiev86EXM+yzqTpRIFnm6Ts+47L18rb9D5IUo68gr5B2bMKPOfvMVzdN /vw2RKdCVJ70nh3qqRis5RsJrn/3T8H1CQtuPvsAd/oB86YGWPpWBtpTyI+VBp+x +XR434K8D9QXFst73wTCnQwSX6j0sIotQC5GsPJEKky2Wijg3BlxqTxtYjLhwKWg x3e63TEw7IgU+lE/ybzWLJ7EndbKsC7stZh+Lyh5b3YHgI3cfJUxjZNFpniKr/Fy 4EjjLZzFf3QRmNNJ/7VlYLYztGZsOWxRsLk7QfUPSZY4iHUr8aiwfL7IFwnAlzIo 36HDjJi80UakMlf45UcxRaJwWiaj7G4x3h1D1BZLtMiypiaw/mesrithmfHg+KYu 1oYi7ft0FnZ67Wnk5+E+ =VRe2 -----END PGP PUBLIC KEY BLOCK-----","title":"Security Key"},{"location":"security/#attribution","text":"This Security Policy is adapted from Rust's Security Policy .","title":"Attribution"},{"location":"reference/converters/","text":"version_set_from_specifier = specifier_to_version_set module-attribute An alias of specifier_to_version_set . specifier_from_version_set = version_set_to_specifier module-attribute An alias of version_set_to_specifier . simplify ( specifier : Specifier ) -> Specifier Simplifies a Specifier . The simplification is accomplished through converting to the version set and back. Parameters: Name Type Description Default specifier Specifier The version specifier to simplify. required Returns: Type Description Specifier The simplified specifier. Source code in versions/converters.py 45 46 47 48 49 50 51 52 53 54 55 56 def simplify ( specifier : Specifier ) -> Specifier : \"\"\"Simplifies a [`Specifier`][versions.specifiers.Specifier]. The simplification is accomplished through converting to the version set and back. Arguments: specifier: The version specifier to simplify. Returns: The simplified specifier. \"\"\" return specifier_from_version_set ( specifier_to_version_set ( specifier )) specifier_to_version_set ( specifier : Specifier ) -> VersionSet Converts a Specifier to VersionSet . Parameters: Name Type Description Default specifier Specifier The version specifier to convert. required Returns: Type Description VersionSet The converted version set. Source code in versions/converters.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def specifier_to_version_set ( specifier : Specifier ) -> VersionSet : \"\"\"Converts a [`Specifier`][versions.specifiers.Specifier] to [`VersionSet`][versions.version_sets.VersionSet]. Arguments: specifier: The version specifier to convert. Returns: The converted version set. \"\"\" if is_specifier_single ( specifier ): return specifier . translate ( specifier . version ) if is_specifier_false ( specifier ): return VersionEmpty () if is_specifier_true ( specifier ): return VersionRange () if is_specifier_all ( specifier ): return reduce ( intersection , map ( specifier_to_version_set , specifier . specifiers )) if is_specifier_any ( specifier ): return reduce ( union , map ( specifier_to_version_set , specifier . specifiers )) raise TypeError ( UNEXPECTED_SPECIFIER . format ( repr ( specifier ))) version_set_to_specifier ( version_set : VersionSet ) -> Specifier Converts a VersionSet to Specifier . Parameters: Name Type Description Default version_set VersionSet The version set to convert. required Returns: Type Description Specifier The converted version specifier. Source code in versions/converters.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 def version_set_to_specifier ( version_set : VersionSet ) -> Specifier : \"\"\"Converts a [`VersionSet`][versions.version_sets.VersionSet] to [`Specifier`][versions.specifiers.Specifier]. Arguments: version_set: The version set to convert. Returns: The converted version specifier. \"\"\" if is_version_empty ( version_set ): return SpecifierFalse () if is_version_point ( version_set ): return SpecifierSingle ( OperatorType . DOUBLE_EQUAL , version_set . version ) if is_version_range ( version_set ): if version_set . is_empty (): return SpecifierFalse () if version_set . is_universe (): return SpecifierTrue () if version_set . is_point (): return SpecifierSingle ( OperatorType . DOUBLE_EQUAL , version_set . version ) min = version_set . min max = version_set . max min_specifier = None max_specifier = None if min : min_type = ( OperatorType . GREATER_OR_EQUAL if version_set . include_min else OperatorType . GREATER ) min_specifier = SpecifierSingle ( min_type , min ) if max : max_type = OperatorType . LESS_OR_EQUAL if version_set . include_max else OperatorType . LESS max_specifier = SpecifierSingle ( max_type , max ) if min_specifier and max_specifier : return SpecifierAll . of ( min_specifier , max_specifier ) specifier = min_specifier or max_specifier if specifier is None : # pragma: no cover raise InternalError ( EXPECTED_MIN_OR_MAX ) return specifier if is_version_union ( version_set ): exclude_version = version_set . exclude_version if exclude_version : return SpecifierSingle ( OperatorType . NOT_EQUAL , exclude_version ) return SpecifierAny . of_iterable ( map ( version_set_to_specifier , version_set . items )) raise TypeError ( UNEXPECTED_VERSION_SET . format ( repr ( version_set )))","title":"Converters"},{"location":"reference/converters/#versions.converters.version_set_from_specifier","text":"An alias of specifier_to_version_set .","title":"version_set_from_specifier"},{"location":"reference/converters/#versions.converters.specifier_from_version_set","text":"An alias of version_set_to_specifier .","title":"specifier_from_version_set"},{"location":"reference/converters/#versions.converters.simplify","text":"Simplifies a Specifier . The simplification is accomplished through converting to the version set and back. Parameters: Name Type Description Default specifier Specifier The version specifier to simplify. required Returns: Type Description Specifier The simplified specifier. Source code in versions/converters.py 45 46 47 48 49 50 51 52 53 54 55 56 def simplify ( specifier : Specifier ) -> Specifier : \"\"\"Simplifies a [`Specifier`][versions.specifiers.Specifier]. The simplification is accomplished through converting to the version set and back. Arguments: specifier: The version specifier to simplify. Returns: The simplified specifier. \"\"\" return specifier_from_version_set ( specifier_to_version_set ( specifier ))","title":"simplify()"},{"location":"reference/converters/#versions.converters.specifier_to_version_set","text":"Converts a Specifier to VersionSet . Parameters: Name Type Description Default specifier Specifier The version specifier to convert. required Returns: Type Description VersionSet The converted version set. Source code in versions/converters.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def specifier_to_version_set ( specifier : Specifier ) -> VersionSet : \"\"\"Converts a [`Specifier`][versions.specifiers.Specifier] to [`VersionSet`][versions.version_sets.VersionSet]. Arguments: specifier: The version specifier to convert. Returns: The converted version set. \"\"\" if is_specifier_single ( specifier ): return specifier . translate ( specifier . version ) if is_specifier_false ( specifier ): return VersionEmpty () if is_specifier_true ( specifier ): return VersionRange () if is_specifier_all ( specifier ): return reduce ( intersection , map ( specifier_to_version_set , specifier . specifiers )) if is_specifier_any ( specifier ): return reduce ( union , map ( specifier_to_version_set , specifier . specifiers )) raise TypeError ( UNEXPECTED_SPECIFIER . format ( repr ( specifier )))","title":"specifier_to_version_set()"},{"location":"reference/converters/#versions.converters.version_set_to_specifier","text":"Converts a VersionSet to Specifier . Parameters: Name Type Description Default version_set VersionSet The version set to convert. required Returns: Type Description Specifier The converted version specifier. Source code in versions/converters.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 def version_set_to_specifier ( version_set : VersionSet ) -> Specifier : \"\"\"Converts a [`VersionSet`][versions.version_sets.VersionSet] to [`Specifier`][versions.specifiers.Specifier]. Arguments: version_set: The version set to convert. Returns: The converted version specifier. \"\"\" if is_version_empty ( version_set ): return SpecifierFalse () if is_version_point ( version_set ): return SpecifierSingle ( OperatorType . DOUBLE_EQUAL , version_set . version ) if is_version_range ( version_set ): if version_set . is_empty (): return SpecifierFalse () if version_set . is_universe (): return SpecifierTrue () if version_set . is_point (): return SpecifierSingle ( OperatorType . DOUBLE_EQUAL , version_set . version ) min = version_set . min max = version_set . max min_specifier = None max_specifier = None if min : min_type = ( OperatorType . GREATER_OR_EQUAL if version_set . include_min else OperatorType . GREATER ) min_specifier = SpecifierSingle ( min_type , min ) if max : max_type = OperatorType . LESS_OR_EQUAL if version_set . include_max else OperatorType . LESS max_specifier = SpecifierSingle ( max_type , max ) if min_specifier and max_specifier : return SpecifierAll . of ( min_specifier , max_specifier ) specifier = min_specifier or max_specifier if specifier is None : # pragma: no cover raise InternalError ( EXPECTED_MIN_OR_MAX ) return specifier if is_version_union ( version_set ): exclude_version = version_set . exclude_version if exclude_version : return SpecifierSingle ( OperatorType . NOT_EQUAL , exclude_version ) return SpecifierAny . of_iterable ( map ( version_set_to_specifier , version_set . items )) raise TypeError ( UNEXPECTED_VERSION_SET . format ( repr ( version_set )))","title":"version_set_to_specifier()"},{"location":"reference/errors/","text":"ParseError Bases: ValueError Parsing has failed. Source code in versions/errors.py 10 11 class ParseError ( ValueError ): \"\"\"Parsing has failed.\"\"\" ParseSpecificationError Bases: ParseError Parsing a specification has failed. Source code in versions/errors.py 14 15 class ParseSpecificationError ( ParseError ): \"\"\"Parsing a specification has failed.\"\"\" ParseTagError Bases: ParseError Parsing a version tag has failed. Source code in versions/errors.py 18 19 class ParseTagError ( ParseError ): \"\"\"Parsing a version tag has failed.\"\"\" ParseVersionError Bases: ParseError Parsing a version has failed. Source code in versions/errors.py 22 23 class ParseVersionError ( ParseError ): \"\"\"Parsing a version has failed.\"\"\" InternalError Bases: RuntimeError An internal error has occured. Source code in versions/errors.py 26 27 class InternalError ( RuntimeError ): \"\"\"An internal error has occured.\"\"\"","title":"Errors"},{"location":"reference/errors/#versions.errors.ParseError","text":"Bases: ValueError Parsing has failed. Source code in versions/errors.py 10 11 class ParseError ( ValueError ): \"\"\"Parsing has failed.\"\"\"","title":"ParseError"},{"location":"reference/errors/#versions.errors.ParseSpecificationError","text":"Bases: ParseError Parsing a specification has failed. Source code in versions/errors.py 14 15 class ParseSpecificationError ( ParseError ): \"\"\"Parsing a specification has failed.\"\"\"","title":"ParseSpecificationError"},{"location":"reference/errors/#versions.errors.ParseTagError","text":"Bases: ParseError Parsing a version tag has failed. Source code in versions/errors.py 18 19 class ParseTagError ( ParseError ): \"\"\"Parsing a version tag has failed.\"\"\"","title":"ParseTagError"},{"location":"reference/errors/#versions.errors.ParseVersionError","text":"Bases: ParseError Parsing a version has failed. Source code in versions/errors.py 22 23 class ParseVersionError ( ParseError ): \"\"\"Parsing a version has failed.\"\"\"","title":"ParseVersionError"},{"location":"reference/errors/#versions.errors.InternalError","text":"Bases: RuntimeError An internal error has occured. Source code in versions/errors.py 26 27 class InternalError ( RuntimeError ): \"\"\"An internal error has occured.\"\"\"","title":"InternalError"},{"location":"reference/functions/","text":"parse_version ( string : str , version_type : Type [ Version ] = Version ) -> Version Parses a string into a version of version_type . Parameters: Name Type Description Default string str The string to parse. required version_type Type [ Version ] The version type to use in conversion. Version Returns: Type Description Version The newly parsed Version . Source code in versions/functions.py 27 28 29 30 31 32 33 34 35 36 37 def parse_version ( string : str , version_type : Type [ Version ] = Version ) -> Version : \"\"\"Parses a `string` into a version of `version_type`. Arguments: string: The string to parse. version_type: The version type to use in conversion. Returns: The newly parsed [`Version`][versions.version.Version]. \"\"\" return VersionParser ( version_type ) . parse ( string ) parse_specifier ( string : str , version_type : Type [ Version ] = Version ) -> Specifier Parses a string into a version specifier with versions of version_type . Parameters: Name Type Description Default string str The string to parse. required version_type Type [ Version ] The version type to use in conversion. Version Returns: Type Description Specifier The newly parsed Specifier . Source code in versions/functions.py 40 41 42 43 44 45 46 47 48 49 50 def parse_specifier ( string : str , version_type : Type [ Version ] = Version ) -> Specifier : \"\"\"Parses a `string` into a version specifier with versions of `version_type`. Arguments: string: The string to parse. version_type: The version type to use in conversion. Returns: The newly parsed [`Specifier`][versions.specifiers.Specifier]. \"\"\" return SpecifierParser ( VersionParser ( version_type )) . parse ( string ) parse_version_set ( string : str , version_type : Type [ Version ] = Version ) -> VersionSet Parses a string into a version set with versions of version_type . Parameters: Name Type Description Default string str The string to parse. required version_type Type [ Version ] The version type to use in conversion. Version Returns: Type Description VersionSet The newly parsed VersionSet . Source code in versions/functions.py 53 54 55 56 57 58 59 60 61 62 63 def parse_version_set ( string : str , version_type : Type [ Version ] = Version ) -> VersionSet : \"\"\"Parses a `string` into a version set with versions of `version_type`. Arguments: string: The string to parse. version_type: The version type to use in conversion. Returns: The newly parsed [`VersionSet`][versions.version_sets.VersionSet]. \"\"\" return VersionSetParser ( SpecifierParser ( VersionParser ( version_type ))) . parse ( string )","title":"Functions"},{"location":"reference/functions/#versions.functions.parse_version","text":"Parses a string into a version of version_type . Parameters: Name Type Description Default string str The string to parse. required version_type Type [ Version ] The version type to use in conversion. Version Returns: Type Description Version The newly parsed Version . Source code in versions/functions.py 27 28 29 30 31 32 33 34 35 36 37 def parse_version ( string : str , version_type : Type [ Version ] = Version ) -> Version : \"\"\"Parses a `string` into a version of `version_type`. Arguments: string: The string to parse. version_type: The version type to use in conversion. Returns: The newly parsed [`Version`][versions.version.Version]. \"\"\" return VersionParser ( version_type ) . parse ( string )","title":"parse_version()"},{"location":"reference/functions/#versions.functions.parse_specifier","text":"Parses a string into a version specifier with versions of version_type . Parameters: Name Type Description Default string str The string to parse. required version_type Type [ Version ] The version type to use in conversion. Version Returns: Type Description Specifier The newly parsed Specifier . Source code in versions/functions.py 40 41 42 43 44 45 46 47 48 49 50 def parse_specifier ( string : str , version_type : Type [ Version ] = Version ) -> Specifier : \"\"\"Parses a `string` into a version specifier with versions of `version_type`. Arguments: string: The string to parse. version_type: The version type to use in conversion. Returns: The newly parsed [`Specifier`][versions.specifiers.Specifier]. \"\"\" return SpecifierParser ( VersionParser ( version_type )) . parse ( string )","title":"parse_specifier()"},{"location":"reference/functions/#versions.functions.parse_version_set","text":"Parses a string into a version set with versions of version_type . Parameters: Name Type Description Default string str The string to parse. required version_type Type [ Version ] The version type to use in conversion. Version Returns: Type Description VersionSet The newly parsed VersionSet . Source code in versions/functions.py 53 54 55 56 57 58 59 60 61 62 63 def parse_version_set ( string : str , version_type : Type [ Version ] = Version ) -> VersionSet : \"\"\"Parses a `string` into a version set with versions of `version_type`. Arguments: string: The string to parse. version_type: The version type to use in conversion. Returns: The newly parsed [`VersionSet`][versions.version_sets.VersionSet]. \"\"\" return VersionSetParser ( SpecifierParser ( VersionParser ( version_type ))) . parse ( string )","title":"parse_version_set()"},{"location":"reference/meta/","text":"version_info = parse_version ( version ) module-attribute The library version represented as a Version . python_version_info = Version . from_parts ( python_major , python_minor , python_micro ) module-attribute The python version represented as a Version .","title":"Meta"},{"location":"reference/meta/#versions.meta.version_info","text":"The library version represented as a Version .","title":"version_info"},{"location":"reference/meta/#versions.meta.python_version_info","text":"The python version represented as a Version .","title":"python_version_info"},{"location":"reference/operators/","text":"Matches = Binary [ Version , Version , bool ] module-attribute The (version, against) -> bool function. PartialMatches = Unary [ Version , bool ] module-attribute The (version) -> bool function. Translate = Unary [ Version , VersionSet ] module-attribute The (version) -> version_set function. OperatorType Bases: Enum Represents operator types. Source code in versions/operators.py 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 class OperatorType ( Enum ): \"\"\"Represents operator types.\"\"\" # official constraints TILDE_EQUAL = TILDE_EQUAL \"\"\"The binary `~=` operator.\"\"\" DOUBLE_EQUAL = DOUBLE_EQUAL \"\"\"The binary `==` operator.\"\"\" NOT_EQUAL = NOT_EQUAL \"\"\"The binary `!=` operator.\"\"\" LESS = LESS \"\"\"The binary `<` operator.\"\"\" LESS_OR_EQUAL = LESS_OR_EQUAL \"\"\"The binary `<=` operator.\"\"\" GREATER = GREATER \"\"\"The binary `>` operator.\"\"\" GREATER_OR_EQUAL = GREATER_OR_EQUAL \"\"\"The binary `>=` operator.\"\"\" # additional constraints CARET = CARET \"\"\"The unary `^` operator.\"\"\" EQUAL = EQUAL \"\"\"The binary `=` operator.\"\"\" TILDE = TILDE \"\"\"The unary `~` operator.\"\"\" # wildcard constraints WILDCARD_DOUBLE_EQUAL = WILDCARD_DOUBLE_EQUAL \"\"\"The wildcard binary `==*` operator.\"\"\" WILDCARD_EQUAL = WILDCARD_EQUAL \"\"\"The wildcard binary `=*` operator.\"\"\" WILDCARD_NOT_EQUAL = WILDCARD_NOT_EQUAL \"\"\"The wildcard binary `!=*` operator.\"\"\" def is_wildcard ( self ) -> bool : \"\"\"Checks if an operator is *wildcard*. Returns: Whether the operator is *wildcard*. \"\"\" return self in WILDCARD def is_equals ( self ) -> bool : \"\"\"Checks if an operator is *equals*. Returns: Whether the operator is *equals*. \"\"\" return self in EQUALS def is_unary ( self ) -> bool : \"\"\"Checks if an operator is *unary*. Returns: Whether the operator is *unary*. \"\"\" return self in UNARY def __eq__ ( self , other : Any ) -> bool : if is_same_type ( other , self ): return ( self . is_equals () and other . is_equals ()) or super () . __eq__ ( other ) return NotImplemented def __hash__ ( self ) -> int : return super () . __hash__ () # type: ignore @property def string ( self ) -> str : return wildcard_type ( self . value ) TILDE_EQUAL = TILDE_EQUAL class-attribute The binary ~= operator. DOUBLE_EQUAL = DOUBLE_EQUAL class-attribute The binary == operator. NOT_EQUAL = NOT_EQUAL class-attribute The binary != operator. LESS = LESS class-attribute The binary < operator. LESS_OR_EQUAL = LESS_OR_EQUAL class-attribute The binary <= operator. GREATER = GREATER class-attribute The binary > operator. GREATER_OR_EQUAL = GREATER_OR_EQUAL class-attribute The binary >= operator. CARET = CARET class-attribute The unary ^ operator. EQUAL = EQUAL class-attribute The binary = operator. TILDE = TILDE class-attribute The unary ~ operator. WILDCARD_DOUBLE_EQUAL = WILDCARD_DOUBLE_EQUAL class-attribute The wildcard binary ==* operator. WILDCARD_EQUAL = WILDCARD_EQUAL class-attribute The wildcard binary =* operator. WILDCARD_NOT_EQUAL = WILDCARD_NOT_EQUAL class-attribute The wildcard binary !=* operator. is_wildcard () -> bool Checks if an operator is wildcard . Returns: Type Description bool Whether the operator is wildcard . Source code in versions/operators.py 700 701 702 703 704 705 706 def is_wildcard ( self ) -> bool : \"\"\"Checks if an operator is *wildcard*. Returns: Whether the operator is *wildcard*. \"\"\" return self in WILDCARD is_equals () -> bool Checks if an operator is equals . Returns: Type Description bool Whether the operator is equals . Source code in versions/operators.py 708 709 710 711 712 713 714 def is_equals ( self ) -> bool : \"\"\"Checks if an operator is *equals*. Returns: Whether the operator is *equals*. \"\"\" return self in EQUALS is_unary () -> bool Checks if an operator is unary . Returns: Type Description bool Whether the operator is unary . Source code in versions/operators.py 716 717 718 719 720 721 722 def is_unary ( self ) -> bool : \"\"\"Checks if an operator is *unary*. Returns: Whether the operator is *unary*. \"\"\" return self in UNARY Operator Bases: Representation , ToString Represents operators. Source code in versions/operators.py 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 @frozen ( repr = False ) class Operator ( Representation , ToString ): \"\"\"Represents operators.\"\"\" type : OperatorType \"\"\"The operator type.\"\"\" version : Version \"\"\"The operator version.\"\"\" def is_unary ( self ) -> bool : \"\"\"Checks if an operator is *unary*. Returns: Whether the operator is *unary*. \"\"\" return self . type . is_unary () def is_wildcard ( self ) -> bool : \"\"\"Checks if an operator is *wildcard*. Returns: Whether the operator is *wildcard*. \"\"\" return self . type . is_wildcard () @property def matches_and_translate ( self ) -> Tuple [ Matches , Translate ]: return OPERATOR [ self . type ] @property def matches ( self ) -> Matches : \"\"\"The `matches` function representing the operator.\"\"\" matches , _translate = self . matches_and_translate return matches @property def translate ( self ) -> Translate : \"\"\"The `translate` function representing the operator.\"\"\" _matches , translate = self . matches_and_translate return translate @property def partial_matches ( self ) -> PartialMatches : \"\"\"The partial `matches` function with `self.version` as the `against` version.\"\"\" return partial_matches ( self . matches , self . version ) def to_string ( self ) -> str : \"\"\"Converts an [`Operator`][versions.operators.Operator] to its string representation. Returns: The operator string. \"\"\" string = self . version . to_string () if self . is_wildcard (): string = wildcard_string ( string ) if self . is_unary (): return concat_empty_args ( self . type . string , string ) return concat_space_args ( self . type . string , string ) def to_short_string ( self ) -> str : \"\"\"Converts an [`Operator`][versions.operators.Operator] to its *short* string representation. Returns: The *short* operator string. \"\"\" string = self . version . to_short_string () if self . is_wildcard (): string = wildcard_string ( string ) return concat_empty_args ( self . type . string , string ) type : OperatorType class-attribute The operator type. version : Version class-attribute The operator version. is_unary () -> bool Checks if an operator is unary . Returns: Type Description bool Whether the operator is unary . Source code in versions/operators.py 775 776 777 778 779 780 781 def is_unary ( self ) -> bool : \"\"\"Checks if an operator is *unary*. Returns: Whether the operator is *unary*. \"\"\" return self . type . is_unary () is_wildcard () -> bool Checks if an operator is wildcard . Returns: Type Description bool Whether the operator is wildcard . Source code in versions/operators.py 783 784 785 786 787 788 789 def is_wildcard ( self ) -> bool : \"\"\"Checks if an operator is *wildcard*. Returns: Whether the operator is *wildcard*. \"\"\" return self . type . is_wildcard () matches () -> Matches property The matches function representing the operator. Source code in versions/operators.py 795 796 797 798 799 800 @property def matches ( self ) -> Matches : \"\"\"The `matches` function representing the operator.\"\"\" matches , _translate = self . matches_and_translate return matches translate () -> Translate property The translate function representing the operator. Source code in versions/operators.py 802 803 804 805 806 807 @property def translate ( self ) -> Translate : \"\"\"The `translate` function representing the operator.\"\"\" _matches , translate = self . matches_and_translate return translate partial_matches () -> PartialMatches property The partial matches function with self.version as the against version. Source code in versions/operators.py 809 810 811 812 @property def partial_matches ( self ) -> PartialMatches : \"\"\"The partial `matches` function with `self.version` as the `against` version.\"\"\" return partial_matches ( self . matches , self . version ) to_string () -> str Converts an Operator to its string representation. Returns: Type Description str The operator string. Source code in versions/operators.py 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 def to_string ( self ) -> str : \"\"\"Converts an [`Operator`][versions.operators.Operator] to its string representation. Returns: The operator string. \"\"\" string = self . version . to_string () if self . is_wildcard (): string = wildcard_string ( string ) if self . is_unary (): return concat_empty_args ( self . type . string , string ) return concat_space_args ( self . type . string , string ) to_short_string () -> str Converts an Operator to its short string representation. Returns: Type Description str The short operator string. Source code in versions/operators.py 830 831 832 833 834 835 836 837 838 839 840 841 def to_short_string ( self ) -> str : \"\"\"Converts an [`Operator`][versions.operators.Operator] to its *short* string representation. Returns: The *short* operator string. \"\"\" string = self . version . to_short_string () if self . is_wildcard (): string = wildcard_string ( string ) return concat_empty_args ( self . type . string , string ) next_caret_breaking ( version : V ) -> V Returns the next breaking version according to the caret ( ^ ) strategy. This function is slightly convoluted due to handling 0.x.y versions. See next_breaking for more information. Example >>> from versions import next_caret_breaking , parse_version >>> version = parse_version ( \"1.0.0\" ) >>> version < Version ( 1.0.0 ) > >>> next_caret_breaking ( version ) < Version ( 2.0.0 ) > Parameters: Name Type Description Default version V The version to find next breaking version of. required Returns: Type Description V The next breaking version according to the version . Source code in versions/operators.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def next_caret_breaking ( version : V ) -> V : \"\"\"Returns the next breaking version according to the *caret* (`^`) strategy. This function is slightly convoluted due to handling `0.x.y` versions. See [`next_breaking`][versions.version.Version.next_breaking] for more information. Example: ```python >>> from versions import next_caret_breaking, parse_version >>> version = parse_version(\"1.0.0\") >>> version <Version (1.0.0)> >>> next_caret_breaking(version) <Version (2.0.0)> ``` Arguments: version: The version to find next breaking version of. Returns: The next breaking version according to the `version`. \"\"\" return version . next_breaking () next_tilde_equal_breaking ( version : V ) -> V Returns the next breaking version according to the tilde-equal ( ~= ) strategy. This function simply bumps the second to last part of the release. Example >>> from versions import next_tilde_equal_breaking , parse_version >>> version = parse_version ( \"1.2.0\" ) >>> version < Version ( 1.2.0 ) > >>> next_tilde_equal_breaking ( version ) < Version ( 1.3.0 ) > >>> invalid = parse_version ( \"1\" ) >>> next_tilde_equal_breaking ( invalid ) Traceback ( most recent call last ): ... ValueError : ` ~= ` can not be used with with a single version segment Parameters: Name Type Description Default version V The version to find the next breaking version of. required Returns: Type Description V The next breaking Version according to the version . Source code in versions/operators.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 def next_tilde_equal_breaking ( version : V ) -> V : \"\"\"Returns the next breaking version according to the *tilde-equal* (`~=`) strategy. This function simply bumps the second to last part of the release. Example: ```python >>> from versions import next_tilde_equal_breaking, parse_version >>> version = parse_version(\"1.2.0\") >>> version <Version (1.2.0)> >>> next_tilde_equal_breaking(version) <Version (1.3.0)> ``` ```python >>> invalid = parse_version(\"1\") >>> next_tilde_equal_breaking(invalid) Traceback (most recent call last): ... ValueError: `~=` can not be used with with a single version segment ``` Arguments: version: The version to find the next breaking version of. Returns: The next breaking [`Version`][versions.version.Version] according to the `version`. \"\"\" index = version . last_index if index : return version . to_stable () . next_at ( index - 1 ) raise ValueError ( CAN_NOT_USE_TILDE_EQUAL ) next_tilde_breaking ( version : V ) -> V Returns the next breaking version according to the tilde ( ~ ) strategy. This function simply bumps the minor part of the release if it is present, otherwise the major part is bumped. Example >>> from versions import next_tilde_equal_breaking , parse_version >>> version = parse_version ( \"2.1.0\" ) >>> version < Version ( 2.1.0 ) > >>> next_tilde_breaking ( version ) < Version ( 2.2.0 ) > Parameters: Name Type Description Default version V The version to find the next breaking version of. required Returns: Type Description V The next breaking Version according to the version . Source code in versions/operators.py 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 def next_tilde_breaking ( version : V ) -> V : \"\"\"Returns the next breaking version according to the *tilde* (`~`) strategy. This function simply bumps the minor part of the release if it is present, otherwise the major part is bumped. Example: ```python >>> from versions import next_tilde_equal_breaking, parse_version >>> version = parse_version(\"2.1.0\") >>> version <Version (2.1.0)> >>> next_tilde_breaking(version) <Version (2.2.0)> ``` Arguments: version: The version to find the next breaking version of. Returns: The next breaking [`Version`][versions.version.Version] according to the `version`. \"\"\" if version . has_minor (): return version . next_minor () return version . next_major () next_wildcard_breaking ( version : V ) -> Optional [ V ] Returns the next breaking version according to the wildcard ( * ) strategy. There are three cases to handle: If the wildcard is used within the pre-release tag of the version, next breaking version has the same release with pre-release tag removed. For example, x.y.z-rc.* is bumped to x.y.z . If the wildcard is used within the post-release tag of the version, next breaking version has the last part of the release bumped. For instance, x.y.z-post.* is bumped to x.y.z' , where z' = z + 1 . Otherwise, the second to last part of the release is bumped. For example, x.y.* is bumped to x.y'.0 , where y' = y + 1 . Note This function returns None if the given version is * . Example >>> from versions import next_wildcard_breaking , parse_version >>> version = parse_version ( \"4.2.0\" ) >>> version < Version ( 4.2.0 ) > >>> next_wildcard_breaking ( version ) < Version ( 4.3.0 ) > >>> other = parse_version ( \"1.2.3-rc.0\" ) >>> other < Version ( 1.2.3 - rc .0 ) > >>> next_wildcard_breaking ( other ) < Version ( 1.2.3 ) > >>> another = parse_version ( \"0.6.8-post.0\" ) >>> another < Version ( 0.6.8 - post .0 ) > >>> next_wildcard_breaking ( another ) < Version ( 0.6.9 ) > # nice Parameters: Name Type Description Default version V The version to find the next breaking version of. required Returns: Type Description Optional [ V ] The next breaking Version according to the version , or None . Source code in versions/operators.py 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 def next_wildcard_breaking ( version : V ) -> Optional [ V ]: \"\"\"Returns the next breaking version according to the *wildcard* (`*`) strategy. There are three cases to handle: - If the wildcard is used within the *pre-release* tag of the version, next breaking version has the same release with *pre-release* tag removed. For example, `x.y.z-rc.*` is bumped to `x.y.z`. - If the wildcard is used within the *post-release* tag of the version, next breaking version has the last part of the release bumped. For instance, `x.y.z-post.*` is bumped to `x.y.z'`, where `z' = z + 1`. - Otherwise, the second to last part of the release is bumped. For example, `x.y.*` is bumped to `x.y'.0`, where `y' = y + 1`. Note: This function returns [`None`][None] if the given version is `*`. Example: ```python >>> from versions import next_wildcard_breaking, parse_version >>> version = parse_version(\"4.2.0\") >>> version <Version (4.2.0)> >>> next_wildcard_breaking(version) <Version (4.3.0)> >>> other = parse_version(\"1.2.3-rc.0\") >>> other <Version (1.2.3-rc.0)> >>> next_wildcard_breaking(other) <Version (1.2.3)> >>> another = parse_version(\"0.6.8-post.0\") >>> another <Version (0.6.8-post.0)> >>> next_wildcard_breaking(another) <Version (0.6.9)> # nice ``` Arguments: version: The version to find the next breaking version of. Returns: The next breaking [`Version`][versions.version.Version] according to the `version`, or [`None`][None]. \"\"\" index = version . last_index if version . is_stable () and not version . is_post_release (): # the wildcard was used within the release segment if not index : return None index -= 1 return version . next_at ( index ) # this will take care of unstable releases matches_caret ( version : Version , against : Version ) -> bool Checks if the version matches the caret ( ^ ) specification. This is equivalent to: against <= version < next_caret_breaking ( against ) Parameters: Name Type Description Default version Version The version to check. required against Version The version to check the version against. required Returns: Type Description bool Whether the version matches against . Source code in versions/operators.py 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 def matches_caret ( version : Version , against : Version ) -> bool : \"\"\"Checks if the `version` matches the *caret* (`^`) specification. This is equivalent to: ```python against <= version < next_caret_breaking(against) ``` Arguments: version: The version to check. against: The version to check the `version` against. Returns: Whether the `version` matches `against`. \"\"\" return against <= version < next_caret_breaking ( against ) matches_tilde_equal ( version : Version , against : Version ) -> bool Checks if the version matches the tilde-equal ( ~= ) specification. This is equivalent to: against <= version < next_tilde_equal_breaking ( against ) Parameters: Name Type Description Default version Version The version to check. required against Version The version to check the version against. required Returns: Type Description bool Whether the version matches against . Source code in versions/operators.py 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 def matches_tilde_equal ( version : Version , against : Version ) -> bool : \"\"\"Checks if the `version` matches the *tilde-equal* (`~=`) specification. This is equivalent to: ```python against <= version < next_tilde_equal_breaking(against) ``` Arguments: version: The version to check. against: The version to check the `version` against. Returns: Whether the `version` matches `against`. \"\"\" return against <= version < next_tilde_equal_breaking ( against ) matches_tilde ( version : Version , against : Version ) -> bool Checks if the version matches the tilde ( ~ ) specification. This is equivalent to: against <= version < next_tilde_breaking ( against ) Parameters: Name Type Description Default version Version The version to check. required against Version The version to check the version against. required Returns: Type Description bool Whether the version matches against . Source code in versions/operators.py 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 def matches_tilde ( version : Version , against : Version ) -> bool : \"\"\"Checks if the `version` matches the *tilde* (`~`) specification. This is equivalent to: ```python against <= version < next_tilde_breaking(against) ``` Arguments: version: The version to check. against: The version to check the `version` against. Returns: Whether the `version` matches `against`. \"\"\" return against <= version < next_tilde_breaking ( against ) matches_equal ( version : Version , against : Version ) -> bool Checks if the version matches the equal ( == ) specification. This is equivalent to: version == against Parameters: Name Type Description Default version Version The version to check. required against Version The version to check the version against. required Returns: Type Description bool Whether the version matches against . Source code in versions/operators.py 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 def matches_equal ( version : Version , against : Version ) -> bool : \"\"\"Checks if the `version` matches the *equal* (`==`) specification. This is equivalent to: ```python version == against ``` Arguments: version: The version to check. against: The version to check the `version` against. Returns: Whether the `version` matches `against`. \"\"\" return version == against matches_not_equal ( version : Version , against : Version ) -> bool Checks if the version matches the not-equal ( != ) specification. This is equivalent to: version != against Parameters: Name Type Description Default version Version The version to check. required against Version The version to check the version against. required Returns: Type Description bool Whether the version matches against . Source code in versions/operators.py 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 def matches_not_equal ( version : Version , against : Version ) -> bool : \"\"\"Checks if the `version` matches the *not-equal* (`!=`) specification. This is equivalent to: ```python version != against ``` Arguments: version: The version to check. against: The version to check the `version` against. Returns: Whether the `version` matches `against`. \"\"\" return version != against matches_less ( version : Version , against : Version ) -> bool Checks if the version matches the less ( < ) specification. This is equivalent to: version < against Parameters: Name Type Description Default version Version The version to check. required against Version The version to check the version against. required Returns: Type Description bool Whether the version matches against . Source code in versions/operators.py 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 def matches_less ( version : Version , against : Version ) -> bool : \"\"\"Checks if the `version` matches the *less* (`<`) specification. This is equivalent to: ```python version < against ``` Arguments: version: The version to check. against: The version to check the `version` against. Returns: Whether the `version` matches `against`. \"\"\" return version < against matches_less_or_equal ( version : Version , against : Version ) -> bool Checks if the version matches the less-or-equal ( <= ) specification. This is equivalent to: version <= against Parameters: Name Type Description Default version Version The version to check. required against Version The version to check the version against. required Returns: Type Description bool Whether the version matches against . Source code in versions/operators.py 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 def matches_less_or_equal ( version : Version , against : Version ) -> bool : \"\"\"Checks if the `version` matches the *less-or-equal* (`<=`) specification. This is equivalent to: ```python version <= against ``` Arguments: version: The version to check. against: The version to check the `version` against. Returns: Whether the `version` matches `against`. \"\"\" return version <= against matches_greater ( version : Version , against : Version ) -> bool Checks if the version matches the greater ( > ) specification. This is equivalent to: version > against Parameters: Name Type Description Default version Version The version to check. required against Version The version to check the version against. required Returns: Type Description bool Whether the version matches against . Source code in versions/operators.py 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 def matches_greater ( version : Version , against : Version ) -> bool : \"\"\"Checks if the `version` matches the *greater* (`>`) specification. This is equivalent to: ```python version > against ``` Arguments: version: The version to check. against: The version to check the `version` against. Returns: Whether the `version` matches `against`. \"\"\" return version > against matches_greater_or_equal ( version : Version , against : Version ) -> bool Checks if the version matches the greater-or-equal ( >= ) specification. This is equivalent to: version >= against Parameters: Name Type Description Default version Version The version to check. required against Version The version to check the version against. required Returns: Type Description bool Whether the version matches against . Source code in versions/operators.py 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 def matches_greater_or_equal ( version : Version , against : Version ) -> bool : \"\"\"Checks if the `version` matches the *greater-or-equal* (`>=`) specification. This is equivalent to: ```python version >= against ``` Arguments: version: The version to check. against: The version to check the `version` against. Returns: Whether the `version` matches `against`. \"\"\" return version >= against matches_wildcard_equal ( version : Version , against : Version ) -> bool Checks if the version matches the wildcard-equal ( == * ) specification. This is equivalent to: wildcard = next_wildcard_breaking ( against ) wildcard is None or against <= version < wildcard Parameters: Name Type Description Default version Version The version to check. required against Version The version to check the version against. required Returns: Type Description bool Whether the version matches against . Source code in versions/operators.py 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 def matches_wildcard_equal ( version : Version , against : Version ) -> bool : \"\"\"Checks if the `version` matches the *wildcard-equal* (`== *`) specification. This is equivalent to: ```python wildcard = next_wildcard_breaking(against) wildcard is None or against <= version < wildcard ``` Arguments: version: The version to check. against: The version to check the `version` against. Returns: Whether the `version` matches `against`. \"\"\" wildcard = next_wildcard_breaking ( against ) if wildcard is None : return True return against <= version < wildcard matches_wildcard_not_equal ( version : Version , against : Version ) -> bool Checks if the version matches the wildcard-not-equal ( != * ) specification. This is equivalent to: wildcard = next_wildcard_breaking ( against ) wildcard is not None and ( version < against or version >= wildcard ) Parameters: Name Type Description Default version Version The version to check. required against Version The version to check the version against. required Returns: Type Description bool Whether the version matches against . Source code in versions/operators.py 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 def matches_wildcard_not_equal ( version : Version , against : Version ) -> bool : \"\"\"Checks if the `version` matches the *wildcard-not-equal* (`!= *`) specification. This is equivalent to: ```python wildcard = next_wildcard_breaking(against) wildcard is not None and (version < against or version >= wildcard) ``` Arguments: version: The version to check. against: The version to check the `version` against. Returns: Whether the `version` matches `against`. \"\"\" return not matches_wildcard_equal ( version , against ) translate_caret ( version : Version ) -> VersionRange Translates the version into a version set according to the caret ( ^ ) strategy. This function returns the [version, next_caret_breaking(version)) range. Parameters: Name Type Description Default version Version The version to translate. required Returns: Type Description VersionRange The version set representing the caret specification. Source code in versions/operators.py 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 def translate_caret ( version : Version ) -> VersionRange : \"\"\"Translates the `version` into a version set according to the *caret* (`^`) strategy. This function returns the `[version, next_caret_breaking(version))` range. Arguments: version: The version to translate. Returns: The version set representing the *caret* specification. \"\"\" return VersionRange ( min = version , max = next_caret_breaking ( version ), include_min = True , include_max = False , ) translate_tilde_equal ( version : Version ) -> VersionRange Translates the version into a version set according to the tilde-equal ( ~= ) strategy. This function returns the [version, next_tilde_equal_breaking(version)) range. Parameters: Name Type Description Default version Version The version to translate. required Returns: Type Description VersionRange The version set representing the tilde-equal specification. Source code in versions/operators.py 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 def translate_tilde_equal ( version : Version ) -> VersionRange : \"\"\"Translates the `version` into a version set according to the *tilde-equal* (`~=`) strategy. This function returns the `[version, next_tilde_equal_breaking(version))` range. Arguments: version: The version to translate. Returns: The version set representing the *tilde-equal* specification. \"\"\" return VersionRange ( min = version , max = next_tilde_equal_breaking ( version ), include_min = True , include_max = False , ) translate_tilde ( version : Version ) -> VersionRange Translates the version into a version set according to the tilde ( ~ ) strategy. This function returns the [version, next_tilde_breaking(version)) range. Parameters: Name Type Description Default version Version The version to translate. required Returns: Type Description VersionRange The version set representing the tilde-equal specification. Source code in versions/operators.py 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 def translate_tilde ( version : Version ) -> VersionRange : \"\"\"Translates the `version` into a version set according to the *tilde* (`~`) strategy. This function returns the `[version, next_tilde_breaking(version))` range. Arguments: version: The version to translate. Returns: The version set representing the *tilde-equal* specification. \"\"\" return VersionRange ( min = version , max = next_tilde_breaking ( version ), include_min = True , include_max = False , ) translate_equal ( version : Version ) -> VersionPoint Translates the version into a version set according to the equal ( == ) strategy. This function returns the [version, version] range (aka version point). Parameters: Name Type Description Default version Version The version to translate. required Returns: Type Description VersionPoint The version set representing the equal specification. Source code in versions/operators.py 529 530 531 532 533 534 535 536 537 538 539 540 def translate_equal ( version : Version ) -> VersionPoint : \"\"\"Translates the `version` into a version set according to the *equal* (`==`) strategy. This function returns the `[version, version]` range (aka `version` point). Arguments: version: The version to translate. Returns: The version set representing the *equal* specification. \"\"\" return VersionPoint ( version ) translate_not_equal ( version : Version ) -> VersionUnion Translates the version into a version set according to the not-equal ( != ) strategy. This function returns the (\u03b5, version) | (version, \u03c9) union. Parameters: Name Type Description Default version Version The version to translate. required Returns: Type Description VersionUnion The version set representing the not-equal specification. Source code in versions/operators.py 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 def translate_not_equal ( version : Version ) -> VersionUnion : \"\"\"Translates the `version` into a version set according to the *not-equal* (`!=`) strategy. This function returns the `(\u03b5, version) | (version, \u03c9)` union. Arguments: version: The version to translate. Returns: The version set representing the *not-equal* specification. \"\"\" result = translate_equal ( version ) . complement () if is_version_union ( result ): return result raise InternalError ( UNEXPECTED_EQUAL_COMPLEMENT ) translate_less ( version : Version ) -> VersionRange Translates the version into a version set according to the less ( < ) strategy. This function returns the (\u03b5, version) range. Parameters: Name Type Description Default version Version The version to translate. required Returns: Type Description VersionRange The version set representing the less specification. Source code in versions/operators.py 565 566 567 568 569 570 571 572 573 574 575 576 def translate_less ( version : Version ) -> VersionRange : \"\"\"Translates the `version` into a version set according to the *less* (`<`) strategy. This function returns the `(\u03b5, version)` range. Arguments: version: The version to translate. Returns: The version set representing the *less* specification. \"\"\" return VersionRange ( max = version , include_max = False ) translate_less_or_equal ( version : Version ) -> VersionRange Translates the version into a version set according to the less-or-equal ( <= ) strategy. This function returns the (\u03b5, version] range. Parameters: Name Type Description Default version Version The version to translate. required Returns: Type Description VersionRange The version set representing the less-or-equal specification. Source code in versions/operators.py 579 580 581 582 583 584 585 586 587 588 589 590 def translate_less_or_equal ( version : Version ) -> VersionRange : \"\"\"Translates the `version` into a version set according to the *less-or-equal* (`<=`) strategy. This function returns the `(\u03b5, version]` range. Arguments: version: The version to translate. Returns: The version set representing the *less-or-equal* specification. \"\"\" return VersionRange ( max = version , include_max = True ) translate_greater ( version : Version ) -> VersionRange Translates the version into a version set according to the greater ( > ) strategy. This function returns the (version, \u03c9) range. Parameters: Name Type Description Default version Version The version to translate. required Returns: Type Description VersionRange The version set representing the greater specification. Source code in versions/operators.py 593 594 595 596 597 598 599 600 601 602 603 604 def translate_greater ( version : Version ) -> VersionRange : \"\"\"Translates the `version` into a version set according to the *greater* (`>`) strategy. This function returns the `(version, \u03c9)` range. Arguments: version: The version to translate. Returns: The version set representing the *greater* specification. \"\"\" return VersionRange ( min = version , include_min = False ) translate_greater_or_equal ( version : Version ) -> VersionRange Translates the version into a version set according to the greater-or-equal ( >= ) strategy. This function returns the [version, \u03c9) range. Parameters: Name Type Description Default version Version The version to translate. required Returns: Type Description VersionRange The version set representing the greater-or-equal specification. Source code in versions/operators.py 607 608 609 610 611 612 613 614 615 616 617 618 619 def translate_greater_or_equal ( version : Version ) -> VersionRange : \"\"\"Translates the `version` into a version set according to the *greater-or-equal* (`>=`) strategy. This function returns the `[version, \u03c9)` range. Arguments: version: The version to translate. Returns: The version set representing the *greater-or-equal* specification. \"\"\" return VersionRange ( min = version , include_min = True ) translate_wildcard_equal ( version : Version ) -> VersionRange Translates the version into a version set according to the wildcard-equal ( == * ) strategy. This function returns the [version, next_wildcard_version(version)) range in most cases, except for when the version is * ; then the (\u03b5, \u03c9) range is returned. Parameters: Name Type Description Default version Version The version to translate. required Returns: Type Description VersionRange The version set representing the wildcard-equal specification. Source code in versions/operators.py 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 def translate_wildcard_equal ( version : Version ) -> VersionRange : \"\"\"Translates the `version` into a version set according to the *wildcard-equal* (`== *`) strategy. This function returns the `[version, next_wildcard_version(version))` range in most cases, except for when the version is `*`; then the `(\u03b5, \u03c9)` range is returned. Arguments: version: The version to translate. Returns: The version set representing the *wildcard-equal* specification. \"\"\" wildcard = next_wildcard_breaking ( version ) if wildcard is None : return VersionRange () return VersionRange ( min = version , max = wildcard , include_min = True , include_max = False ) translate_wildcard_not_equal ( version : Version ) -> Union [ VersionEmpty , VersionUnion ] Translates the version into a version set according to the wildcard-not-equal ( != * ) strategy. This function returns the (\u03b5, version) | (next_wildcard_breaking(version), \u03c9) union in most cases, except for when the version is * ; then the {} empty set is returned. Parameters: Name Type Description Default version Version The version to translate. required Returns: Type Description Union [ VersionEmpty , VersionUnion ] The version set representing the wildcard-not-equal specification. Source code in versions/operators.py 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 def translate_wildcard_not_equal ( version : Version ) -> Union [ VersionEmpty , VersionUnion ]: \"\"\"Translates the `version` into a version set according to the *wildcard-not-equal* (`!= *`) strategy. This function returns the `(\u03b5, version) | (next_wildcard_breaking(version), \u03c9)` union in most cases, except for when the version is `*`; then the `{}` empty set is returned. Arguments: version: The version to translate. Returns: The version set representing the *wildcard-not-equal* specification. \"\"\" result = translate_wildcard_equal ( version ) . complement () if is_version_empty ( result ) or is_version_union ( result ): return result raise InternalError ( UNEXPECTED_WILDCARD_EQUAL_COMPLEMENT )","title":"Operators"},{"location":"reference/operators/#versions.operators.Matches","text":"The (version, against) -> bool function.","title":"Matches"},{"location":"reference/operators/#versions.operators.PartialMatches","text":"The (version) -> bool function.","title":"PartialMatches"},{"location":"reference/operators/#versions.operators.Translate","text":"The (version) -> version_set function.","title":"Translate"},{"location":"reference/operators/#versions.operators.OperatorType","text":"Bases: Enum Represents operator types. Source code in versions/operators.py 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 class OperatorType ( Enum ): \"\"\"Represents operator types.\"\"\" # official constraints TILDE_EQUAL = TILDE_EQUAL \"\"\"The binary `~=` operator.\"\"\" DOUBLE_EQUAL = DOUBLE_EQUAL \"\"\"The binary `==` operator.\"\"\" NOT_EQUAL = NOT_EQUAL \"\"\"The binary `!=` operator.\"\"\" LESS = LESS \"\"\"The binary `<` operator.\"\"\" LESS_OR_EQUAL = LESS_OR_EQUAL \"\"\"The binary `<=` operator.\"\"\" GREATER = GREATER \"\"\"The binary `>` operator.\"\"\" GREATER_OR_EQUAL = GREATER_OR_EQUAL \"\"\"The binary `>=` operator.\"\"\" # additional constraints CARET = CARET \"\"\"The unary `^` operator.\"\"\" EQUAL = EQUAL \"\"\"The binary `=` operator.\"\"\" TILDE = TILDE \"\"\"The unary `~` operator.\"\"\" # wildcard constraints WILDCARD_DOUBLE_EQUAL = WILDCARD_DOUBLE_EQUAL \"\"\"The wildcard binary `==*` operator.\"\"\" WILDCARD_EQUAL = WILDCARD_EQUAL \"\"\"The wildcard binary `=*` operator.\"\"\" WILDCARD_NOT_EQUAL = WILDCARD_NOT_EQUAL \"\"\"The wildcard binary `!=*` operator.\"\"\" def is_wildcard ( self ) -> bool : \"\"\"Checks if an operator is *wildcard*. Returns: Whether the operator is *wildcard*. \"\"\" return self in WILDCARD def is_equals ( self ) -> bool : \"\"\"Checks if an operator is *equals*. Returns: Whether the operator is *equals*. \"\"\" return self in EQUALS def is_unary ( self ) -> bool : \"\"\"Checks if an operator is *unary*. Returns: Whether the operator is *unary*. \"\"\" return self in UNARY def __eq__ ( self , other : Any ) -> bool : if is_same_type ( other , self ): return ( self . is_equals () and other . is_equals ()) or super () . __eq__ ( other ) return NotImplemented def __hash__ ( self ) -> int : return super () . __hash__ () # type: ignore @property def string ( self ) -> str : return wildcard_type ( self . value )","title":"OperatorType"},{"location":"reference/operators/#versions.operators.OperatorType.TILDE_EQUAL","text":"The binary ~= operator.","title":"TILDE_EQUAL"},{"location":"reference/operators/#versions.operators.OperatorType.DOUBLE_EQUAL","text":"The binary == operator.","title":"DOUBLE_EQUAL"},{"location":"reference/operators/#versions.operators.OperatorType.NOT_EQUAL","text":"The binary != operator.","title":"NOT_EQUAL"},{"location":"reference/operators/#versions.operators.OperatorType.LESS","text":"The binary < operator.","title":"LESS"},{"location":"reference/operators/#versions.operators.OperatorType.LESS_OR_EQUAL","text":"The binary <= operator.","title":"LESS_OR_EQUAL"},{"location":"reference/operators/#versions.operators.OperatorType.GREATER","text":"The binary > operator.","title":"GREATER"},{"location":"reference/operators/#versions.operators.OperatorType.GREATER_OR_EQUAL","text":"The binary >= operator.","title":"GREATER_OR_EQUAL"},{"location":"reference/operators/#versions.operators.OperatorType.CARET","text":"The unary ^ operator.","title":"CARET"},{"location":"reference/operators/#versions.operators.OperatorType.EQUAL","text":"The binary = operator.","title":"EQUAL"},{"location":"reference/operators/#versions.operators.OperatorType.TILDE","text":"The unary ~ operator.","title":"TILDE"},{"location":"reference/operators/#versions.operators.OperatorType.WILDCARD_DOUBLE_EQUAL","text":"The wildcard binary ==* operator.","title":"WILDCARD_DOUBLE_EQUAL"},{"location":"reference/operators/#versions.operators.OperatorType.WILDCARD_EQUAL","text":"The wildcard binary =* operator.","title":"WILDCARD_EQUAL"},{"location":"reference/operators/#versions.operators.OperatorType.WILDCARD_NOT_EQUAL","text":"The wildcard binary !=* operator.","title":"WILDCARD_NOT_EQUAL"},{"location":"reference/operators/#versions.operators.OperatorType.is_wildcard","text":"Checks if an operator is wildcard . Returns: Type Description bool Whether the operator is wildcard . Source code in versions/operators.py 700 701 702 703 704 705 706 def is_wildcard ( self ) -> bool : \"\"\"Checks if an operator is *wildcard*. Returns: Whether the operator is *wildcard*. \"\"\" return self in WILDCARD","title":"is_wildcard()"},{"location":"reference/operators/#versions.operators.OperatorType.is_equals","text":"Checks if an operator is equals . Returns: Type Description bool Whether the operator is equals . Source code in versions/operators.py 708 709 710 711 712 713 714 def is_equals ( self ) -> bool : \"\"\"Checks if an operator is *equals*. Returns: Whether the operator is *equals*. \"\"\" return self in EQUALS","title":"is_equals()"},{"location":"reference/operators/#versions.operators.OperatorType.is_unary","text":"Checks if an operator is unary . Returns: Type Description bool Whether the operator is unary . Source code in versions/operators.py 716 717 718 719 720 721 722 def is_unary ( self ) -> bool : \"\"\"Checks if an operator is *unary*. Returns: Whether the operator is *unary*. \"\"\" return self in UNARY","title":"is_unary()"},{"location":"reference/operators/#versions.operators.Operator","text":"Bases: Representation , ToString Represents operators. Source code in versions/operators.py 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 @frozen ( repr = False ) class Operator ( Representation , ToString ): \"\"\"Represents operators.\"\"\" type : OperatorType \"\"\"The operator type.\"\"\" version : Version \"\"\"The operator version.\"\"\" def is_unary ( self ) -> bool : \"\"\"Checks if an operator is *unary*. Returns: Whether the operator is *unary*. \"\"\" return self . type . is_unary () def is_wildcard ( self ) -> bool : \"\"\"Checks if an operator is *wildcard*. Returns: Whether the operator is *wildcard*. \"\"\" return self . type . is_wildcard () @property def matches_and_translate ( self ) -> Tuple [ Matches , Translate ]: return OPERATOR [ self . type ] @property def matches ( self ) -> Matches : \"\"\"The `matches` function representing the operator.\"\"\" matches , _translate = self . matches_and_translate return matches @property def translate ( self ) -> Translate : \"\"\"The `translate` function representing the operator.\"\"\" _matches , translate = self . matches_and_translate return translate @property def partial_matches ( self ) -> PartialMatches : \"\"\"The partial `matches` function with `self.version` as the `against` version.\"\"\" return partial_matches ( self . matches , self . version ) def to_string ( self ) -> str : \"\"\"Converts an [`Operator`][versions.operators.Operator] to its string representation. Returns: The operator string. \"\"\" string = self . version . to_string () if self . is_wildcard (): string = wildcard_string ( string ) if self . is_unary (): return concat_empty_args ( self . type . string , string ) return concat_space_args ( self . type . string , string ) def to_short_string ( self ) -> str : \"\"\"Converts an [`Operator`][versions.operators.Operator] to its *short* string representation. Returns: The *short* operator string. \"\"\" string = self . version . to_short_string () if self . is_wildcard (): string = wildcard_string ( string ) return concat_empty_args ( self . type . string , string )","title":"Operator"},{"location":"reference/operators/#versions.operators.Operator.type","text":"The operator type.","title":"type"},{"location":"reference/operators/#versions.operators.Operator.version","text":"The operator version.","title":"version"},{"location":"reference/operators/#versions.operators.Operator.is_unary","text":"Checks if an operator is unary . Returns: Type Description bool Whether the operator is unary . Source code in versions/operators.py 775 776 777 778 779 780 781 def is_unary ( self ) -> bool : \"\"\"Checks if an operator is *unary*. Returns: Whether the operator is *unary*. \"\"\" return self . type . is_unary ()","title":"is_unary()"},{"location":"reference/operators/#versions.operators.Operator.is_wildcard","text":"Checks if an operator is wildcard . Returns: Type Description bool Whether the operator is wildcard . Source code in versions/operators.py 783 784 785 786 787 788 789 def is_wildcard ( self ) -> bool : \"\"\"Checks if an operator is *wildcard*. Returns: Whether the operator is *wildcard*. \"\"\" return self . type . is_wildcard ()","title":"is_wildcard()"},{"location":"reference/operators/#versions.operators.Operator.matches","text":"The matches function representing the operator. Source code in versions/operators.py 795 796 797 798 799 800 @property def matches ( self ) -> Matches : \"\"\"The `matches` function representing the operator.\"\"\" matches , _translate = self . matches_and_translate return matches","title":"matches()"},{"location":"reference/operators/#versions.operators.Operator.translate","text":"The translate function representing the operator. Source code in versions/operators.py 802 803 804 805 806 807 @property def translate ( self ) -> Translate : \"\"\"The `translate` function representing the operator.\"\"\" _matches , translate = self . matches_and_translate return translate","title":"translate()"},{"location":"reference/operators/#versions.operators.Operator.partial_matches","text":"The partial matches function with self.version as the against version. Source code in versions/operators.py 809 810 811 812 @property def partial_matches ( self ) -> PartialMatches : \"\"\"The partial `matches` function with `self.version` as the `against` version.\"\"\" return partial_matches ( self . matches , self . version )","title":"partial_matches()"},{"location":"reference/operators/#versions.operators.Operator.to_string","text":"Converts an Operator to its string representation. Returns: Type Description str The operator string. Source code in versions/operators.py 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 def to_string ( self ) -> str : \"\"\"Converts an [`Operator`][versions.operators.Operator] to its string representation. Returns: The operator string. \"\"\" string = self . version . to_string () if self . is_wildcard (): string = wildcard_string ( string ) if self . is_unary (): return concat_empty_args ( self . type . string , string ) return concat_space_args ( self . type . string , string )","title":"to_string()"},{"location":"reference/operators/#versions.operators.Operator.to_short_string","text":"Converts an Operator to its short string representation. Returns: Type Description str The short operator string. Source code in versions/operators.py 830 831 832 833 834 835 836 837 838 839 840 841 def to_short_string ( self ) -> str : \"\"\"Converts an [`Operator`][versions.operators.Operator] to its *short* string representation. Returns: The *short* operator string. \"\"\" string = self . version . to_short_string () if self . is_wildcard (): string = wildcard_string ( string ) return concat_empty_args ( self . type . string , string )","title":"to_short_string()"},{"location":"reference/operators/#versions.operators.next_caret_breaking","text":"Returns the next breaking version according to the caret ( ^ ) strategy. This function is slightly convoluted due to handling 0.x.y versions. See next_breaking for more information. Example >>> from versions import next_caret_breaking , parse_version >>> version = parse_version ( \"1.0.0\" ) >>> version < Version ( 1.0.0 ) > >>> next_caret_breaking ( version ) < Version ( 2.0.0 ) > Parameters: Name Type Description Default version V The version to find next breaking version of. required Returns: Type Description V The next breaking version according to the version . Source code in versions/operators.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def next_caret_breaking ( version : V ) -> V : \"\"\"Returns the next breaking version according to the *caret* (`^`) strategy. This function is slightly convoluted due to handling `0.x.y` versions. See [`next_breaking`][versions.version.Version.next_breaking] for more information. Example: ```python >>> from versions import next_caret_breaking, parse_version >>> version = parse_version(\"1.0.0\") >>> version <Version (1.0.0)> >>> next_caret_breaking(version) <Version (2.0.0)> ``` Arguments: version: The version to find next breaking version of. Returns: The next breaking version according to the `version`. \"\"\" return version . next_breaking ()","title":"next_caret_breaking()"},{"location":"reference/operators/#versions.operators.next_tilde_equal_breaking","text":"Returns the next breaking version according to the tilde-equal ( ~= ) strategy. This function simply bumps the second to last part of the release. Example >>> from versions import next_tilde_equal_breaking , parse_version >>> version = parse_version ( \"1.2.0\" ) >>> version < Version ( 1.2.0 ) > >>> next_tilde_equal_breaking ( version ) < Version ( 1.3.0 ) > >>> invalid = parse_version ( \"1\" ) >>> next_tilde_equal_breaking ( invalid ) Traceback ( most recent call last ): ... ValueError : ` ~= ` can not be used with with a single version segment Parameters: Name Type Description Default version V The version to find the next breaking version of. required Returns: Type Description V The next breaking Version according to the version . Source code in versions/operators.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 def next_tilde_equal_breaking ( version : V ) -> V : \"\"\"Returns the next breaking version according to the *tilde-equal* (`~=`) strategy. This function simply bumps the second to last part of the release. Example: ```python >>> from versions import next_tilde_equal_breaking, parse_version >>> version = parse_version(\"1.2.0\") >>> version <Version (1.2.0)> >>> next_tilde_equal_breaking(version) <Version (1.3.0)> ``` ```python >>> invalid = parse_version(\"1\") >>> next_tilde_equal_breaking(invalid) Traceback (most recent call last): ... ValueError: `~=` can not be used with with a single version segment ``` Arguments: version: The version to find the next breaking version of. Returns: The next breaking [`Version`][versions.version.Version] according to the `version`. \"\"\" index = version . last_index if index : return version . to_stable () . next_at ( index - 1 ) raise ValueError ( CAN_NOT_USE_TILDE_EQUAL )","title":"next_tilde_equal_breaking()"},{"location":"reference/operators/#versions.operators.next_tilde_breaking","text":"Returns the next breaking version according to the tilde ( ~ ) strategy. This function simply bumps the minor part of the release if it is present, otherwise the major part is bumped. Example >>> from versions import next_tilde_equal_breaking , parse_version >>> version = parse_version ( \"2.1.0\" ) >>> version < Version ( 2.1.0 ) > >>> next_tilde_breaking ( version ) < Version ( 2.2.0 ) > Parameters: Name Type Description Default version V The version to find the next breaking version of. required Returns: Type Description V The next breaking Version according to the version . Source code in versions/operators.py 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 def next_tilde_breaking ( version : V ) -> V : \"\"\"Returns the next breaking version according to the *tilde* (`~`) strategy. This function simply bumps the minor part of the release if it is present, otherwise the major part is bumped. Example: ```python >>> from versions import next_tilde_equal_breaking, parse_version >>> version = parse_version(\"2.1.0\") >>> version <Version (2.1.0)> >>> next_tilde_breaking(version) <Version (2.2.0)> ``` Arguments: version: The version to find the next breaking version of. Returns: The next breaking [`Version`][versions.version.Version] according to the `version`. \"\"\" if version . has_minor (): return version . next_minor () return version . next_major ()","title":"next_tilde_breaking()"},{"location":"reference/operators/#versions.operators.next_wildcard_breaking","text":"Returns the next breaking version according to the wildcard ( * ) strategy. There are three cases to handle: If the wildcard is used within the pre-release tag of the version, next breaking version has the same release with pre-release tag removed. For example, x.y.z-rc.* is bumped to x.y.z . If the wildcard is used within the post-release tag of the version, next breaking version has the last part of the release bumped. For instance, x.y.z-post.* is bumped to x.y.z' , where z' = z + 1 . Otherwise, the second to last part of the release is bumped. For example, x.y.* is bumped to x.y'.0 , where y' = y + 1 . Note This function returns None if the given version is * . Example >>> from versions import next_wildcard_breaking , parse_version >>> version = parse_version ( \"4.2.0\" ) >>> version < Version ( 4.2.0 ) > >>> next_wildcard_breaking ( version ) < Version ( 4.3.0 ) > >>> other = parse_version ( \"1.2.3-rc.0\" ) >>> other < Version ( 1.2.3 - rc .0 ) > >>> next_wildcard_breaking ( other ) < Version ( 1.2.3 ) > >>> another = parse_version ( \"0.6.8-post.0\" ) >>> another < Version ( 0.6.8 - post .0 ) > >>> next_wildcard_breaking ( another ) < Version ( 0.6.9 ) > # nice Parameters: Name Type Description Default version V The version to find the next breaking version of. required Returns: Type Description Optional [ V ] The next breaking Version according to the version , or None . Source code in versions/operators.py 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 def next_wildcard_breaking ( version : V ) -> Optional [ V ]: \"\"\"Returns the next breaking version according to the *wildcard* (`*`) strategy. There are three cases to handle: - If the wildcard is used within the *pre-release* tag of the version, next breaking version has the same release with *pre-release* tag removed. For example, `x.y.z-rc.*` is bumped to `x.y.z`. - If the wildcard is used within the *post-release* tag of the version, next breaking version has the last part of the release bumped. For instance, `x.y.z-post.*` is bumped to `x.y.z'`, where `z' = z + 1`. - Otherwise, the second to last part of the release is bumped. For example, `x.y.*` is bumped to `x.y'.0`, where `y' = y + 1`. Note: This function returns [`None`][None] if the given version is `*`. Example: ```python >>> from versions import next_wildcard_breaking, parse_version >>> version = parse_version(\"4.2.0\") >>> version <Version (4.2.0)> >>> next_wildcard_breaking(version) <Version (4.3.0)> >>> other = parse_version(\"1.2.3-rc.0\") >>> other <Version (1.2.3-rc.0)> >>> next_wildcard_breaking(other) <Version (1.2.3)> >>> another = parse_version(\"0.6.8-post.0\") >>> another <Version (0.6.8-post.0)> >>> next_wildcard_breaking(another) <Version (0.6.9)> # nice ``` Arguments: version: The version to find the next breaking version of. Returns: The next breaking [`Version`][versions.version.Version] according to the `version`, or [`None`][None]. \"\"\" index = version . last_index if version . is_stable () and not version . is_post_release (): # the wildcard was used within the release segment if not index : return None index -= 1 return version . next_at ( index ) # this will take care of unstable releases","title":"next_wildcard_breaking()"},{"location":"reference/operators/#versions.operators.matches_caret","text":"Checks if the version matches the caret ( ^ ) specification. This is equivalent to: against <= version < next_caret_breaking ( against ) Parameters: Name Type Description Default version Version The version to check. required against Version The version to check the version against. required Returns: Type Description bool Whether the version matches against . Source code in versions/operators.py 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 def matches_caret ( version : Version , against : Version ) -> bool : \"\"\"Checks if the `version` matches the *caret* (`^`) specification. This is equivalent to: ```python against <= version < next_caret_breaking(against) ``` Arguments: version: The version to check. against: The version to check the `version` against. Returns: Whether the `version` matches `against`. \"\"\" return against <= version < next_caret_breaking ( against )","title":"matches_caret()"},{"location":"reference/operators/#versions.operators.matches_tilde_equal","text":"Checks if the version matches the tilde-equal ( ~= ) specification. This is equivalent to: against <= version < next_tilde_equal_breaking ( against ) Parameters: Name Type Description Default version Version The version to check. required against Version The version to check the version against. required Returns: Type Description bool Whether the version matches against . Source code in versions/operators.py 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 def matches_tilde_equal ( version : Version , against : Version ) -> bool : \"\"\"Checks if the `version` matches the *tilde-equal* (`~=`) specification. This is equivalent to: ```python against <= version < next_tilde_equal_breaking(against) ``` Arguments: version: The version to check. against: The version to check the `version` against. Returns: Whether the `version` matches `against`. \"\"\" return against <= version < next_tilde_equal_breaking ( against )","title":"matches_tilde_equal()"},{"location":"reference/operators/#versions.operators.matches_tilde","text":"Checks if the version matches the tilde ( ~ ) specification. This is equivalent to: against <= version < next_tilde_breaking ( against ) Parameters: Name Type Description Default version Version The version to check. required against Version The version to check the version against. required Returns: Type Description bool Whether the version matches against . Source code in versions/operators.py 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 def matches_tilde ( version : Version , against : Version ) -> bool : \"\"\"Checks if the `version` matches the *tilde* (`~`) specification. This is equivalent to: ```python against <= version < next_tilde_breaking(against) ``` Arguments: version: The version to check. against: The version to check the `version` against. Returns: Whether the `version` matches `against`. \"\"\" return against <= version < next_tilde_breaking ( against )","title":"matches_tilde()"},{"location":"reference/operators/#versions.operators.matches_equal","text":"Checks if the version matches the equal ( == ) specification. This is equivalent to: version == against Parameters: Name Type Description Default version Version The version to check. required against Version The version to check the version against. required Returns: Type Description bool Whether the version matches against . Source code in versions/operators.py 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 def matches_equal ( version : Version , against : Version ) -> bool : \"\"\"Checks if the `version` matches the *equal* (`==`) specification. This is equivalent to: ```python version == against ``` Arguments: version: The version to check. against: The version to check the `version` against. Returns: Whether the `version` matches `against`. \"\"\" return version == against","title":"matches_equal()"},{"location":"reference/operators/#versions.operators.matches_not_equal","text":"Checks if the version matches the not-equal ( != ) specification. This is equivalent to: version != against Parameters: Name Type Description Default version Version The version to check. required against Version The version to check the version against. required Returns: Type Description bool Whether the version matches against . Source code in versions/operators.py 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 def matches_not_equal ( version : Version , against : Version ) -> bool : \"\"\"Checks if the `version` matches the *not-equal* (`!=`) specification. This is equivalent to: ```python version != against ``` Arguments: version: The version to check. against: The version to check the `version` against. Returns: Whether the `version` matches `against`. \"\"\" return version != against","title":"matches_not_equal()"},{"location":"reference/operators/#versions.operators.matches_less","text":"Checks if the version matches the less ( < ) specification. This is equivalent to: version < against Parameters: Name Type Description Default version Version The version to check. required against Version The version to check the version against. required Returns: Type Description bool Whether the version matches against . Source code in versions/operators.py 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 def matches_less ( version : Version , against : Version ) -> bool : \"\"\"Checks if the `version` matches the *less* (`<`) specification. This is equivalent to: ```python version < against ``` Arguments: version: The version to check. against: The version to check the `version` against. Returns: Whether the `version` matches `against`. \"\"\" return version < against","title":"matches_less()"},{"location":"reference/operators/#versions.operators.matches_less_or_equal","text":"Checks if the version matches the less-or-equal ( <= ) specification. This is equivalent to: version <= against Parameters: Name Type Description Default version Version The version to check. required against Version The version to check the version against. required Returns: Type Description bool Whether the version matches against . Source code in versions/operators.py 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 def matches_less_or_equal ( version : Version , against : Version ) -> bool : \"\"\"Checks if the `version` matches the *less-or-equal* (`<=`) specification. This is equivalent to: ```python version <= against ``` Arguments: version: The version to check. against: The version to check the `version` against. Returns: Whether the `version` matches `against`. \"\"\" return version <= against","title":"matches_less_or_equal()"},{"location":"reference/operators/#versions.operators.matches_greater","text":"Checks if the version matches the greater ( > ) specification. This is equivalent to: version > against Parameters: Name Type Description Default version Version The version to check. required against Version The version to check the version against. required Returns: Type Description bool Whether the version matches against . Source code in versions/operators.py 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 def matches_greater ( version : Version , against : Version ) -> bool : \"\"\"Checks if the `version` matches the *greater* (`>`) specification. This is equivalent to: ```python version > against ``` Arguments: version: The version to check. against: The version to check the `version` against. Returns: Whether the `version` matches `against`. \"\"\" return version > against","title":"matches_greater()"},{"location":"reference/operators/#versions.operators.matches_greater_or_equal","text":"Checks if the version matches the greater-or-equal ( >= ) specification. This is equivalent to: version >= against Parameters: Name Type Description Default version Version The version to check. required against Version The version to check the version against. required Returns: Type Description bool Whether the version matches against . Source code in versions/operators.py 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 def matches_greater_or_equal ( version : Version , against : Version ) -> bool : \"\"\"Checks if the `version` matches the *greater-or-equal* (`>=`) specification. This is equivalent to: ```python version >= against ``` Arguments: version: The version to check. against: The version to check the `version` against. Returns: Whether the `version` matches `against`. \"\"\" return version >= against","title":"matches_greater_or_equal()"},{"location":"reference/operators/#versions.operators.matches_wildcard_equal","text":"Checks if the version matches the wildcard-equal ( == * ) specification. This is equivalent to: wildcard = next_wildcard_breaking ( against ) wildcard is None or against <= version < wildcard Parameters: Name Type Description Default version Version The version to check. required against Version The version to check the version against. required Returns: Type Description bool Whether the version matches against . Source code in versions/operators.py 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 def matches_wildcard_equal ( version : Version , against : Version ) -> bool : \"\"\"Checks if the `version` matches the *wildcard-equal* (`== *`) specification. This is equivalent to: ```python wildcard = next_wildcard_breaking(against) wildcard is None or against <= version < wildcard ``` Arguments: version: The version to check. against: The version to check the `version` against. Returns: Whether the `version` matches `against`. \"\"\" wildcard = next_wildcard_breaking ( against ) if wildcard is None : return True return against <= version < wildcard","title":"matches_wildcard_equal()"},{"location":"reference/operators/#versions.operators.matches_wildcard_not_equal","text":"Checks if the version matches the wildcard-not-equal ( != * ) specification. This is equivalent to: wildcard = next_wildcard_breaking ( against ) wildcard is not None and ( version < against or version >= wildcard ) Parameters: Name Type Description Default version Version The version to check. required against Version The version to check the version against. required Returns: Type Description bool Whether the version matches against . Source code in versions/operators.py 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 def matches_wildcard_not_equal ( version : Version , against : Version ) -> bool : \"\"\"Checks if the `version` matches the *wildcard-not-equal* (`!= *`) specification. This is equivalent to: ```python wildcard = next_wildcard_breaking(against) wildcard is not None and (version < against or version >= wildcard) ``` Arguments: version: The version to check. against: The version to check the `version` against. Returns: Whether the `version` matches `against`. \"\"\" return not matches_wildcard_equal ( version , against )","title":"matches_wildcard_not_equal()"},{"location":"reference/operators/#versions.operators.translate_caret","text":"Translates the version into a version set according to the caret ( ^ ) strategy. This function returns the [version, next_caret_breaking(version)) range. Parameters: Name Type Description Default version Version The version to translate. required Returns: Type Description VersionRange The version set representing the caret specification. Source code in versions/operators.py 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 def translate_caret ( version : Version ) -> VersionRange : \"\"\"Translates the `version` into a version set according to the *caret* (`^`) strategy. This function returns the `[version, next_caret_breaking(version))` range. Arguments: version: The version to translate. Returns: The version set representing the *caret* specification. \"\"\" return VersionRange ( min = version , max = next_caret_breaking ( version ), include_min = True , include_max = False , )","title":"translate_caret()"},{"location":"reference/operators/#versions.operators.translate_tilde_equal","text":"Translates the version into a version set according to the tilde-equal ( ~= ) strategy. This function returns the [version, next_tilde_equal_breaking(version)) range. Parameters: Name Type Description Default version Version The version to translate. required Returns: Type Description VersionRange The version set representing the tilde-equal specification. Source code in versions/operators.py 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 def translate_tilde_equal ( version : Version ) -> VersionRange : \"\"\"Translates the `version` into a version set according to the *tilde-equal* (`~=`) strategy. This function returns the `[version, next_tilde_equal_breaking(version))` range. Arguments: version: The version to translate. Returns: The version set representing the *tilde-equal* specification. \"\"\" return VersionRange ( min = version , max = next_tilde_equal_breaking ( version ), include_min = True , include_max = False , )","title":"translate_tilde_equal()"},{"location":"reference/operators/#versions.operators.translate_tilde","text":"Translates the version into a version set according to the tilde ( ~ ) strategy. This function returns the [version, next_tilde_breaking(version)) range. Parameters: Name Type Description Default version Version The version to translate. required Returns: Type Description VersionRange The version set representing the tilde-equal specification. Source code in versions/operators.py 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 def translate_tilde ( version : Version ) -> VersionRange : \"\"\"Translates the `version` into a version set according to the *tilde* (`~`) strategy. This function returns the `[version, next_tilde_breaking(version))` range. Arguments: version: The version to translate. Returns: The version set representing the *tilde-equal* specification. \"\"\" return VersionRange ( min = version , max = next_tilde_breaking ( version ), include_min = True , include_max = False , )","title":"translate_tilde()"},{"location":"reference/operators/#versions.operators.translate_equal","text":"Translates the version into a version set according to the equal ( == ) strategy. This function returns the [version, version] range (aka version point). Parameters: Name Type Description Default version Version The version to translate. required Returns: Type Description VersionPoint The version set representing the equal specification. Source code in versions/operators.py 529 530 531 532 533 534 535 536 537 538 539 540 def translate_equal ( version : Version ) -> VersionPoint : \"\"\"Translates the `version` into a version set according to the *equal* (`==`) strategy. This function returns the `[version, version]` range (aka `version` point). Arguments: version: The version to translate. Returns: The version set representing the *equal* specification. \"\"\" return VersionPoint ( version )","title":"translate_equal()"},{"location":"reference/operators/#versions.operators.translate_not_equal","text":"Translates the version into a version set according to the not-equal ( != ) strategy. This function returns the (\u03b5, version) | (version, \u03c9) union. Parameters: Name Type Description Default version Version The version to translate. required Returns: Type Description VersionUnion The version set representing the not-equal specification. Source code in versions/operators.py 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 def translate_not_equal ( version : Version ) -> VersionUnion : \"\"\"Translates the `version` into a version set according to the *not-equal* (`!=`) strategy. This function returns the `(\u03b5, version) | (version, \u03c9)` union. Arguments: version: The version to translate. Returns: The version set representing the *not-equal* specification. \"\"\" result = translate_equal ( version ) . complement () if is_version_union ( result ): return result raise InternalError ( UNEXPECTED_EQUAL_COMPLEMENT )","title":"translate_not_equal()"},{"location":"reference/operators/#versions.operators.translate_less","text":"Translates the version into a version set according to the less ( < ) strategy. This function returns the (\u03b5, version) range. Parameters: Name Type Description Default version Version The version to translate. required Returns: Type Description VersionRange The version set representing the less specification. Source code in versions/operators.py 565 566 567 568 569 570 571 572 573 574 575 576 def translate_less ( version : Version ) -> VersionRange : \"\"\"Translates the `version` into a version set according to the *less* (`<`) strategy. This function returns the `(\u03b5, version)` range. Arguments: version: The version to translate. Returns: The version set representing the *less* specification. \"\"\" return VersionRange ( max = version , include_max = False )","title":"translate_less()"},{"location":"reference/operators/#versions.operators.translate_less_or_equal","text":"Translates the version into a version set according to the less-or-equal ( <= ) strategy. This function returns the (\u03b5, version] range. Parameters: Name Type Description Default version Version The version to translate. required Returns: Type Description VersionRange The version set representing the less-or-equal specification. Source code in versions/operators.py 579 580 581 582 583 584 585 586 587 588 589 590 def translate_less_or_equal ( version : Version ) -> VersionRange : \"\"\"Translates the `version` into a version set according to the *less-or-equal* (`<=`) strategy. This function returns the `(\u03b5, version]` range. Arguments: version: The version to translate. Returns: The version set representing the *less-or-equal* specification. \"\"\" return VersionRange ( max = version , include_max = True )","title":"translate_less_or_equal()"},{"location":"reference/operators/#versions.operators.translate_greater","text":"Translates the version into a version set according to the greater ( > ) strategy. This function returns the (version, \u03c9) range. Parameters: Name Type Description Default version Version The version to translate. required Returns: Type Description VersionRange The version set representing the greater specification. Source code in versions/operators.py 593 594 595 596 597 598 599 600 601 602 603 604 def translate_greater ( version : Version ) -> VersionRange : \"\"\"Translates the `version` into a version set according to the *greater* (`>`) strategy. This function returns the `(version, \u03c9)` range. Arguments: version: The version to translate. Returns: The version set representing the *greater* specification. \"\"\" return VersionRange ( min = version , include_min = False )","title":"translate_greater()"},{"location":"reference/operators/#versions.operators.translate_greater_or_equal","text":"Translates the version into a version set according to the greater-or-equal ( >= ) strategy. This function returns the [version, \u03c9) range. Parameters: Name Type Description Default version Version The version to translate. required Returns: Type Description VersionRange The version set representing the greater-or-equal specification. Source code in versions/operators.py 607 608 609 610 611 612 613 614 615 616 617 618 619 def translate_greater_or_equal ( version : Version ) -> VersionRange : \"\"\"Translates the `version` into a version set according to the *greater-or-equal* (`>=`) strategy. This function returns the `[version, \u03c9)` range. Arguments: version: The version to translate. Returns: The version set representing the *greater-or-equal* specification. \"\"\" return VersionRange ( min = version , include_min = True )","title":"translate_greater_or_equal()"},{"location":"reference/operators/#versions.operators.translate_wildcard_equal","text":"Translates the version into a version set according to the wildcard-equal ( == * ) strategy. This function returns the [version, next_wildcard_version(version)) range in most cases, except for when the version is * ; then the (\u03b5, \u03c9) range is returned. Parameters: Name Type Description Default version Version The version to translate. required Returns: Type Description VersionRange The version set representing the wildcard-equal specification. Source code in versions/operators.py 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 def translate_wildcard_equal ( version : Version ) -> VersionRange : \"\"\"Translates the `version` into a version set according to the *wildcard-equal* (`== *`) strategy. This function returns the `[version, next_wildcard_version(version))` range in most cases, except for when the version is `*`; then the `(\u03b5, \u03c9)` range is returned. Arguments: version: The version to translate. Returns: The version set representing the *wildcard-equal* specification. \"\"\" wildcard = next_wildcard_breaking ( version ) if wildcard is None : return VersionRange () return VersionRange ( min = version , max = wildcard , include_min = True , include_max = False )","title":"translate_wildcard_equal()"},{"location":"reference/operators/#versions.operators.translate_wildcard_not_equal","text":"Translates the version into a version set according to the wildcard-not-equal ( != * ) strategy. This function returns the (\u03b5, version) | (next_wildcard_breaking(version), \u03c9) union in most cases, except for when the version is * ; then the {} empty set is returned. Parameters: Name Type Description Default version Version The version to translate. required Returns: Type Description Union [ VersionEmpty , VersionUnion ] The version set representing the wildcard-not-equal specification. Source code in versions/operators.py 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 def translate_wildcard_not_equal ( version : Version ) -> Union [ VersionEmpty , VersionUnion ]: \"\"\"Translates the `version` into a version set according to the *wildcard-not-equal* (`!= *`) strategy. This function returns the `(\u03b5, version) | (next_wildcard_breaking(version), \u03c9)` union in most cases, except for when the version is `*`; then the `{}` empty set is returned. Arguments: version: The version to translate. Returns: The version set representing the *wildcard-not-equal* specification. \"\"\" result = translate_wildcard_equal ( version ) . complement () if is_version_empty ( result ) or is_version_union ( result ): return result raise InternalError ( UNEXPECTED_WILDCARD_EQUAL_COMPLEMENT )","title":"translate_wildcard_not_equal()"},{"location":"reference/segments/","text":"DEFAULT_PARTS = ( 0 , 0 , 0 ) module-attribute The default parts of the Release . DEFAULT_VALUE = 0 module-attribute The default value to use. DEFAULT_PADDING = 0 module-attribute The default padding to use. Epoch Bases: Representation , FromString , ToString Represents the epoch segment of the version ( e! ). Source code in versions/segments.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 @frozen ( repr = False , eq = True , order = True ) class Epoch ( Representation , FromString , ToString ): \"\"\"Represents the *epoch* segment of the version (`e!`).\"\"\" value : int = field ( default = DEFAULT_VALUE ) \"\"\"The value of the epoch.\"\"\" def __bool__ ( self ) -> bool : return bool ( self . value ) @classmethod def create ( cls : Type [ E ], value : int = DEFAULT_VALUE ) -> E : \"\"\"Creates an [`Epoch`][versions.segments.Epoch] from `value`. Arguments: value: The value of the epoch. Returns: The newly created [`Epoch`][versions.segments.Epoch]. \"\"\" return cls ( value ) @classmethod def from_string ( cls : Type [ E ], string : str ) -> E : \"\"\"Parses an [`Epoch`][versions.segments.Epoch] from `string`. Arguments: string: The string to parse. Returns: The parsed epoch. \"\"\" return cls ( int ( string )) def to_string ( self ) -> str : \"\"\"Converts an [`Epoch`][versions.segments.Epoch] to its string representation. Returns: The epoch string. \"\"\" return str ( self . value ) value : int = field ( default = DEFAULT_VALUE ) class-attribute The value of the epoch. create ( value : int = DEFAULT_VALUE ) -> E classmethod Creates an Epoch from value . Parameters: Name Type Description Default value int The value of the epoch. DEFAULT_VALUE Returns: Type Description E The newly created Epoch . Source code in versions/segments.py 98 99 100 101 102 103 104 105 106 107 108 @classmethod def create ( cls : Type [ E ], value : int = DEFAULT_VALUE ) -> E : \"\"\"Creates an [`Epoch`][versions.segments.Epoch] from `value`. Arguments: value: The value of the epoch. Returns: The newly created [`Epoch`][versions.segments.Epoch]. \"\"\" return cls ( value ) from_string ( string : str ) -> E classmethod Parses an Epoch from string . Parameters: Name Type Description Default string str The string to parse. required Returns: Type Description E The parsed epoch. Source code in versions/segments.py 110 111 112 113 114 115 116 117 118 119 120 @classmethod def from_string ( cls : Type [ E ], string : str ) -> E : \"\"\"Parses an [`Epoch`][versions.segments.Epoch] from `string`. Arguments: string: The string to parse. Returns: The parsed epoch. \"\"\" return cls ( int ( string )) to_string () -> str Converts an Epoch to its string representation. Returns: Type Description str The epoch string. Source code in versions/segments.py 122 123 124 125 126 127 128 def to_string ( self ) -> str : \"\"\"Converts an [`Epoch`][versions.segments.Epoch] to its string representation. Returns: The epoch string. \"\"\" return str ( self . value ) Release Bases: Representation , FromString , ToString Represents the release segment of the version ( x.y.z ). Source code in versions/segments.py 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 @frozen ( repr = False , eq = True , order = True ) class Release ( Representation , FromString , ToString ): \"\"\"Represents the *release* segment of the version (`x.y.z`).\"\"\" parts : Parts = field ( default = DEFAULT_PARTS , eq = False , order = False ) \"\"\"The parts of the release.\"\"\" compare_parts : Parts = field ( repr = False , init = False , eq = True , order = True ) @parts . validator def check_parts ( self , attribute : Attribute [ Parts ], value : Parts ) -> None : if not value : raise ValueError ( EMPTY_RELEASE ) def __attrs_post_init__ ( self ) -> None : evolve_in_place ( self , compare_parts = self . compute_compare_parts ()) def compute_compare_parts ( self ) -> Parts : parts = self . parts index = count_leading_zeros ( reversed ( parts )) if index == self . precision : index -= 1 return self . slice_parts ( - index ) if index else parts @classmethod def create ( cls : Type [ R ], parts : Parts = DEFAULT_PARTS ) -> R : \"\"\"Creates a [`Release`][versions.segments.Release] from `parts`. Arguments: parts: The parts of the release. Returns: The newly created [`Release`][versions.segments.Release]. \"\"\" return cls ( parts ) @classmethod def from_iterable ( cls : Type [ R ], iterable : Iterable [ int ]) -> R : \"\"\"Creates a [`Release`][versions.segments.Release] from `iterable`. Arguments: iterable: The parts of the release in an iterable. Returns: The newly created [`Release`][versions.segments.Release]. \"\"\" return cls ( tuple ( iterable )) @classmethod def from_parts ( cls : Type [ R ], * parts : int ) -> R : \"\"\"Creates a [`Release`][versions.segments.Release] from `parts`. Arguments: *parts: The parts of the release. Returns: The newly created [`Release`][versions.segments.Release]. \"\"\" return cls ( parts ) def into_parts ( self ) -> Parts : \"\"\"Converts a [`Release`][versions.segments.Release] to its parts. Returns: The parts of the release. \"\"\" return self . parts @property def precision ( self ) -> int : \"\"\"The count of the release parts.\"\"\" return len ( self . parts ) @property def last_index ( self ) -> int : \"\"\"The index of the last release part.\"\"\" return self . precision - 1 @property def major ( self ) -> int : \"\"\"The *major* part of the release.\"\"\" return self . get_at ( MAJOR ) @property def minor ( self ) -> int : \"\"\"The *minor* part of the release.\"\"\" return self . get_at ( MINOR ) @property def micro ( self ) -> int : \"\"\"The *micro* part of the release.\"\"\" return self . get_at ( MICRO ) @property def patch ( self ) -> int : \"\"\"The *patch* part of the release. This is equivalent to [`micro`][versions.segments.Release.micro]. \"\"\" return self . get_at ( PATCH ) @property def extra ( self ) -> Extra : \"\"\"The *extra* parts of the release.\"\"\" return self . parts [ TOTAL :] def get_at ( self , index : int , default : int = DEFAULT_VALUE ) -> int : \"\"\"Gets the release part at the `index`, defaulting to `default`. Arguments: index: The index of the part to get. default: The default value to use. Returns: The release part at `index` or the `default` value. \"\"\" return self . get_at_unchecked ( index ) if self . has_at ( index ) else default def get_at_unchecked ( self , index : int ) -> int : \"\"\"Gets the release part at the `index`. Arguments: index: The index of the part to get. Raises: IndexError: The index is *out-of-bounds*. Returns: The release part at `index`. \"\"\" return self . parts [ index ] def is_semantic ( self ) -> bool : \"\"\"Checks if the release matches the *semantic versioning* schema. Returns: Whether the release matches the [`semver`](https://semver.org/) schema. \"\"\" return self . precision == TOTAL def to_semantic ( self : R ) -> R : \"\"\"Converts the release to match the [`semver`](https://semver.org/) schema. Returns: The converted release. \"\"\" if self . has_extra (): return self . next_patch () . slice ( TOTAL ) return self if self . is_semantic () else self . pad_to ( TOTAL ) def set_major ( self : R , value : int ) -> R : \"\"\"Sets the *major* part of the release to the `value`. Arguments: value: The value to set the *major* part to. Returns: The updated release. \"\"\" return self . set_at ( MAJOR , value ) def set_minor ( self : R , value : int ) -> R : \"\"\"Sets the *minor* part of the release to the `value`. Arguments: value: The value to set the *minor* part to. Returns: The updated release. \"\"\" return self . set_at ( MINOR , value ) def set_micro ( self : R , value : int ) -> R : \"\"\"Sets the *micro* part of the release to the `value`. Arguments: value: The value to set the *micro* part to. Returns: The updated release. \"\"\" return self . set_at ( MICRO , value ) def set_patch ( self : R , value : int ) -> R : \"\"\"Sets the *patch* part of the release to the `value`. This is equivalent to [`set_micro`][versions.segments.Release.set_micro]. Arguments: value: The value to set the *patch* part to. Returns: The updated release. \"\"\" return self . set_at ( PATCH , value ) def set_at ( self : R , index : int , value : int ) -> R : \"\"\"Sets the release part at the `index` to the `value`. Arguments: index: The index to set the `value` at. value: The value to set the part to. Returns: The updated release. \"\"\" return self . pad_to_index ( index ) . set_at_unchecked ( index , value ) def set_at_unchecked ( self : R , index : int , value : int ) -> R : \"\"\"Sets the release part at the `index` to the `value`. Arguments: index: The index to set the `value` at. value: The value to set the part to. Raises: IndexError: The index is *out-of-bounds*. Returns: The updated release. \"\"\" mutable = list ( self . parts ) mutable [ index ] = value return self . from_iterable ( mutable ) def next_major ( self : R ) -> R : \"\"\"Bumps the *major* part of the release. Returns: The bumped release. \"\"\" return self . next_at ( MAJOR ) def next_minor ( self : R ) -> R : \"\"\"Bumps the *minor* part of the release. Returns: The bumped release. \"\"\" return self . next_at ( MINOR ) def next_micro ( self : R ) -> R : \"\"\"Bumps the *micro* part of the release. Returns: The bumped release. \"\"\" return self . next_at ( MICRO ) def next_patch ( self : R ) -> R : \"\"\"Bumps the *patch* part of the release. This is equivalent to [`next_micro`][versions.segments.Release.next_micro]. Returns: The bumped release. \"\"\" return self . next_at ( PATCH ) def next_at ( self : R , index : int ) -> R : \"\"\"Bumps the part of the release at the `index`. Arguments: index: The index to bump the part at. Returns: The bumped release. \"\"\" updated = self . set_at ( index , self . get_at ( index ) + 1 ) return updated . slice ( index + 1 ) . pad_to ( updated . precision ) def has_major ( self ) -> bool : \"\"\"Checks if the release has the *major* part. Returns: Whether the *major* part is present. \"\"\" return self . has_at ( MAJOR ) def has_minor ( self ) -> bool : \"\"\"Checks if the release has the *minor* part. Returns: Whether the *minor* part is present. \"\"\" return self . has_at ( MINOR ) def has_micro ( self ) -> bool : \"\"\"Checks if the release has the *micro* part. Returns: Whether the *micro* part is present. \"\"\" return self . has_at ( MICRO ) def has_patch ( self ) -> bool : \"\"\"Checks if the release has the *patch* part. This is equivalent to [`has_micro`][versions.segments.Release.has_micro]. Returns: Whether the *patch* part is present. \"\"\" return self . has_at ( PATCH ) def has_extra ( self ) -> bool : \"\"\"Checks if the release has any *extra* parts. Returns: Whether the *extra* parts are present. \"\"\" return self . has_at ( TOTAL ) def has_at ( self , index : int ) -> bool : \"\"\"Checks if the release has a part at the `index`. Returns: Whether the part at the `index` is present. \"\"\" return self . precision > index def pad_to ( self : R , length : int , padding : int = DEFAULT_PADDING ) -> R : \"\"\"Pads a [`Release`][versions.segments.Release] to the `length` with `padding`. Arguments: length: The length to pad the release to. padding: The padding to use. Returns: The padded release. \"\"\" if self . precision < length : return self . from_iterable ( fix_to_length ( length , padding , self . parts )) return self def pad_to_index ( self : R , index : int , padding : int = DEFAULT_PADDING ) -> R : \"\"\"Pads a [`Release`][versions.segments.Release] to the `index` with `padding`. Arguments: index: The index to pad the release to. padding: The padding to use. Returns: The padded release. \"\"\" return self . pad_to ( index + 1 , padding ) def pad_to_next ( self : R , padding : int = DEFAULT_PADDING ) -> R : \"\"\"Pads a [`Release`][versions.segments.Release] to the next index. Arguments: padding: The padding to use. Returns: The padded release. \"\"\" return self . pad_to ( self . precision + 1 , padding ) def slice ( self : R , stop : int ) -> R : return self . create ( self . slice_parts ( stop )) def slice_parts ( self , stop : int ) -> Parts : return self . parts [: stop ] @classmethod def from_string ( cls : Type [ R ], string : str ) -> R : \"\"\"Parses a [`Release`][versions.segments.Release] from `string`. Arguments: string: The string to parse. Returns: The parsed release. \"\"\" return cls . from_iterable ( map ( int , split_dot ( string ))) def to_string ( self ) -> str : \"\"\"Converts a [`Release`][versions.segments.Release] to its string representation. Returns: The release string. \"\"\" return concat_dot ( map ( str , self . parts )) parts : Parts = field ( default = DEFAULT_PARTS , eq = False , order = False ) class-attribute The parts of the release. create ( parts : Parts = DEFAULT_PARTS ) -> R classmethod Creates a Release from parts . Parameters: Name Type Description Default parts Parts The parts of the release. DEFAULT_PARTS Returns: Type Description R The newly created Release . Source code in versions/segments.py 163 164 165 166 167 168 169 170 171 172 173 @classmethod def create ( cls : Type [ R ], parts : Parts = DEFAULT_PARTS ) -> R : \"\"\"Creates a [`Release`][versions.segments.Release] from `parts`. Arguments: parts: The parts of the release. Returns: The newly created [`Release`][versions.segments.Release]. \"\"\" return cls ( parts ) from_iterable ( iterable : Iterable [ int ]) -> R classmethod Creates a Release from iterable . Parameters: Name Type Description Default iterable Iterable [ int ] The parts of the release in an iterable. required Returns: Type Description R The newly created Release . Source code in versions/segments.py 175 176 177 178 179 180 181 182 183 184 185 @classmethod def from_iterable ( cls : Type [ R ], iterable : Iterable [ int ]) -> R : \"\"\"Creates a [`Release`][versions.segments.Release] from `iterable`. Arguments: iterable: The parts of the release in an iterable. Returns: The newly created [`Release`][versions.segments.Release]. \"\"\" return cls ( tuple ( iterable )) from_parts ( * parts : int ) -> R classmethod Creates a Release from parts . Parameters: Name Type Description Default *parts int The parts of the release. () Returns: Type Description R The newly created Release . Source code in versions/segments.py 187 188 189 190 191 192 193 194 195 196 197 @classmethod def from_parts ( cls : Type [ R ], * parts : int ) -> R : \"\"\"Creates a [`Release`][versions.segments.Release] from `parts`. Arguments: *parts: The parts of the release. Returns: The newly created [`Release`][versions.segments.Release]. \"\"\" return cls ( parts ) into_parts () -> Parts Converts a Release to its parts. Returns: Type Description Parts The parts of the release. Source code in versions/segments.py 199 200 201 202 203 204 205 def into_parts ( self ) -> Parts : \"\"\"Converts a [`Release`][versions.segments.Release] to its parts. Returns: The parts of the release. \"\"\" return self . parts precision () -> int property The count of the release parts. Source code in versions/segments.py 207 208 209 210 @property def precision ( self ) -> int : \"\"\"The count of the release parts.\"\"\" return len ( self . parts ) last_index () -> int property The index of the last release part. Source code in versions/segments.py 212 213 214 215 @property def last_index ( self ) -> int : \"\"\"The index of the last release part.\"\"\" return self . precision - 1 major () -> int property The major part of the release. Source code in versions/segments.py 217 218 219 220 @property def major ( self ) -> int : \"\"\"The *major* part of the release.\"\"\" return self . get_at ( MAJOR ) minor () -> int property The minor part of the release. Source code in versions/segments.py 222 223 224 225 @property def minor ( self ) -> int : \"\"\"The *minor* part of the release.\"\"\" return self . get_at ( MINOR ) micro () -> int property The micro part of the release. Source code in versions/segments.py 227 228 229 230 @property def micro ( self ) -> int : \"\"\"The *micro* part of the release.\"\"\" return self . get_at ( MICRO ) patch () -> int property The patch part of the release. This is equivalent to micro . Source code in versions/segments.py 232 233 234 235 236 237 238 @property def patch ( self ) -> int : \"\"\"The *patch* part of the release. This is equivalent to [`micro`][versions.segments.Release.micro]. \"\"\" return self . get_at ( PATCH ) extra () -> Extra property The extra parts of the release. Source code in versions/segments.py 240 241 242 243 @property def extra ( self ) -> Extra : \"\"\"The *extra* parts of the release.\"\"\" return self . parts [ TOTAL :] get_at ( index : int , default : int = DEFAULT_VALUE ) -> int Gets the release part at the index , defaulting to default . Parameters: Name Type Description Default index int The index of the part to get. required default int The default value to use. DEFAULT_VALUE Returns: Type Description int The release part at index or the default value. Source code in versions/segments.py 245 246 247 248 249 250 251 252 253 254 255 def get_at ( self , index : int , default : int = DEFAULT_VALUE ) -> int : \"\"\"Gets the release part at the `index`, defaulting to `default`. Arguments: index: The index of the part to get. default: The default value to use. Returns: The release part at `index` or the `default` value. \"\"\" return self . get_at_unchecked ( index ) if self . has_at ( index ) else default get_at_unchecked ( index : int ) -> int Gets the release part at the index . Parameters: Name Type Description Default index int The index of the part to get. required Raises: Type Description IndexError The index is out-of-bounds . Returns: Type Description int The release part at index . Source code in versions/segments.py 257 258 259 260 261 262 263 264 265 266 267 268 269 def get_at_unchecked ( self , index : int ) -> int : \"\"\"Gets the release part at the `index`. Arguments: index: The index of the part to get. Raises: IndexError: The index is *out-of-bounds*. Returns: The release part at `index`. \"\"\" return self . parts [ index ] is_semantic () -> bool Checks if the release matches the semantic versioning schema. Returns: Type Description bool Whether the release matches the semver schema. Source code in versions/segments.py 271 272 273 274 275 276 277 def is_semantic ( self ) -> bool : \"\"\"Checks if the release matches the *semantic versioning* schema. Returns: Whether the release matches the [`semver`](https://semver.org/) schema. \"\"\" return self . precision == TOTAL to_semantic () -> R Converts the release to match the semver schema. Returns: Type Description R The converted release. Source code in versions/segments.py 279 280 281 282 283 284 285 286 287 288 def to_semantic ( self : R ) -> R : \"\"\"Converts the release to match the [`semver`](https://semver.org/) schema. Returns: The converted release. \"\"\" if self . has_extra (): return self . next_patch () . slice ( TOTAL ) return self if self . is_semantic () else self . pad_to ( TOTAL ) set_major ( value : int ) -> R Sets the major part of the release to the value . Parameters: Name Type Description Default value int The value to set the major part to. required Returns: Type Description R The updated release. Source code in versions/segments.py 290 291 292 293 294 295 296 297 298 299 def set_major ( self : R , value : int ) -> R : \"\"\"Sets the *major* part of the release to the `value`. Arguments: value: The value to set the *major* part to. Returns: The updated release. \"\"\" return self . set_at ( MAJOR , value ) set_minor ( value : int ) -> R Sets the minor part of the release to the value . Parameters: Name Type Description Default value int The value to set the minor part to. required Returns: Type Description R The updated release. Source code in versions/segments.py 301 302 303 304 305 306 307 308 309 310 def set_minor ( self : R , value : int ) -> R : \"\"\"Sets the *minor* part of the release to the `value`. Arguments: value: The value to set the *minor* part to. Returns: The updated release. \"\"\" return self . set_at ( MINOR , value ) set_micro ( value : int ) -> R Sets the micro part of the release to the value . Parameters: Name Type Description Default value int The value to set the micro part to. required Returns: Type Description R The updated release. Source code in versions/segments.py 312 313 314 315 316 317 318 319 320 321 def set_micro ( self : R , value : int ) -> R : \"\"\"Sets the *micro* part of the release to the `value`. Arguments: value: The value to set the *micro* part to. Returns: The updated release. \"\"\" return self . set_at ( MICRO , value ) set_patch ( value : int ) -> R Sets the patch part of the release to the value . This is equivalent to set_micro . Parameters: Name Type Description Default value int The value to set the patch part to. required Returns: Type Description R The updated release. Source code in versions/segments.py 323 324 325 326 327 328 329 330 331 332 333 334 def set_patch ( self : R , value : int ) -> R : \"\"\"Sets the *patch* part of the release to the `value`. This is equivalent to [`set_micro`][versions.segments.Release.set_micro]. Arguments: value: The value to set the *patch* part to. Returns: The updated release. \"\"\" return self . set_at ( PATCH , value ) set_at ( index : int , value : int ) -> R Sets the release part at the index to the value . Parameters: Name Type Description Default index int The index to set the value at. required value int The value to set the part to. required Returns: Type Description R The updated release. Source code in versions/segments.py 336 337 338 339 340 341 342 343 344 345 346 def set_at ( self : R , index : int , value : int ) -> R : \"\"\"Sets the release part at the `index` to the `value`. Arguments: index: The index to set the `value` at. value: The value to set the part to. Returns: The updated release. \"\"\" return self . pad_to_index ( index ) . set_at_unchecked ( index , value ) set_at_unchecked ( index : int , value : int ) -> R Sets the release part at the index to the value . Parameters: Name Type Description Default index int The index to set the value at. required value int The value to set the part to. required Raises: Type Description IndexError The index is out-of-bounds . Returns: Type Description R The updated release. Source code in versions/segments.py 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 def set_at_unchecked ( self : R , index : int , value : int ) -> R : \"\"\"Sets the release part at the `index` to the `value`. Arguments: index: The index to set the `value` at. value: The value to set the part to. Raises: IndexError: The index is *out-of-bounds*. Returns: The updated release. \"\"\" mutable = list ( self . parts ) mutable [ index ] = value return self . from_iterable ( mutable ) next_major () -> R Bumps the major part of the release. Returns: Type Description R The bumped release. Source code in versions/segments.py 366 367 368 369 370 371 372 def next_major ( self : R ) -> R : \"\"\"Bumps the *major* part of the release. Returns: The bumped release. \"\"\" return self . next_at ( MAJOR ) next_minor () -> R Bumps the minor part of the release. Returns: Type Description R The bumped release. Source code in versions/segments.py 374 375 376 377 378 379 380 def next_minor ( self : R ) -> R : \"\"\"Bumps the *minor* part of the release. Returns: The bumped release. \"\"\" return self . next_at ( MINOR ) next_micro () -> R Bumps the micro part of the release. Returns: Type Description R The bumped release. Source code in versions/segments.py 382 383 384 385 386 387 388 def next_micro ( self : R ) -> R : \"\"\"Bumps the *micro* part of the release. Returns: The bumped release. \"\"\" return self . next_at ( MICRO ) next_patch () -> R Bumps the patch part of the release. This is equivalent to next_micro . Returns: Type Description R The bumped release. Source code in versions/segments.py 390 391 392 393 394 395 396 397 398 def next_patch ( self : R ) -> R : \"\"\"Bumps the *patch* part of the release. This is equivalent to [`next_micro`][versions.segments.Release.next_micro]. Returns: The bumped release. \"\"\" return self . next_at ( PATCH ) next_at ( index : int ) -> R Bumps the part of the release at the index . Parameters: Name Type Description Default index int The index to bump the part at. required Returns: Type Description R The bumped release. Source code in versions/segments.py 400 401 402 403 404 405 406 407 408 409 410 411 def next_at ( self : R , index : int ) -> R : \"\"\"Bumps the part of the release at the `index`. Arguments: index: The index to bump the part at. Returns: The bumped release. \"\"\" updated = self . set_at ( index , self . get_at ( index ) + 1 ) return updated . slice ( index + 1 ) . pad_to ( updated . precision ) has_major () -> bool Checks if the release has the major part. Returns: Type Description bool Whether the major part is present. Source code in versions/segments.py 413 414 415 416 417 418 419 def has_major ( self ) -> bool : \"\"\"Checks if the release has the *major* part. Returns: Whether the *major* part is present. \"\"\" return self . has_at ( MAJOR ) has_minor () -> bool Checks if the release has the minor part. Returns: Type Description bool Whether the minor part is present. Source code in versions/segments.py 421 422 423 424 425 426 427 def has_minor ( self ) -> bool : \"\"\"Checks if the release has the *minor* part. Returns: Whether the *minor* part is present. \"\"\" return self . has_at ( MINOR ) has_micro () -> bool Checks if the release has the micro part. Returns: Type Description bool Whether the micro part is present. Source code in versions/segments.py 429 430 431 432 433 434 435 def has_micro ( self ) -> bool : \"\"\"Checks if the release has the *micro* part. Returns: Whether the *micro* part is present. \"\"\" return self . has_at ( MICRO ) has_patch () -> bool Checks if the release has the patch part. This is equivalent to has_micro . Returns: Type Description bool Whether the patch part is present. Source code in versions/segments.py 437 438 439 440 441 442 443 444 445 def has_patch ( self ) -> bool : \"\"\"Checks if the release has the *patch* part. This is equivalent to [`has_micro`][versions.segments.Release.has_micro]. Returns: Whether the *patch* part is present. \"\"\" return self . has_at ( PATCH ) has_extra () -> bool Checks if the release has any extra parts. Returns: Type Description bool Whether the extra parts are present. Source code in versions/segments.py 447 448 449 450 451 452 453 def has_extra ( self ) -> bool : \"\"\"Checks if the release has any *extra* parts. Returns: Whether the *extra* parts are present. \"\"\" return self . has_at ( TOTAL ) has_at ( index : int ) -> bool Checks if the release has a part at the index . Returns: Type Description bool Whether the part at the index is present. Source code in versions/segments.py 455 456 457 458 459 460 461 def has_at ( self , index : int ) -> bool : \"\"\"Checks if the release has a part at the `index`. Returns: Whether the part at the `index` is present. \"\"\" return self . precision > index pad_to ( length : int , padding : int = DEFAULT_PADDING ) -> R Pads a Release to the length with padding . Parameters: Name Type Description Default length int The length to pad the release to. required padding int The padding to use. DEFAULT_PADDING Returns: Type Description R The padded release. Source code in versions/segments.py 463 464 465 466 467 468 469 470 471 472 473 474 475 476 def pad_to ( self : R , length : int , padding : int = DEFAULT_PADDING ) -> R : \"\"\"Pads a [`Release`][versions.segments.Release] to the `length` with `padding`. Arguments: length: The length to pad the release to. padding: The padding to use. Returns: The padded release. \"\"\" if self . precision < length : return self . from_iterable ( fix_to_length ( length , padding , self . parts )) return self pad_to_index ( index : int , padding : int = DEFAULT_PADDING ) -> R Pads a Release to the index with padding . Parameters: Name Type Description Default index int The index to pad the release to. required padding int The padding to use. DEFAULT_PADDING Returns: Type Description R The padded release. Source code in versions/segments.py 478 479 480 481 482 483 484 485 486 487 488 def pad_to_index ( self : R , index : int , padding : int = DEFAULT_PADDING ) -> R : \"\"\"Pads a [`Release`][versions.segments.Release] to the `index` with `padding`. Arguments: index: The index to pad the release to. padding: The padding to use. Returns: The padded release. \"\"\" return self . pad_to ( index + 1 , padding ) pad_to_next ( padding : int = DEFAULT_PADDING ) -> R Pads a Release to the next index. Parameters: Name Type Description Default padding int The padding to use. DEFAULT_PADDING Returns: Type Description R The padded release. Source code in versions/segments.py 490 491 492 493 494 495 496 497 498 499 def pad_to_next ( self : R , padding : int = DEFAULT_PADDING ) -> R : \"\"\"Pads a [`Release`][versions.segments.Release] to the next index. Arguments: padding: The padding to use. Returns: The padded release. \"\"\" return self . pad_to ( self . precision + 1 , padding ) from_string ( string : str ) -> R classmethod Parses a Release from string . Parameters: Name Type Description Default string str The string to parse. required Returns: Type Description R The parsed release. Source code in versions/segments.py 507 508 509 510 511 512 513 514 515 516 517 @classmethod def from_string ( cls : Type [ R ], string : str ) -> R : \"\"\"Parses a [`Release`][versions.segments.Release] from `string`. Arguments: string: The string to parse. Returns: The parsed release. \"\"\" return cls . from_iterable ( map ( int , split_dot ( string ))) to_string () -> str Converts a Release to its string representation. Returns: Type Description str The release string. Source code in versions/segments.py 519 520 521 522 523 524 525 def to_string ( self ) -> str : \"\"\"Converts a [`Release`][versions.segments.Release] to its string representation. Returns: The release string. \"\"\" return concat_dot ( map ( str , self . parts )) Tag Bases: Representation , FromString , ToString Represents various version tags ( tag.n ). Source code in versions/segments.py 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 @frozen ( repr = False , eq = True , order = True ) class Tag ( Representation , FromString , ToString ): \"\"\"Represents various version *tags* (`tag.n`).\"\"\" DEFAULT_PHASE : ClassVar [ str ] = PHASE_ALL_DEFAULT PHASE_SET : ClassVar [ Set [ str ]] = PHASE_ALL_SET phase : str = field ( converter = case_fold ) # type: ignore \"\"\"The phase of the release tag.\"\"\" value : int = field ( default = DEFAULT_VALUE ) \"\"\"The value of the release tag.\"\"\" @phase . default def default_phase ( self ) -> str : return self . DEFAULT_PHASE @phase . validator def check_phase ( self , attribute : Attribute [ str ], value : str ) -> None : if value not in self . PHASE_SET : raise ValueError ( PHASE_NOT_ALLOWED . format ( value , get_name ( type ( self )))) def __attrs_post_init__ ( self ) -> None : evolve_in_place ( self , phase = self . expand ( self . phase )) @staticmethod def expand ( phase : str ) -> str : return SHORT_TO_PHASE . get ( phase , phase ) @staticmethod def reduce ( phase : str ) -> str : return PHASE_TO_SHORT . get ( phase , phase ) @staticmethod def normalize_phase ( phase : str ) -> str : return PHASE_TO_NORMAL . get ( phase , phase ) @classmethod def create ( cls : Type [ T ], phase : Optional [ str ] = None , value : int = DEFAULT_VALUE ) -> T : \"\"\"Creates a [`Tag`][versions.segments.Tag] from `phase` and `value`. Arguments: phase: The phase of the tag. value: The value of the tag. Returns: The newly created [`Tag`][versions.segments.Tag]. \"\"\" if phase is None : phase = cls . DEFAULT_PHASE return cls ( phase , value ) @classmethod def default_phase_with_value ( cls : Type [ T ], value : int ) -> T : \"\"\"Creates a [`Tag`][versions.segments.Tag] from `value` with the default phase. Arguments: value: The value of the tag. Returns: The newly created [`Tag`][versions.segments.Tag]. \"\"\" return cls ( cls . DEFAULT_PHASE , value ) @property def short ( self ) -> str : \"\"\"The *short* phase of the release.\"\"\" return self . reduce ( self . phase ) @property def normal ( self ) -> str : \"\"\"The *normalized* phase of the release.\"\"\" return self . normalize_phase ( self . phase ) def normalize ( self : T ) -> T : \"\"\"Normalizes the version tag. Returns: The normalized tag. \"\"\" return evolve ( self , phase = self . normal ) def next ( self : T ) -> T : \"\"\"Bumps the version tag. Returns: The next version tag. \"\"\" return evolve ( self , value = self . value + 1 ) def next_phase ( self : T ) -> Optional [ T ]: \"\"\"Bumps the version tag phase, if possible. Returns: The next version tag, if present. \"\"\" phase = PHASE_TO_NEXT . get ( self . phase ) return None if phase is None else self . create ( phase ) @classmethod def from_string ( cls : Type [ T ], string : str ) -> T : \"\"\"Parses a [`Tag`][versions.segments.Tag] from `string`. Arguments: string: The string to parse. Returns: The parsed tag. \"\"\" return TagParser ( cls ) . parse ( string ) def to_string ( self ) -> str : \"\"\"Converts a [`Tag`][versions.segments.Tag] to its string representation. Returns: The tag string. \"\"\" return concat_dot_args ( self . phase , str ( self . value )) def to_short_string ( self ) -> str : \"\"\"Converts a [`Tag`][versions.segments.Tag] to its *short* string representation. Returns: The *short* tag string. \"\"\" return concat_empty_args ( self . short , str ( self . value )) phase : str = field ( converter = case_fold ) class-attribute The phase of the release tag. value : int = field ( default = DEFAULT_VALUE ) class-attribute The value of the release tag. create ( phase : Optional [ str ] = None , value : int = DEFAULT_VALUE ) -> T classmethod Creates a Tag from phase and value . Parameters: Name Type Description Default phase Optional [ str ] The phase of the tag. None value int The value of the tag. DEFAULT_VALUE Returns: Type Description T The newly created Tag . Source code in versions/segments.py 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 @classmethod def create ( cls : Type [ T ], phase : Optional [ str ] = None , value : int = DEFAULT_VALUE ) -> T : \"\"\"Creates a [`Tag`][versions.segments.Tag] from `phase` and `value`. Arguments: phase: The phase of the tag. value: The value of the tag. Returns: The newly created [`Tag`][versions.segments.Tag]. \"\"\" if phase is None : phase = cls . DEFAULT_PHASE return cls ( phase , value ) default_phase_with_value ( value : int ) -> T classmethod Creates a Tag from value with the default phase. Parameters: Name Type Description Default value int The value of the tag. required Returns: Type Description T The newly created Tag . Source code in versions/segments.py 587 588 589 590 591 592 593 594 595 596 597 @classmethod def default_phase_with_value ( cls : Type [ T ], value : int ) -> T : \"\"\"Creates a [`Tag`][versions.segments.Tag] from `value` with the default phase. Arguments: value: The value of the tag. Returns: The newly created [`Tag`][versions.segments.Tag]. \"\"\" return cls ( cls . DEFAULT_PHASE , value ) short () -> str property The short phase of the release. Source code in versions/segments.py 599 600 601 602 @property def short ( self ) -> str : \"\"\"The *short* phase of the release.\"\"\" return self . reduce ( self . phase ) normal () -> str property The normalized phase of the release. Source code in versions/segments.py 604 605 606 607 @property def normal ( self ) -> str : \"\"\"The *normalized* phase of the release.\"\"\" return self . normalize_phase ( self . phase ) normalize () -> T Normalizes the version tag. Returns: Type Description T The normalized tag. Source code in versions/segments.py 609 610 611 612 613 614 615 def normalize ( self : T ) -> T : \"\"\"Normalizes the version tag. Returns: The normalized tag. \"\"\" return evolve ( self , phase = self . normal ) next () -> T Bumps the version tag. Returns: Type Description T The next version tag. Source code in versions/segments.py 617 618 619 620 621 622 623 def next ( self : T ) -> T : \"\"\"Bumps the version tag. Returns: The next version tag. \"\"\" return evolve ( self , value = self . value + 1 ) next_phase () -> Optional [ T ] Bumps the version tag phase, if possible. Returns: Type Description Optional [ T ] The next version tag, if present. Source code in versions/segments.py 625 626 627 628 629 630 631 632 633 def next_phase ( self : T ) -> Optional [ T ]: \"\"\"Bumps the version tag phase, if possible. Returns: The next version tag, if present. \"\"\" phase = PHASE_TO_NEXT . get ( self . phase ) return None if phase is None else self . create ( phase ) from_string ( string : str ) -> T classmethod Parses a Tag from string . Parameters: Name Type Description Default string str The string to parse. required Returns: Type Description T The parsed tag. Source code in versions/segments.py 635 636 637 638 639 640 641 642 643 644 645 @classmethod def from_string ( cls : Type [ T ], string : str ) -> T : \"\"\"Parses a [`Tag`][versions.segments.Tag] from `string`. Arguments: string: The string to parse. Returns: The parsed tag. \"\"\" return TagParser ( cls ) . parse ( string ) to_string () -> str Converts a Tag to its string representation. Returns: Type Description str The tag string. Source code in versions/segments.py 647 648 649 650 651 652 653 def to_string ( self ) -> str : \"\"\"Converts a [`Tag`][versions.segments.Tag] to its string representation. Returns: The tag string. \"\"\" return concat_dot_args ( self . phase , str ( self . value )) to_short_string () -> str Converts a Tag to its short string representation. Returns: Type Description str The short tag string. Source code in versions/segments.py 655 656 657 658 659 660 661 def to_short_string ( self ) -> str : \"\"\"Converts a [`Tag`][versions.segments.Tag] to its *short* string representation. Returns: The *short* tag string. \"\"\" return concat_empty_args ( self . short , str ( self . value )) PreTag Bases: Tag Represents the pre-release tag of the version ( pre.n ). Source code in versions/segments.py 664 665 666 667 668 669 @frozen ( repr = False , eq = True , order = True ) class PreTag ( Tag ): \"\"\"Represents the *pre-release* tag of the version (`pre.n`).\"\"\" DEFAULT_PHASE = PHASE_PRE_DEFAULT PHASE_SET = PHASE_PRE_SET PostTag Bases: Tag Represents the post-release tag of the version ( post.n ). Source code in versions/segments.py 672 673 674 675 676 677 @frozen ( repr = False , eq = True , order = True ) class PostTag ( Tag ): \"\"\"Represents the *post-release* tag of the version (`post.n`).\"\"\" DEFAULT_PHASE = PHASE_POST_DEFAULT PHASE_SET = PHASE_POST_SET DevTag Bases: Tag Represents the dev-release tag of the version ( dev.n ). Source code in versions/segments.py 680 681 682 683 684 685 @frozen ( repr = False , eq = True , order = True ) class DevTag ( Tag ): \"\"\"Represents the *dev-release* tag of the version (`dev.n`).\"\"\" DEFAULT_PHASE = PHASE_DEV_DEFAULT PHASE_SET = PHASE_DEV_SET Local Bases: Representation , FromString , ToString Represents the local segment of the version ( +abcdefg.n ) Source code in versions/segments.py 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 @frozen ( repr = False , eq = True , order = True ) class Local ( Representation , FromString , ToString ): \"\"\"Represents the *local* segment of the version (`+abcdefg.n`)\"\"\" parts : LocalParts = field ( eq = False , order = False ) \"\"\"The local segment parts.\"\"\" compare_parts : CompareLocalParts = field ( repr = False , init = False , eq = True , order = True ) @parts . validator def check_parts ( self , attribute : Attribute [ LocalParts ], value : LocalParts ) -> None : if not value : raise ValueError ( EMPTY_LOCAL ) def __attrs_post_init__ ( self ) -> None : evolve_in_place ( self , compare_parts = self . compute_compare_parts ()) def compute_compare_parts ( self ) -> CompareLocalParts : empty = EMPTY return tuple ( ( part , empty ) if is_int ( part ) else ( negative_infinity , part ) # type: ignore for part in self . parts ) @classmethod def create ( cls : Type [ L ], parts : LocalParts ) -> L : \"\"\"Creates a [`Local`][versions.segments.Local] segment from local `parts`. Arguments: parts: The local parts. Returns: The newly created [`Local`][versions.segments.Local] segment. \"\"\" return cls ( parts ) @classmethod def from_iterable ( cls : Type [ L ], iterable : Iterable [ LocalPart ]) -> L : \"\"\"Creates a [`Local`][versions.segments.Local] segment from `iterable`. Arguments: iterable: The local parts in an iterable. Returns: The newly created [`Local`][versions.segments.Local] segment. \"\"\" return cls ( tuple ( iterable )) @classmethod def from_parts ( cls : Type [ L ], * parts : LocalPart ) -> L : \"\"\"Creates a [`Local`][versions.segments.Local] segment from local `parts`. Arguments: *parts: The local parts. Returns: The newly created [`Local`][versions.segments.Local] segment. \"\"\" return cls ( parts ) def into_parts ( self ) -> LocalParts : \"\"\"Converts a [`Local`][versions.segments.Local] segment to its parts. Returns: The parts of the local segment. \"\"\" return self . parts @classmethod def from_string ( cls : Type [ L ], string : str ) -> L : \"\"\"Parses a [`Local`][versions.segments.Local] segment from `string`. Arguments: string: The string to parse. Returns: The parsed local segment. \"\"\" return cls . from_iterable ( map ( local_part , split_separators ( string ))) def to_string ( self ) -> str : \"\"\"Converts a [`Local`][versions.segments.Local] segment to its string representation. Returns: The local segment string. \"\"\" return concat_dot ( map ( str , self . parts )) parts : LocalParts = field ( eq = False , order = False ) class-attribute The local segment parts. create ( parts : LocalParts ) -> L classmethod Creates a Local segment from local parts . Parameters: Name Type Description Default parts LocalParts The local parts. required Returns: Type Description L The newly created Local segment. Source code in versions/segments.py 731 732 733 734 735 736 737 738 739 740 741 @classmethod def create ( cls : Type [ L ], parts : LocalParts ) -> L : \"\"\"Creates a [`Local`][versions.segments.Local] segment from local `parts`. Arguments: parts: The local parts. Returns: The newly created [`Local`][versions.segments.Local] segment. \"\"\" return cls ( parts ) from_iterable ( iterable : Iterable [ LocalPart ]) -> L classmethod Creates a Local segment from iterable . Parameters: Name Type Description Default iterable Iterable [ LocalPart ] The local parts in an iterable. required Returns: Type Description L The newly created Local segment. Source code in versions/segments.py 743 744 745 746 747 748 749 750 751 752 753 @classmethod def from_iterable ( cls : Type [ L ], iterable : Iterable [ LocalPart ]) -> L : \"\"\"Creates a [`Local`][versions.segments.Local] segment from `iterable`. Arguments: iterable: The local parts in an iterable. Returns: The newly created [`Local`][versions.segments.Local] segment. \"\"\" return cls ( tuple ( iterable )) from_parts ( * parts : LocalPart ) -> L classmethod Creates a Local segment from local parts . Parameters: Name Type Description Default *parts LocalPart The local parts. () Returns: Type Description L The newly created Local segment. Source code in versions/segments.py 755 756 757 758 759 760 761 762 763 764 765 @classmethod def from_parts ( cls : Type [ L ], * parts : LocalPart ) -> L : \"\"\"Creates a [`Local`][versions.segments.Local] segment from local `parts`. Arguments: *parts: The local parts. Returns: The newly created [`Local`][versions.segments.Local] segment. \"\"\" return cls ( parts ) into_parts () -> LocalParts Converts a Local segment to its parts. Returns: Type Description LocalParts The parts of the local segment. Source code in versions/segments.py 767 768 769 770 771 772 773 def into_parts ( self ) -> LocalParts : \"\"\"Converts a [`Local`][versions.segments.Local] segment to its parts. Returns: The parts of the local segment. \"\"\" return self . parts from_string ( string : str ) -> L classmethod Parses a Local segment from string . Parameters: Name Type Description Default string str The string to parse. required Returns: Type Description L The parsed local segment. Source code in versions/segments.py 775 776 777 778 779 780 781 782 783 784 785 @classmethod def from_string ( cls : Type [ L ], string : str ) -> L : \"\"\"Parses a [`Local`][versions.segments.Local] segment from `string`. Arguments: string: The string to parse. Returns: The parsed local segment. \"\"\" return cls . from_iterable ( map ( local_part , split_separators ( string ))) to_string () -> str Converts a Local segment to its string representation. Returns: Type Description str The local segment string. Source code in versions/segments.py 787 788 789 790 791 792 793 def to_string ( self ) -> str : \"\"\"Converts a [`Local`][versions.segments.Local] segment to its string representation. Returns: The local segment string. \"\"\" return concat_dot ( map ( str , self . parts ))","title":"Segments"},{"location":"reference/segments/#versions.segments.DEFAULT_PARTS","text":"The default parts of the Release .","title":"DEFAULT_PARTS"},{"location":"reference/segments/#versions.segments.DEFAULT_VALUE","text":"The default value to use.","title":"DEFAULT_VALUE"},{"location":"reference/segments/#versions.segments.DEFAULT_PADDING","text":"The default padding to use.","title":"DEFAULT_PADDING"},{"location":"reference/segments/#versions.segments.Epoch","text":"Bases: Representation , FromString , ToString Represents the epoch segment of the version ( e! ). Source code in versions/segments.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 @frozen ( repr = False , eq = True , order = True ) class Epoch ( Representation , FromString , ToString ): \"\"\"Represents the *epoch* segment of the version (`e!`).\"\"\" value : int = field ( default = DEFAULT_VALUE ) \"\"\"The value of the epoch.\"\"\" def __bool__ ( self ) -> bool : return bool ( self . value ) @classmethod def create ( cls : Type [ E ], value : int = DEFAULT_VALUE ) -> E : \"\"\"Creates an [`Epoch`][versions.segments.Epoch] from `value`. Arguments: value: The value of the epoch. Returns: The newly created [`Epoch`][versions.segments.Epoch]. \"\"\" return cls ( value ) @classmethod def from_string ( cls : Type [ E ], string : str ) -> E : \"\"\"Parses an [`Epoch`][versions.segments.Epoch] from `string`. Arguments: string: The string to parse. Returns: The parsed epoch. \"\"\" return cls ( int ( string )) def to_string ( self ) -> str : \"\"\"Converts an [`Epoch`][versions.segments.Epoch] to its string representation. Returns: The epoch string. \"\"\" return str ( self . value )","title":"Epoch"},{"location":"reference/segments/#versions.segments.Epoch.value","text":"The value of the epoch.","title":"value"},{"location":"reference/segments/#versions.segments.Epoch.create","text":"Creates an Epoch from value . Parameters: Name Type Description Default value int The value of the epoch. DEFAULT_VALUE Returns: Type Description E The newly created Epoch . Source code in versions/segments.py 98 99 100 101 102 103 104 105 106 107 108 @classmethod def create ( cls : Type [ E ], value : int = DEFAULT_VALUE ) -> E : \"\"\"Creates an [`Epoch`][versions.segments.Epoch] from `value`. Arguments: value: The value of the epoch. Returns: The newly created [`Epoch`][versions.segments.Epoch]. \"\"\" return cls ( value )","title":"create()"},{"location":"reference/segments/#versions.segments.Epoch.from_string","text":"Parses an Epoch from string . Parameters: Name Type Description Default string str The string to parse. required Returns: Type Description E The parsed epoch. Source code in versions/segments.py 110 111 112 113 114 115 116 117 118 119 120 @classmethod def from_string ( cls : Type [ E ], string : str ) -> E : \"\"\"Parses an [`Epoch`][versions.segments.Epoch] from `string`. Arguments: string: The string to parse. Returns: The parsed epoch. \"\"\" return cls ( int ( string ))","title":"from_string()"},{"location":"reference/segments/#versions.segments.Epoch.to_string","text":"Converts an Epoch to its string representation. Returns: Type Description str The epoch string. Source code in versions/segments.py 122 123 124 125 126 127 128 def to_string ( self ) -> str : \"\"\"Converts an [`Epoch`][versions.segments.Epoch] to its string representation. Returns: The epoch string. \"\"\" return str ( self . value )","title":"to_string()"},{"location":"reference/segments/#versions.segments.Release","text":"Bases: Representation , FromString , ToString Represents the release segment of the version ( x.y.z ). Source code in versions/segments.py 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 @frozen ( repr = False , eq = True , order = True ) class Release ( Representation , FromString , ToString ): \"\"\"Represents the *release* segment of the version (`x.y.z`).\"\"\" parts : Parts = field ( default = DEFAULT_PARTS , eq = False , order = False ) \"\"\"The parts of the release.\"\"\" compare_parts : Parts = field ( repr = False , init = False , eq = True , order = True ) @parts . validator def check_parts ( self , attribute : Attribute [ Parts ], value : Parts ) -> None : if not value : raise ValueError ( EMPTY_RELEASE ) def __attrs_post_init__ ( self ) -> None : evolve_in_place ( self , compare_parts = self . compute_compare_parts ()) def compute_compare_parts ( self ) -> Parts : parts = self . parts index = count_leading_zeros ( reversed ( parts )) if index == self . precision : index -= 1 return self . slice_parts ( - index ) if index else parts @classmethod def create ( cls : Type [ R ], parts : Parts = DEFAULT_PARTS ) -> R : \"\"\"Creates a [`Release`][versions.segments.Release] from `parts`. Arguments: parts: The parts of the release. Returns: The newly created [`Release`][versions.segments.Release]. \"\"\" return cls ( parts ) @classmethod def from_iterable ( cls : Type [ R ], iterable : Iterable [ int ]) -> R : \"\"\"Creates a [`Release`][versions.segments.Release] from `iterable`. Arguments: iterable: The parts of the release in an iterable. Returns: The newly created [`Release`][versions.segments.Release]. \"\"\" return cls ( tuple ( iterable )) @classmethod def from_parts ( cls : Type [ R ], * parts : int ) -> R : \"\"\"Creates a [`Release`][versions.segments.Release] from `parts`. Arguments: *parts: The parts of the release. Returns: The newly created [`Release`][versions.segments.Release]. \"\"\" return cls ( parts ) def into_parts ( self ) -> Parts : \"\"\"Converts a [`Release`][versions.segments.Release] to its parts. Returns: The parts of the release. \"\"\" return self . parts @property def precision ( self ) -> int : \"\"\"The count of the release parts.\"\"\" return len ( self . parts ) @property def last_index ( self ) -> int : \"\"\"The index of the last release part.\"\"\" return self . precision - 1 @property def major ( self ) -> int : \"\"\"The *major* part of the release.\"\"\" return self . get_at ( MAJOR ) @property def minor ( self ) -> int : \"\"\"The *minor* part of the release.\"\"\" return self . get_at ( MINOR ) @property def micro ( self ) -> int : \"\"\"The *micro* part of the release.\"\"\" return self . get_at ( MICRO ) @property def patch ( self ) -> int : \"\"\"The *patch* part of the release. This is equivalent to [`micro`][versions.segments.Release.micro]. \"\"\" return self . get_at ( PATCH ) @property def extra ( self ) -> Extra : \"\"\"The *extra* parts of the release.\"\"\" return self . parts [ TOTAL :] def get_at ( self , index : int , default : int = DEFAULT_VALUE ) -> int : \"\"\"Gets the release part at the `index`, defaulting to `default`. Arguments: index: The index of the part to get. default: The default value to use. Returns: The release part at `index` or the `default` value. \"\"\" return self . get_at_unchecked ( index ) if self . has_at ( index ) else default def get_at_unchecked ( self , index : int ) -> int : \"\"\"Gets the release part at the `index`. Arguments: index: The index of the part to get. Raises: IndexError: The index is *out-of-bounds*. Returns: The release part at `index`. \"\"\" return self . parts [ index ] def is_semantic ( self ) -> bool : \"\"\"Checks if the release matches the *semantic versioning* schema. Returns: Whether the release matches the [`semver`](https://semver.org/) schema. \"\"\" return self . precision == TOTAL def to_semantic ( self : R ) -> R : \"\"\"Converts the release to match the [`semver`](https://semver.org/) schema. Returns: The converted release. \"\"\" if self . has_extra (): return self . next_patch () . slice ( TOTAL ) return self if self . is_semantic () else self . pad_to ( TOTAL ) def set_major ( self : R , value : int ) -> R : \"\"\"Sets the *major* part of the release to the `value`. Arguments: value: The value to set the *major* part to. Returns: The updated release. \"\"\" return self . set_at ( MAJOR , value ) def set_minor ( self : R , value : int ) -> R : \"\"\"Sets the *minor* part of the release to the `value`. Arguments: value: The value to set the *minor* part to. Returns: The updated release. \"\"\" return self . set_at ( MINOR , value ) def set_micro ( self : R , value : int ) -> R : \"\"\"Sets the *micro* part of the release to the `value`. Arguments: value: The value to set the *micro* part to. Returns: The updated release. \"\"\" return self . set_at ( MICRO , value ) def set_patch ( self : R , value : int ) -> R : \"\"\"Sets the *patch* part of the release to the `value`. This is equivalent to [`set_micro`][versions.segments.Release.set_micro]. Arguments: value: The value to set the *patch* part to. Returns: The updated release. \"\"\" return self . set_at ( PATCH , value ) def set_at ( self : R , index : int , value : int ) -> R : \"\"\"Sets the release part at the `index` to the `value`. Arguments: index: The index to set the `value` at. value: The value to set the part to. Returns: The updated release. \"\"\" return self . pad_to_index ( index ) . set_at_unchecked ( index , value ) def set_at_unchecked ( self : R , index : int , value : int ) -> R : \"\"\"Sets the release part at the `index` to the `value`. Arguments: index: The index to set the `value` at. value: The value to set the part to. Raises: IndexError: The index is *out-of-bounds*. Returns: The updated release. \"\"\" mutable = list ( self . parts ) mutable [ index ] = value return self . from_iterable ( mutable ) def next_major ( self : R ) -> R : \"\"\"Bumps the *major* part of the release. Returns: The bumped release. \"\"\" return self . next_at ( MAJOR ) def next_minor ( self : R ) -> R : \"\"\"Bumps the *minor* part of the release. Returns: The bumped release. \"\"\" return self . next_at ( MINOR ) def next_micro ( self : R ) -> R : \"\"\"Bumps the *micro* part of the release. Returns: The bumped release. \"\"\" return self . next_at ( MICRO ) def next_patch ( self : R ) -> R : \"\"\"Bumps the *patch* part of the release. This is equivalent to [`next_micro`][versions.segments.Release.next_micro]. Returns: The bumped release. \"\"\" return self . next_at ( PATCH ) def next_at ( self : R , index : int ) -> R : \"\"\"Bumps the part of the release at the `index`. Arguments: index: The index to bump the part at. Returns: The bumped release. \"\"\" updated = self . set_at ( index , self . get_at ( index ) + 1 ) return updated . slice ( index + 1 ) . pad_to ( updated . precision ) def has_major ( self ) -> bool : \"\"\"Checks if the release has the *major* part. Returns: Whether the *major* part is present. \"\"\" return self . has_at ( MAJOR ) def has_minor ( self ) -> bool : \"\"\"Checks if the release has the *minor* part. Returns: Whether the *minor* part is present. \"\"\" return self . has_at ( MINOR ) def has_micro ( self ) -> bool : \"\"\"Checks if the release has the *micro* part. Returns: Whether the *micro* part is present. \"\"\" return self . has_at ( MICRO ) def has_patch ( self ) -> bool : \"\"\"Checks if the release has the *patch* part. This is equivalent to [`has_micro`][versions.segments.Release.has_micro]. Returns: Whether the *patch* part is present. \"\"\" return self . has_at ( PATCH ) def has_extra ( self ) -> bool : \"\"\"Checks if the release has any *extra* parts. Returns: Whether the *extra* parts are present. \"\"\" return self . has_at ( TOTAL ) def has_at ( self , index : int ) -> bool : \"\"\"Checks if the release has a part at the `index`. Returns: Whether the part at the `index` is present. \"\"\" return self . precision > index def pad_to ( self : R , length : int , padding : int = DEFAULT_PADDING ) -> R : \"\"\"Pads a [`Release`][versions.segments.Release] to the `length` with `padding`. Arguments: length: The length to pad the release to. padding: The padding to use. Returns: The padded release. \"\"\" if self . precision < length : return self . from_iterable ( fix_to_length ( length , padding , self . parts )) return self def pad_to_index ( self : R , index : int , padding : int = DEFAULT_PADDING ) -> R : \"\"\"Pads a [`Release`][versions.segments.Release] to the `index` with `padding`. Arguments: index: The index to pad the release to. padding: The padding to use. Returns: The padded release. \"\"\" return self . pad_to ( index + 1 , padding ) def pad_to_next ( self : R , padding : int = DEFAULT_PADDING ) -> R : \"\"\"Pads a [`Release`][versions.segments.Release] to the next index. Arguments: padding: The padding to use. Returns: The padded release. \"\"\" return self . pad_to ( self . precision + 1 , padding ) def slice ( self : R , stop : int ) -> R : return self . create ( self . slice_parts ( stop )) def slice_parts ( self , stop : int ) -> Parts : return self . parts [: stop ] @classmethod def from_string ( cls : Type [ R ], string : str ) -> R : \"\"\"Parses a [`Release`][versions.segments.Release] from `string`. Arguments: string: The string to parse. Returns: The parsed release. \"\"\" return cls . from_iterable ( map ( int , split_dot ( string ))) def to_string ( self ) -> str : \"\"\"Converts a [`Release`][versions.segments.Release] to its string representation. Returns: The release string. \"\"\" return concat_dot ( map ( str , self . parts ))","title":"Release"},{"location":"reference/segments/#versions.segments.Release.parts","text":"The parts of the release.","title":"parts"},{"location":"reference/segments/#versions.segments.Release.create","text":"Creates a Release from parts . Parameters: Name Type Description Default parts Parts The parts of the release. DEFAULT_PARTS Returns: Type Description R The newly created Release . Source code in versions/segments.py 163 164 165 166 167 168 169 170 171 172 173 @classmethod def create ( cls : Type [ R ], parts : Parts = DEFAULT_PARTS ) -> R : \"\"\"Creates a [`Release`][versions.segments.Release] from `parts`. Arguments: parts: The parts of the release. Returns: The newly created [`Release`][versions.segments.Release]. \"\"\" return cls ( parts )","title":"create()"},{"location":"reference/segments/#versions.segments.Release.from_iterable","text":"Creates a Release from iterable . Parameters: Name Type Description Default iterable Iterable [ int ] The parts of the release in an iterable. required Returns: Type Description R The newly created Release . Source code in versions/segments.py 175 176 177 178 179 180 181 182 183 184 185 @classmethod def from_iterable ( cls : Type [ R ], iterable : Iterable [ int ]) -> R : \"\"\"Creates a [`Release`][versions.segments.Release] from `iterable`. Arguments: iterable: The parts of the release in an iterable. Returns: The newly created [`Release`][versions.segments.Release]. \"\"\" return cls ( tuple ( iterable ))","title":"from_iterable()"},{"location":"reference/segments/#versions.segments.Release.from_parts","text":"Creates a Release from parts . Parameters: Name Type Description Default *parts int The parts of the release. () Returns: Type Description R The newly created Release . Source code in versions/segments.py 187 188 189 190 191 192 193 194 195 196 197 @classmethod def from_parts ( cls : Type [ R ], * parts : int ) -> R : \"\"\"Creates a [`Release`][versions.segments.Release] from `parts`. Arguments: *parts: The parts of the release. Returns: The newly created [`Release`][versions.segments.Release]. \"\"\" return cls ( parts )","title":"from_parts()"},{"location":"reference/segments/#versions.segments.Release.into_parts","text":"Converts a Release to its parts. Returns: Type Description Parts The parts of the release. Source code in versions/segments.py 199 200 201 202 203 204 205 def into_parts ( self ) -> Parts : \"\"\"Converts a [`Release`][versions.segments.Release] to its parts. Returns: The parts of the release. \"\"\" return self . parts","title":"into_parts()"},{"location":"reference/segments/#versions.segments.Release.precision","text":"The count of the release parts. Source code in versions/segments.py 207 208 209 210 @property def precision ( self ) -> int : \"\"\"The count of the release parts.\"\"\" return len ( self . parts )","title":"precision()"},{"location":"reference/segments/#versions.segments.Release.last_index","text":"The index of the last release part. Source code in versions/segments.py 212 213 214 215 @property def last_index ( self ) -> int : \"\"\"The index of the last release part.\"\"\" return self . precision - 1","title":"last_index()"},{"location":"reference/segments/#versions.segments.Release.major","text":"The major part of the release. Source code in versions/segments.py 217 218 219 220 @property def major ( self ) -> int : \"\"\"The *major* part of the release.\"\"\" return self . get_at ( MAJOR )","title":"major()"},{"location":"reference/segments/#versions.segments.Release.minor","text":"The minor part of the release. Source code in versions/segments.py 222 223 224 225 @property def minor ( self ) -> int : \"\"\"The *minor* part of the release.\"\"\" return self . get_at ( MINOR )","title":"minor()"},{"location":"reference/segments/#versions.segments.Release.micro","text":"The micro part of the release. Source code in versions/segments.py 227 228 229 230 @property def micro ( self ) -> int : \"\"\"The *micro* part of the release.\"\"\" return self . get_at ( MICRO )","title":"micro()"},{"location":"reference/segments/#versions.segments.Release.patch","text":"The patch part of the release. This is equivalent to micro . Source code in versions/segments.py 232 233 234 235 236 237 238 @property def patch ( self ) -> int : \"\"\"The *patch* part of the release. This is equivalent to [`micro`][versions.segments.Release.micro]. \"\"\" return self . get_at ( PATCH )","title":"patch()"},{"location":"reference/segments/#versions.segments.Release.extra","text":"The extra parts of the release. Source code in versions/segments.py 240 241 242 243 @property def extra ( self ) -> Extra : \"\"\"The *extra* parts of the release.\"\"\" return self . parts [ TOTAL :]","title":"extra()"},{"location":"reference/segments/#versions.segments.Release.get_at","text":"Gets the release part at the index , defaulting to default . Parameters: Name Type Description Default index int The index of the part to get. required default int The default value to use. DEFAULT_VALUE Returns: Type Description int The release part at index or the default value. Source code in versions/segments.py 245 246 247 248 249 250 251 252 253 254 255 def get_at ( self , index : int , default : int = DEFAULT_VALUE ) -> int : \"\"\"Gets the release part at the `index`, defaulting to `default`. Arguments: index: The index of the part to get. default: The default value to use. Returns: The release part at `index` or the `default` value. \"\"\" return self . get_at_unchecked ( index ) if self . has_at ( index ) else default","title":"get_at()"},{"location":"reference/segments/#versions.segments.Release.get_at_unchecked","text":"Gets the release part at the index . Parameters: Name Type Description Default index int The index of the part to get. required Raises: Type Description IndexError The index is out-of-bounds . Returns: Type Description int The release part at index . Source code in versions/segments.py 257 258 259 260 261 262 263 264 265 266 267 268 269 def get_at_unchecked ( self , index : int ) -> int : \"\"\"Gets the release part at the `index`. Arguments: index: The index of the part to get. Raises: IndexError: The index is *out-of-bounds*. Returns: The release part at `index`. \"\"\" return self . parts [ index ]","title":"get_at_unchecked()"},{"location":"reference/segments/#versions.segments.Release.is_semantic","text":"Checks if the release matches the semantic versioning schema. Returns: Type Description bool Whether the release matches the semver schema. Source code in versions/segments.py 271 272 273 274 275 276 277 def is_semantic ( self ) -> bool : \"\"\"Checks if the release matches the *semantic versioning* schema. Returns: Whether the release matches the [`semver`](https://semver.org/) schema. \"\"\" return self . precision == TOTAL","title":"is_semantic()"},{"location":"reference/segments/#versions.segments.Release.to_semantic","text":"Converts the release to match the semver schema. Returns: Type Description R The converted release. Source code in versions/segments.py 279 280 281 282 283 284 285 286 287 288 def to_semantic ( self : R ) -> R : \"\"\"Converts the release to match the [`semver`](https://semver.org/) schema. Returns: The converted release. \"\"\" if self . has_extra (): return self . next_patch () . slice ( TOTAL ) return self if self . is_semantic () else self . pad_to ( TOTAL )","title":"to_semantic()"},{"location":"reference/segments/#versions.segments.Release.set_major","text":"Sets the major part of the release to the value . Parameters: Name Type Description Default value int The value to set the major part to. required Returns: Type Description R The updated release. Source code in versions/segments.py 290 291 292 293 294 295 296 297 298 299 def set_major ( self : R , value : int ) -> R : \"\"\"Sets the *major* part of the release to the `value`. Arguments: value: The value to set the *major* part to. Returns: The updated release. \"\"\" return self . set_at ( MAJOR , value )","title":"set_major()"},{"location":"reference/segments/#versions.segments.Release.set_minor","text":"Sets the minor part of the release to the value . Parameters: Name Type Description Default value int The value to set the minor part to. required Returns: Type Description R The updated release. Source code in versions/segments.py 301 302 303 304 305 306 307 308 309 310 def set_minor ( self : R , value : int ) -> R : \"\"\"Sets the *minor* part of the release to the `value`. Arguments: value: The value to set the *minor* part to. Returns: The updated release. \"\"\" return self . set_at ( MINOR , value )","title":"set_minor()"},{"location":"reference/segments/#versions.segments.Release.set_micro","text":"Sets the micro part of the release to the value . Parameters: Name Type Description Default value int The value to set the micro part to. required Returns: Type Description R The updated release. Source code in versions/segments.py 312 313 314 315 316 317 318 319 320 321 def set_micro ( self : R , value : int ) -> R : \"\"\"Sets the *micro* part of the release to the `value`. Arguments: value: The value to set the *micro* part to. Returns: The updated release. \"\"\" return self . set_at ( MICRO , value )","title":"set_micro()"},{"location":"reference/segments/#versions.segments.Release.set_patch","text":"Sets the patch part of the release to the value . This is equivalent to set_micro . Parameters: Name Type Description Default value int The value to set the patch part to. required Returns: Type Description R The updated release. Source code in versions/segments.py 323 324 325 326 327 328 329 330 331 332 333 334 def set_patch ( self : R , value : int ) -> R : \"\"\"Sets the *patch* part of the release to the `value`. This is equivalent to [`set_micro`][versions.segments.Release.set_micro]. Arguments: value: The value to set the *patch* part to. Returns: The updated release. \"\"\" return self . set_at ( PATCH , value )","title":"set_patch()"},{"location":"reference/segments/#versions.segments.Release.set_at","text":"Sets the release part at the index to the value . Parameters: Name Type Description Default index int The index to set the value at. required value int The value to set the part to. required Returns: Type Description R The updated release. Source code in versions/segments.py 336 337 338 339 340 341 342 343 344 345 346 def set_at ( self : R , index : int , value : int ) -> R : \"\"\"Sets the release part at the `index` to the `value`. Arguments: index: The index to set the `value` at. value: The value to set the part to. Returns: The updated release. \"\"\" return self . pad_to_index ( index ) . set_at_unchecked ( index , value )","title":"set_at()"},{"location":"reference/segments/#versions.segments.Release.set_at_unchecked","text":"Sets the release part at the index to the value . Parameters: Name Type Description Default index int The index to set the value at. required value int The value to set the part to. required Raises: Type Description IndexError The index is out-of-bounds . Returns: Type Description R The updated release. Source code in versions/segments.py 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 def set_at_unchecked ( self : R , index : int , value : int ) -> R : \"\"\"Sets the release part at the `index` to the `value`. Arguments: index: The index to set the `value` at. value: The value to set the part to. Raises: IndexError: The index is *out-of-bounds*. Returns: The updated release. \"\"\" mutable = list ( self . parts ) mutable [ index ] = value return self . from_iterable ( mutable )","title":"set_at_unchecked()"},{"location":"reference/segments/#versions.segments.Release.next_major","text":"Bumps the major part of the release. Returns: Type Description R The bumped release. Source code in versions/segments.py 366 367 368 369 370 371 372 def next_major ( self : R ) -> R : \"\"\"Bumps the *major* part of the release. Returns: The bumped release. \"\"\" return self . next_at ( MAJOR )","title":"next_major()"},{"location":"reference/segments/#versions.segments.Release.next_minor","text":"Bumps the minor part of the release. Returns: Type Description R The bumped release. Source code in versions/segments.py 374 375 376 377 378 379 380 def next_minor ( self : R ) -> R : \"\"\"Bumps the *minor* part of the release. Returns: The bumped release. \"\"\" return self . next_at ( MINOR )","title":"next_minor()"},{"location":"reference/segments/#versions.segments.Release.next_micro","text":"Bumps the micro part of the release. Returns: Type Description R The bumped release. Source code in versions/segments.py 382 383 384 385 386 387 388 def next_micro ( self : R ) -> R : \"\"\"Bumps the *micro* part of the release. Returns: The bumped release. \"\"\" return self . next_at ( MICRO )","title":"next_micro()"},{"location":"reference/segments/#versions.segments.Release.next_patch","text":"Bumps the patch part of the release. This is equivalent to next_micro . Returns: Type Description R The bumped release. Source code in versions/segments.py 390 391 392 393 394 395 396 397 398 def next_patch ( self : R ) -> R : \"\"\"Bumps the *patch* part of the release. This is equivalent to [`next_micro`][versions.segments.Release.next_micro]. Returns: The bumped release. \"\"\" return self . next_at ( PATCH )","title":"next_patch()"},{"location":"reference/segments/#versions.segments.Release.next_at","text":"Bumps the part of the release at the index . Parameters: Name Type Description Default index int The index to bump the part at. required Returns: Type Description R The bumped release. Source code in versions/segments.py 400 401 402 403 404 405 406 407 408 409 410 411 def next_at ( self : R , index : int ) -> R : \"\"\"Bumps the part of the release at the `index`. Arguments: index: The index to bump the part at. Returns: The bumped release. \"\"\" updated = self . set_at ( index , self . get_at ( index ) + 1 ) return updated . slice ( index + 1 ) . pad_to ( updated . precision )","title":"next_at()"},{"location":"reference/segments/#versions.segments.Release.has_major","text":"Checks if the release has the major part. Returns: Type Description bool Whether the major part is present. Source code in versions/segments.py 413 414 415 416 417 418 419 def has_major ( self ) -> bool : \"\"\"Checks if the release has the *major* part. Returns: Whether the *major* part is present. \"\"\" return self . has_at ( MAJOR )","title":"has_major()"},{"location":"reference/segments/#versions.segments.Release.has_minor","text":"Checks if the release has the minor part. Returns: Type Description bool Whether the minor part is present. Source code in versions/segments.py 421 422 423 424 425 426 427 def has_minor ( self ) -> bool : \"\"\"Checks if the release has the *minor* part. Returns: Whether the *minor* part is present. \"\"\" return self . has_at ( MINOR )","title":"has_minor()"},{"location":"reference/segments/#versions.segments.Release.has_micro","text":"Checks if the release has the micro part. Returns: Type Description bool Whether the micro part is present. Source code in versions/segments.py 429 430 431 432 433 434 435 def has_micro ( self ) -> bool : \"\"\"Checks if the release has the *micro* part. Returns: Whether the *micro* part is present. \"\"\" return self . has_at ( MICRO )","title":"has_micro()"},{"location":"reference/segments/#versions.segments.Release.has_patch","text":"Checks if the release has the patch part. This is equivalent to has_micro . Returns: Type Description bool Whether the patch part is present. Source code in versions/segments.py 437 438 439 440 441 442 443 444 445 def has_patch ( self ) -> bool : \"\"\"Checks if the release has the *patch* part. This is equivalent to [`has_micro`][versions.segments.Release.has_micro]. Returns: Whether the *patch* part is present. \"\"\" return self . has_at ( PATCH )","title":"has_patch()"},{"location":"reference/segments/#versions.segments.Release.has_extra","text":"Checks if the release has any extra parts. Returns: Type Description bool Whether the extra parts are present. Source code in versions/segments.py 447 448 449 450 451 452 453 def has_extra ( self ) -> bool : \"\"\"Checks if the release has any *extra* parts. Returns: Whether the *extra* parts are present. \"\"\" return self . has_at ( TOTAL )","title":"has_extra()"},{"location":"reference/segments/#versions.segments.Release.has_at","text":"Checks if the release has a part at the index . Returns: Type Description bool Whether the part at the index is present. Source code in versions/segments.py 455 456 457 458 459 460 461 def has_at ( self , index : int ) -> bool : \"\"\"Checks if the release has a part at the `index`. Returns: Whether the part at the `index` is present. \"\"\" return self . precision > index","title":"has_at()"},{"location":"reference/segments/#versions.segments.Release.pad_to","text":"Pads a Release to the length with padding . Parameters: Name Type Description Default length int The length to pad the release to. required padding int The padding to use. DEFAULT_PADDING Returns: Type Description R The padded release. Source code in versions/segments.py 463 464 465 466 467 468 469 470 471 472 473 474 475 476 def pad_to ( self : R , length : int , padding : int = DEFAULT_PADDING ) -> R : \"\"\"Pads a [`Release`][versions.segments.Release] to the `length` with `padding`. Arguments: length: The length to pad the release to. padding: The padding to use. Returns: The padded release. \"\"\" if self . precision < length : return self . from_iterable ( fix_to_length ( length , padding , self . parts )) return self","title":"pad_to()"},{"location":"reference/segments/#versions.segments.Release.pad_to_index","text":"Pads a Release to the index with padding . Parameters: Name Type Description Default index int The index to pad the release to. required padding int The padding to use. DEFAULT_PADDING Returns: Type Description R The padded release. Source code in versions/segments.py 478 479 480 481 482 483 484 485 486 487 488 def pad_to_index ( self : R , index : int , padding : int = DEFAULT_PADDING ) -> R : \"\"\"Pads a [`Release`][versions.segments.Release] to the `index` with `padding`. Arguments: index: The index to pad the release to. padding: The padding to use. Returns: The padded release. \"\"\" return self . pad_to ( index + 1 , padding )","title":"pad_to_index()"},{"location":"reference/segments/#versions.segments.Release.pad_to_next","text":"Pads a Release to the next index. Parameters: Name Type Description Default padding int The padding to use. DEFAULT_PADDING Returns: Type Description R The padded release. Source code in versions/segments.py 490 491 492 493 494 495 496 497 498 499 def pad_to_next ( self : R , padding : int = DEFAULT_PADDING ) -> R : \"\"\"Pads a [`Release`][versions.segments.Release] to the next index. Arguments: padding: The padding to use. Returns: The padded release. \"\"\" return self . pad_to ( self . precision + 1 , padding )","title":"pad_to_next()"},{"location":"reference/segments/#versions.segments.Release.from_string","text":"Parses a Release from string . Parameters: Name Type Description Default string str The string to parse. required Returns: Type Description R The parsed release. Source code in versions/segments.py 507 508 509 510 511 512 513 514 515 516 517 @classmethod def from_string ( cls : Type [ R ], string : str ) -> R : \"\"\"Parses a [`Release`][versions.segments.Release] from `string`. Arguments: string: The string to parse. Returns: The parsed release. \"\"\" return cls . from_iterable ( map ( int , split_dot ( string )))","title":"from_string()"},{"location":"reference/segments/#versions.segments.Release.to_string","text":"Converts a Release to its string representation. Returns: Type Description str The release string. Source code in versions/segments.py 519 520 521 522 523 524 525 def to_string ( self ) -> str : \"\"\"Converts a [`Release`][versions.segments.Release] to its string representation. Returns: The release string. \"\"\" return concat_dot ( map ( str , self . parts ))","title":"to_string()"},{"location":"reference/segments/#versions.segments.Tag","text":"Bases: Representation , FromString , ToString Represents various version tags ( tag.n ). Source code in versions/segments.py 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 @frozen ( repr = False , eq = True , order = True ) class Tag ( Representation , FromString , ToString ): \"\"\"Represents various version *tags* (`tag.n`).\"\"\" DEFAULT_PHASE : ClassVar [ str ] = PHASE_ALL_DEFAULT PHASE_SET : ClassVar [ Set [ str ]] = PHASE_ALL_SET phase : str = field ( converter = case_fold ) # type: ignore \"\"\"The phase of the release tag.\"\"\" value : int = field ( default = DEFAULT_VALUE ) \"\"\"The value of the release tag.\"\"\" @phase . default def default_phase ( self ) -> str : return self . DEFAULT_PHASE @phase . validator def check_phase ( self , attribute : Attribute [ str ], value : str ) -> None : if value not in self . PHASE_SET : raise ValueError ( PHASE_NOT_ALLOWED . format ( value , get_name ( type ( self )))) def __attrs_post_init__ ( self ) -> None : evolve_in_place ( self , phase = self . expand ( self . phase )) @staticmethod def expand ( phase : str ) -> str : return SHORT_TO_PHASE . get ( phase , phase ) @staticmethod def reduce ( phase : str ) -> str : return PHASE_TO_SHORT . get ( phase , phase ) @staticmethod def normalize_phase ( phase : str ) -> str : return PHASE_TO_NORMAL . get ( phase , phase ) @classmethod def create ( cls : Type [ T ], phase : Optional [ str ] = None , value : int = DEFAULT_VALUE ) -> T : \"\"\"Creates a [`Tag`][versions.segments.Tag] from `phase` and `value`. Arguments: phase: The phase of the tag. value: The value of the tag. Returns: The newly created [`Tag`][versions.segments.Tag]. \"\"\" if phase is None : phase = cls . DEFAULT_PHASE return cls ( phase , value ) @classmethod def default_phase_with_value ( cls : Type [ T ], value : int ) -> T : \"\"\"Creates a [`Tag`][versions.segments.Tag] from `value` with the default phase. Arguments: value: The value of the tag. Returns: The newly created [`Tag`][versions.segments.Tag]. \"\"\" return cls ( cls . DEFAULT_PHASE , value ) @property def short ( self ) -> str : \"\"\"The *short* phase of the release.\"\"\" return self . reduce ( self . phase ) @property def normal ( self ) -> str : \"\"\"The *normalized* phase of the release.\"\"\" return self . normalize_phase ( self . phase ) def normalize ( self : T ) -> T : \"\"\"Normalizes the version tag. Returns: The normalized tag. \"\"\" return evolve ( self , phase = self . normal ) def next ( self : T ) -> T : \"\"\"Bumps the version tag. Returns: The next version tag. \"\"\" return evolve ( self , value = self . value + 1 ) def next_phase ( self : T ) -> Optional [ T ]: \"\"\"Bumps the version tag phase, if possible. Returns: The next version tag, if present. \"\"\" phase = PHASE_TO_NEXT . get ( self . phase ) return None if phase is None else self . create ( phase ) @classmethod def from_string ( cls : Type [ T ], string : str ) -> T : \"\"\"Parses a [`Tag`][versions.segments.Tag] from `string`. Arguments: string: The string to parse. Returns: The parsed tag. \"\"\" return TagParser ( cls ) . parse ( string ) def to_string ( self ) -> str : \"\"\"Converts a [`Tag`][versions.segments.Tag] to its string representation. Returns: The tag string. \"\"\" return concat_dot_args ( self . phase , str ( self . value )) def to_short_string ( self ) -> str : \"\"\"Converts a [`Tag`][versions.segments.Tag] to its *short* string representation. Returns: The *short* tag string. \"\"\" return concat_empty_args ( self . short , str ( self . value ))","title":"Tag"},{"location":"reference/segments/#versions.segments.Tag.phase","text":"The phase of the release tag.","title":"phase"},{"location":"reference/segments/#versions.segments.Tag.value","text":"The value of the release tag.","title":"value"},{"location":"reference/segments/#versions.segments.Tag.create","text":"Creates a Tag from phase and value . Parameters: Name Type Description Default phase Optional [ str ] The phase of the tag. None value int The value of the tag. DEFAULT_VALUE Returns: Type Description T The newly created Tag . Source code in versions/segments.py 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 @classmethod def create ( cls : Type [ T ], phase : Optional [ str ] = None , value : int = DEFAULT_VALUE ) -> T : \"\"\"Creates a [`Tag`][versions.segments.Tag] from `phase` and `value`. Arguments: phase: The phase of the tag. value: The value of the tag. Returns: The newly created [`Tag`][versions.segments.Tag]. \"\"\" if phase is None : phase = cls . DEFAULT_PHASE return cls ( phase , value )","title":"create()"},{"location":"reference/segments/#versions.segments.Tag.default_phase_with_value","text":"Creates a Tag from value with the default phase. Parameters: Name Type Description Default value int The value of the tag. required Returns: Type Description T The newly created Tag . Source code in versions/segments.py 587 588 589 590 591 592 593 594 595 596 597 @classmethod def default_phase_with_value ( cls : Type [ T ], value : int ) -> T : \"\"\"Creates a [`Tag`][versions.segments.Tag] from `value` with the default phase. Arguments: value: The value of the tag. Returns: The newly created [`Tag`][versions.segments.Tag]. \"\"\" return cls ( cls . DEFAULT_PHASE , value )","title":"default_phase_with_value()"},{"location":"reference/segments/#versions.segments.Tag.short","text":"The short phase of the release. Source code in versions/segments.py 599 600 601 602 @property def short ( self ) -> str : \"\"\"The *short* phase of the release.\"\"\" return self . reduce ( self . phase )","title":"short()"},{"location":"reference/segments/#versions.segments.Tag.normal","text":"The normalized phase of the release. Source code in versions/segments.py 604 605 606 607 @property def normal ( self ) -> str : \"\"\"The *normalized* phase of the release.\"\"\" return self . normalize_phase ( self . phase )","title":"normal()"},{"location":"reference/segments/#versions.segments.Tag.normalize","text":"Normalizes the version tag. Returns: Type Description T The normalized tag. Source code in versions/segments.py 609 610 611 612 613 614 615 def normalize ( self : T ) -> T : \"\"\"Normalizes the version tag. Returns: The normalized tag. \"\"\" return evolve ( self , phase = self . normal )","title":"normalize()"},{"location":"reference/segments/#versions.segments.Tag.next","text":"Bumps the version tag. Returns: Type Description T The next version tag. Source code in versions/segments.py 617 618 619 620 621 622 623 def next ( self : T ) -> T : \"\"\"Bumps the version tag. Returns: The next version tag. \"\"\" return evolve ( self , value = self . value + 1 )","title":"next()"},{"location":"reference/segments/#versions.segments.Tag.next_phase","text":"Bumps the version tag phase, if possible. Returns: Type Description Optional [ T ] The next version tag, if present. Source code in versions/segments.py 625 626 627 628 629 630 631 632 633 def next_phase ( self : T ) -> Optional [ T ]: \"\"\"Bumps the version tag phase, if possible. Returns: The next version tag, if present. \"\"\" phase = PHASE_TO_NEXT . get ( self . phase ) return None if phase is None else self . create ( phase )","title":"next_phase()"},{"location":"reference/segments/#versions.segments.Tag.from_string","text":"Parses a Tag from string . Parameters: Name Type Description Default string str The string to parse. required Returns: Type Description T The parsed tag. Source code in versions/segments.py 635 636 637 638 639 640 641 642 643 644 645 @classmethod def from_string ( cls : Type [ T ], string : str ) -> T : \"\"\"Parses a [`Tag`][versions.segments.Tag] from `string`. Arguments: string: The string to parse. Returns: The parsed tag. \"\"\" return TagParser ( cls ) . parse ( string )","title":"from_string()"},{"location":"reference/segments/#versions.segments.Tag.to_string","text":"Converts a Tag to its string representation. Returns: Type Description str The tag string. Source code in versions/segments.py 647 648 649 650 651 652 653 def to_string ( self ) -> str : \"\"\"Converts a [`Tag`][versions.segments.Tag] to its string representation. Returns: The tag string. \"\"\" return concat_dot_args ( self . phase , str ( self . value ))","title":"to_string()"},{"location":"reference/segments/#versions.segments.Tag.to_short_string","text":"Converts a Tag to its short string representation. Returns: Type Description str The short tag string. Source code in versions/segments.py 655 656 657 658 659 660 661 def to_short_string ( self ) -> str : \"\"\"Converts a [`Tag`][versions.segments.Tag] to its *short* string representation. Returns: The *short* tag string. \"\"\" return concat_empty_args ( self . short , str ( self . value ))","title":"to_short_string()"},{"location":"reference/segments/#versions.segments.PreTag","text":"Bases: Tag Represents the pre-release tag of the version ( pre.n ). Source code in versions/segments.py 664 665 666 667 668 669 @frozen ( repr = False , eq = True , order = True ) class PreTag ( Tag ): \"\"\"Represents the *pre-release* tag of the version (`pre.n`).\"\"\" DEFAULT_PHASE = PHASE_PRE_DEFAULT PHASE_SET = PHASE_PRE_SET","title":"PreTag"},{"location":"reference/segments/#versions.segments.PostTag","text":"Bases: Tag Represents the post-release tag of the version ( post.n ). Source code in versions/segments.py 672 673 674 675 676 677 @frozen ( repr = False , eq = True , order = True ) class PostTag ( Tag ): \"\"\"Represents the *post-release* tag of the version (`post.n`).\"\"\" DEFAULT_PHASE = PHASE_POST_DEFAULT PHASE_SET = PHASE_POST_SET","title":"PostTag"},{"location":"reference/segments/#versions.segments.DevTag","text":"Bases: Tag Represents the dev-release tag of the version ( dev.n ). Source code in versions/segments.py 680 681 682 683 684 685 @frozen ( repr = False , eq = True , order = True ) class DevTag ( Tag ): \"\"\"Represents the *dev-release* tag of the version (`dev.n`).\"\"\" DEFAULT_PHASE = PHASE_DEV_DEFAULT PHASE_SET = PHASE_DEV_SET","title":"DevTag"},{"location":"reference/segments/#versions.segments.Local","text":"Bases: Representation , FromString , ToString Represents the local segment of the version ( +abcdefg.n ) Source code in versions/segments.py 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 @frozen ( repr = False , eq = True , order = True ) class Local ( Representation , FromString , ToString ): \"\"\"Represents the *local* segment of the version (`+abcdefg.n`)\"\"\" parts : LocalParts = field ( eq = False , order = False ) \"\"\"The local segment parts.\"\"\" compare_parts : CompareLocalParts = field ( repr = False , init = False , eq = True , order = True ) @parts . validator def check_parts ( self , attribute : Attribute [ LocalParts ], value : LocalParts ) -> None : if not value : raise ValueError ( EMPTY_LOCAL ) def __attrs_post_init__ ( self ) -> None : evolve_in_place ( self , compare_parts = self . compute_compare_parts ()) def compute_compare_parts ( self ) -> CompareLocalParts : empty = EMPTY return tuple ( ( part , empty ) if is_int ( part ) else ( negative_infinity , part ) # type: ignore for part in self . parts ) @classmethod def create ( cls : Type [ L ], parts : LocalParts ) -> L : \"\"\"Creates a [`Local`][versions.segments.Local] segment from local `parts`. Arguments: parts: The local parts. Returns: The newly created [`Local`][versions.segments.Local] segment. \"\"\" return cls ( parts ) @classmethod def from_iterable ( cls : Type [ L ], iterable : Iterable [ LocalPart ]) -> L : \"\"\"Creates a [`Local`][versions.segments.Local] segment from `iterable`. Arguments: iterable: The local parts in an iterable. Returns: The newly created [`Local`][versions.segments.Local] segment. \"\"\" return cls ( tuple ( iterable )) @classmethod def from_parts ( cls : Type [ L ], * parts : LocalPart ) -> L : \"\"\"Creates a [`Local`][versions.segments.Local] segment from local `parts`. Arguments: *parts: The local parts. Returns: The newly created [`Local`][versions.segments.Local] segment. \"\"\" return cls ( parts ) def into_parts ( self ) -> LocalParts : \"\"\"Converts a [`Local`][versions.segments.Local] segment to its parts. Returns: The parts of the local segment. \"\"\" return self . parts @classmethod def from_string ( cls : Type [ L ], string : str ) -> L : \"\"\"Parses a [`Local`][versions.segments.Local] segment from `string`. Arguments: string: The string to parse. Returns: The parsed local segment. \"\"\" return cls . from_iterable ( map ( local_part , split_separators ( string ))) def to_string ( self ) -> str : \"\"\"Converts a [`Local`][versions.segments.Local] segment to its string representation. Returns: The local segment string. \"\"\" return concat_dot ( map ( str , self . parts ))","title":"Local"},{"location":"reference/segments/#versions.segments.Local.parts","text":"The local segment parts.","title":"parts"},{"location":"reference/segments/#versions.segments.Local.create","text":"Creates a Local segment from local parts . Parameters: Name Type Description Default parts LocalParts The local parts. required Returns: Type Description L The newly created Local segment. Source code in versions/segments.py 731 732 733 734 735 736 737 738 739 740 741 @classmethod def create ( cls : Type [ L ], parts : LocalParts ) -> L : \"\"\"Creates a [`Local`][versions.segments.Local] segment from local `parts`. Arguments: parts: The local parts. Returns: The newly created [`Local`][versions.segments.Local] segment. \"\"\" return cls ( parts )","title":"create()"},{"location":"reference/segments/#versions.segments.Local.from_iterable","text":"Creates a Local segment from iterable . Parameters: Name Type Description Default iterable Iterable [ LocalPart ] The local parts in an iterable. required Returns: Type Description L The newly created Local segment. Source code in versions/segments.py 743 744 745 746 747 748 749 750 751 752 753 @classmethod def from_iterable ( cls : Type [ L ], iterable : Iterable [ LocalPart ]) -> L : \"\"\"Creates a [`Local`][versions.segments.Local] segment from `iterable`. Arguments: iterable: The local parts in an iterable. Returns: The newly created [`Local`][versions.segments.Local] segment. \"\"\" return cls ( tuple ( iterable ))","title":"from_iterable()"},{"location":"reference/segments/#versions.segments.Local.from_parts","text":"Creates a Local segment from local parts . Parameters: Name Type Description Default *parts LocalPart The local parts. () Returns: Type Description L The newly created Local segment. Source code in versions/segments.py 755 756 757 758 759 760 761 762 763 764 765 @classmethod def from_parts ( cls : Type [ L ], * parts : LocalPart ) -> L : \"\"\"Creates a [`Local`][versions.segments.Local] segment from local `parts`. Arguments: *parts: The local parts. Returns: The newly created [`Local`][versions.segments.Local] segment. \"\"\" return cls ( parts )","title":"from_parts()"},{"location":"reference/segments/#versions.segments.Local.into_parts","text":"Converts a Local segment to its parts. Returns: Type Description LocalParts The parts of the local segment. Source code in versions/segments.py 767 768 769 770 771 772 773 def into_parts ( self ) -> LocalParts : \"\"\"Converts a [`Local`][versions.segments.Local] segment to its parts. Returns: The parts of the local segment. \"\"\" return self . parts","title":"into_parts()"},{"location":"reference/segments/#versions.segments.Local.from_string","text":"Parses a Local segment from string . Parameters: Name Type Description Default string str The string to parse. required Returns: Type Description L The parsed local segment. Source code in versions/segments.py 775 776 777 778 779 780 781 782 783 784 785 @classmethod def from_string ( cls : Type [ L ], string : str ) -> L : \"\"\"Parses a [`Local`][versions.segments.Local] segment from `string`. Arguments: string: The string to parse. Returns: The parsed local segment. \"\"\" return cls . from_iterable ( map ( local_part , split_separators ( string )))","title":"from_string()"},{"location":"reference/segments/#versions.segments.Local.to_string","text":"Converts a Local segment to its string representation. Returns: Type Description str The local segment string. Source code in versions/segments.py 787 788 789 790 791 792 793 def to_string ( self ) -> str : \"\"\"Converts a [`Local`][versions.segments.Local] segment to its string representation. Returns: The local segment string. \"\"\" return concat_dot ( map ( str , self . parts ))","title":"to_string()"},{"location":"reference/specification/","text":"Specification Bases: Protocol The specification protocol for defining version requirements. Source code in versions/specification.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @runtime_checkable class Specification ( Protocol ): \"\"\"The specification protocol for defining version requirements.\"\"\" @abstractmethod def accepts ( self , version : Version ) -> bool : \"\"\"Checks if the `version` matches the specification. Arguments: version: The version to check. Returns: Whether the `version` matches the specification. \"\"\" raise NotImplementedError accepts ( version : Version ) -> bool abstractmethod Checks if the version matches the specification. Parameters: Name Type Description Default version Version The version to check. required Returns: Type Description bool Whether the version matches the specification. Source code in versions/specification.py 18 19 20 21 22 23 24 25 26 27 28 @abstractmethod def accepts ( self , version : Version ) -> bool : \"\"\"Checks if the `version` matches the specification. Arguments: version: The version to check. Returns: Whether the `version` matches the specification. \"\"\" raise NotImplementedError","title":"Specification"},{"location":"reference/specification/#versions.specification.Specification","text":"Bases: Protocol The specification protocol for defining version requirements. Source code in versions/specification.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @runtime_checkable class Specification ( Protocol ): \"\"\"The specification protocol for defining version requirements.\"\"\" @abstractmethod def accepts ( self , version : Version ) -> bool : \"\"\"Checks if the `version` matches the specification. Arguments: version: The version to check. Returns: Whether the `version` matches the specification. \"\"\" raise NotImplementedError","title":"Specification"},{"location":"reference/specification/#versions.specification.Specification.accepts","text":"Checks if the version matches the specification. Parameters: Name Type Description Default version Version The version to check. required Returns: Type Description bool Whether the version matches the specification. Source code in versions/specification.py 18 19 20 21 22 23 24 25 26 27 28 @abstractmethod def accepts ( self , version : Version ) -> bool : \"\"\"Checks if the `version` matches the specification. Arguments: version: The version to check. Returns: Whether the `version` matches the specification. \"\"\" raise NotImplementedError","title":"accepts()"},{"location":"reference/specifiers/","text":"Specifier Bases: Representation , ToString , Specification Represents all possible specifiers. Source code in versions/specifiers.py 43 44 class Specifier ( Representation , ToString , Specification ): \"\"\"Represents all possible specifiers.\"\"\" SpecifierFalse Bases: Specifier Represents specifiers that do not accept any versions. Source code in versions/specifiers.py 50 51 52 53 54 55 56 57 58 @frozen ( repr = False ) class SpecifierFalse ( Specifier ): \"\"\"Represents specifiers that do not accept any versions.\"\"\" def accepts ( self , version : Version ) -> Literal [ False ]: return False def to_string ( self ) -> str : return EMPTY_VERSION SpecifierTrue Bases: Specifier Represents specifiers that accept all versions. Source code in versions/specifiers.py 61 62 63 64 65 66 67 68 69 @frozen ( repr = False ) class SpecifierTrue ( Specifier ): \"\"\"Represents specifiers that accept all versions.\"\"\" def accepts ( self , version : Version ) -> Literal [ True ]: return True def to_string ( self ) -> str : return UNIVERSE_VERSION SpecifierSingle Bases: Operator , Specifier Represents specifiers that accept versions according to the Operator type. Source code in versions/specifiers.py 72 73 74 75 76 77 78 79 @frozen ( repr = False ) class SpecifierSingle ( Operator , Specifier ): \"\"\"Represents specifiers that accept versions according to the [`Operator`][versions.operators.Operator] type. \"\"\" def accepts ( self , version : Version ) -> bool : return self . partial_matches ( version ) SpecifierAny Bases: Specifier Represents collections of two or more specifiers that accept versions if any of the contained specifiers accept it. Source code in versions/specifiers.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 @frozen ( repr = False ) class SpecifierAny ( Specifier ): \"\"\"Represents collections of two or more specifiers that accept versions if *any* of the contained specifiers accept it. \"\"\" WRAP : ClassVar [ bool ] = False specifiers : Specifiers = field () @specifiers . validator def check_specifiers ( self , attribute : Attribute [ Specifiers ], specifiers : Specifiers ) -> None : check_specifiers ( specifiers ) @classmethod def of_specifiers ( cls , specifiers : Specifiers ) -> Specifier : if not specifiers : return SpecifierTrue () if contains_only_item ( specifiers ): return first ( specifiers ) return cls ( specifiers ) @classmethod def of ( cls , * specifiers : Specifier ) -> Specifier : return cls . of_specifiers ( specifiers ) @classmethod def of_iterable ( cls , iterable : Iterable [ Specifier ]) -> Specifier : return cls . of_specifiers ( tuple ( iterable )) def accepts ( self , version : Version ) -> bool : return any ( specifier . accepts ( version ) for specifier in self . specifiers ) def to_string ( self ) -> str : return create_wrap_around ( concat_pipes_spaced ( specifier . to_string () for specifier in self . specifiers ) ) def to_short_string ( self ) -> str : return create_wrap_around ( concat_pipes ( specifier . to_short_string () for specifier in self . specifiers ) ) SpecifierAll Bases: Specifier Represents collections of two or more specifiers that accept versions if and only if all of the contained specifiers accept it. Source code in versions/specifiers.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 @frozen ( repr = False ) class SpecifierAll ( Specifier ): \"\"\"Represents collections of two or more specifiers that accept versions if and only if *all* of the contained specifiers accept it. \"\"\" WRAP : ClassVar [ bool ] = False specifiers : Specifiers = field () @specifiers . validator def check_specifiers ( self , attribute : Attribute [ Specifiers ], specifiers : Specifiers ) -> None : check_specifiers ( specifiers ) @classmethod def of_specifiers ( cls , specifiers : Specifiers ) -> Specifier : if not specifiers : return SpecifierTrue () if contains_only_item ( specifiers ): return first ( specifiers ) return cls ( specifiers ) @classmethod def of ( cls , * specifiers : Specifier ) -> Specifier : return cls . of_specifiers ( specifiers ) @classmethod def of_iterable ( cls , iterable : Iterable [ Specifier ]) -> Specifier : return cls . of_specifiers ( tuple ( iterable )) def accepts ( self , version : Version ) -> bool : return all ( specifier . accepts ( version ) for specifier in self . specifiers ) def to_string ( self ) -> str : return create_wrap_around ( concat_comma_space ( specifier . to_string () for specifier in self . specifiers ) ) def to_short_string ( self ) -> str : return create_wrap_around ( concat_comma ( specifier . to_short_string () for specifier in self . specifiers ) ) is_specifier ( item : Any ) -> TypeGuard [ Specifier ] Checks if an item is an instance of Specifier . Parameters: Name Type Description Default item Any The item to check. required Returns: Type Description TypeGuard [ Specifier ] Whether the item provided is an instance of Specifier . Source code in versions/specifiers.py 186 187 188 189 190 191 192 193 194 195 def is_specifier ( item : Any ) -> TypeGuard [ Specifier ]: \"\"\"Checks if an `item` is an instance of [`Specifier`][versions.specifiers.Specifier]. Arguments: item: The item to check. Returns: Whether the `item` provided is an instance of [`Specifier`][versions.specifiers.Specifier]. \"\"\" return is_instance ( item , Specifier ) is_specifier_false ( item : Any ) -> TypeGuard [ SpecifierFalse ] Checks if an item is an instance of SpecifierFalse . Parameters: Name Type Description Default item Any The item to check. required Returns: Type Description TypeGuard [ SpecifierFalse ] Whether the item provided is an instance of SpecifierFalse . Source code in versions/specifiers.py 198 199 200 201 202 203 204 205 206 207 208 209 def is_specifier_false ( item : Any ) -> TypeGuard [ SpecifierFalse ]: \"\"\"Checks if an `item` is an instance of [`SpecifierFalse`][versions.specifiers.SpecifierFalse]. Arguments: item: The item to check. Returns: Whether the `item` provided is an instance of [`SpecifierFalse`][versions.specifiers.SpecifierFalse]. \"\"\" return is_instance ( item , SpecifierFalse ) is_specifier_true ( item : Any ) -> TypeGuard [ SpecifierTrue ] Checks if an item is an instance of SpecifierTrue . Parameters: Name Type Description Default item Any The item to check. required Returns: Type Description TypeGuard [ SpecifierTrue ] Whether the item provided is an instance of SpecifierTrue . Source code in versions/specifiers.py 212 213 214 215 216 217 218 219 220 221 222 223 def is_specifier_true ( item : Any ) -> TypeGuard [ SpecifierTrue ]: \"\"\"Checks if an `item` is an instance of [`SpecifierTrue`][versions.specifiers.SpecifierTrue]. Arguments: item: The item to check. Returns: Whether the `item` provided is an instance of [`SpecifierTrue`][versions.specifiers.SpecifierTrue]. \"\"\" return is_instance ( item , SpecifierTrue ) is_specifier_single ( item : Any ) -> TypeGuard [ SpecifierSingle ] Checks if an item is an instance of SpecifierSingle . Parameters: Name Type Description Default item Any The item to check. required Returns: Type Description TypeGuard [ SpecifierSingle ] Whether the item provided is an instance of SpecifierSingle . Source code in versions/specifiers.py 226 227 228 229 230 231 232 233 234 235 236 237 def is_specifier_single ( item : Any ) -> TypeGuard [ SpecifierSingle ]: \"\"\"Checks if an `item` is an instance of [`SpecifierSingle`][versions.specifiers.SpecifierSingle]. Arguments: item: The item to check. Returns: Whether the `item` provided is an instance of [`SpecifierSingle`][versions.specifiers.SpecifierSingle]. \"\"\" return is_instance ( item , SpecifierSingle ) is_specifier_any ( item : Any ) -> TypeGuard [ SpecifierAny ] Checks if an item is an instance of SpecifierAny . Parameters: Name Type Description Default item Any The item to check. required Returns: Type Description TypeGuard [ SpecifierAny ] Whether the item provided is an instance of SpecifierAny . Source code in versions/specifiers.py 240 241 242 243 244 245 246 247 248 249 250 251 def is_specifier_any ( item : Any ) -> TypeGuard [ SpecifierAny ]: \"\"\"Checks if an `item` is an instance of [`SpecifierAny`][versions.specifiers.SpecifierAny]. Arguments: item: The item to check. Returns: Whether the `item` provided is an instance of [`SpecifierAny`][versions.specifiers.SpecifierAny]. \"\"\" return is_instance ( item , SpecifierAny ) is_specifier_all ( item : Any ) -> TypeGuard [ SpecifierAll ] Checks if an item is an instance of SpecifierAll . Parameters: Name Type Description Default item Any The item to check. required Returns: Type Description TypeGuard [ SpecifierAll ] Whether the item provided is an instance of SpecifierAll . Source code in versions/specifiers.py 254 255 256 257 258 259 260 261 262 263 264 265 def is_specifier_all ( item : Any ) -> TypeGuard [ SpecifierAll ]: \"\"\"Checks if an `item` is an instance of [`SpecifierAll`][versions.specifiers.SpecifierAll]. Arguments: item: The item to check. Returns: Whether the `item` provided is an instance of [`SpecifierAll`][versions.specifiers.SpecifierAll]. \"\"\" return is_instance ( item , SpecifierAll )","title":"Specifiers"},{"location":"reference/specifiers/#versions.specifiers.Specifier","text":"Bases: Representation , ToString , Specification Represents all possible specifiers. Source code in versions/specifiers.py 43 44 class Specifier ( Representation , ToString , Specification ): \"\"\"Represents all possible specifiers.\"\"\"","title":"Specifier"},{"location":"reference/specifiers/#versions.specifiers.SpecifierFalse","text":"Bases: Specifier Represents specifiers that do not accept any versions. Source code in versions/specifiers.py 50 51 52 53 54 55 56 57 58 @frozen ( repr = False ) class SpecifierFalse ( Specifier ): \"\"\"Represents specifiers that do not accept any versions.\"\"\" def accepts ( self , version : Version ) -> Literal [ False ]: return False def to_string ( self ) -> str : return EMPTY_VERSION","title":"SpecifierFalse"},{"location":"reference/specifiers/#versions.specifiers.SpecifierTrue","text":"Bases: Specifier Represents specifiers that accept all versions. Source code in versions/specifiers.py 61 62 63 64 65 66 67 68 69 @frozen ( repr = False ) class SpecifierTrue ( Specifier ): \"\"\"Represents specifiers that accept all versions.\"\"\" def accepts ( self , version : Version ) -> Literal [ True ]: return True def to_string ( self ) -> str : return UNIVERSE_VERSION","title":"SpecifierTrue"},{"location":"reference/specifiers/#versions.specifiers.SpecifierSingle","text":"Bases: Operator , Specifier Represents specifiers that accept versions according to the Operator type. Source code in versions/specifiers.py 72 73 74 75 76 77 78 79 @frozen ( repr = False ) class SpecifierSingle ( Operator , Specifier ): \"\"\"Represents specifiers that accept versions according to the [`Operator`][versions.operators.Operator] type. \"\"\" def accepts ( self , version : Version ) -> bool : return self . partial_matches ( version )","title":"SpecifierSingle"},{"location":"reference/specifiers/#versions.specifiers.SpecifierAny","text":"Bases: Specifier Represents collections of two or more specifiers that accept versions if any of the contained specifiers accept it. Source code in versions/specifiers.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 @frozen ( repr = False ) class SpecifierAny ( Specifier ): \"\"\"Represents collections of two or more specifiers that accept versions if *any* of the contained specifiers accept it. \"\"\" WRAP : ClassVar [ bool ] = False specifiers : Specifiers = field () @specifiers . validator def check_specifiers ( self , attribute : Attribute [ Specifiers ], specifiers : Specifiers ) -> None : check_specifiers ( specifiers ) @classmethod def of_specifiers ( cls , specifiers : Specifiers ) -> Specifier : if not specifiers : return SpecifierTrue () if contains_only_item ( specifiers ): return first ( specifiers ) return cls ( specifiers ) @classmethod def of ( cls , * specifiers : Specifier ) -> Specifier : return cls . of_specifiers ( specifiers ) @classmethod def of_iterable ( cls , iterable : Iterable [ Specifier ]) -> Specifier : return cls . of_specifiers ( tuple ( iterable )) def accepts ( self , version : Version ) -> bool : return any ( specifier . accepts ( version ) for specifier in self . specifiers ) def to_string ( self ) -> str : return create_wrap_around ( concat_pipes_spaced ( specifier . to_string () for specifier in self . specifiers ) ) def to_short_string ( self ) -> str : return create_wrap_around ( concat_pipes ( specifier . to_short_string () for specifier in self . specifiers ) )","title":"SpecifierAny"},{"location":"reference/specifiers/#versions.specifiers.SpecifierAll","text":"Bases: Specifier Represents collections of two or more specifiers that accept versions if and only if all of the contained specifiers accept it. Source code in versions/specifiers.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 @frozen ( repr = False ) class SpecifierAll ( Specifier ): \"\"\"Represents collections of two or more specifiers that accept versions if and only if *all* of the contained specifiers accept it. \"\"\" WRAP : ClassVar [ bool ] = False specifiers : Specifiers = field () @specifiers . validator def check_specifiers ( self , attribute : Attribute [ Specifiers ], specifiers : Specifiers ) -> None : check_specifiers ( specifiers ) @classmethod def of_specifiers ( cls , specifiers : Specifiers ) -> Specifier : if not specifiers : return SpecifierTrue () if contains_only_item ( specifiers ): return first ( specifiers ) return cls ( specifiers ) @classmethod def of ( cls , * specifiers : Specifier ) -> Specifier : return cls . of_specifiers ( specifiers ) @classmethod def of_iterable ( cls , iterable : Iterable [ Specifier ]) -> Specifier : return cls . of_specifiers ( tuple ( iterable )) def accepts ( self , version : Version ) -> bool : return all ( specifier . accepts ( version ) for specifier in self . specifiers ) def to_string ( self ) -> str : return create_wrap_around ( concat_comma_space ( specifier . to_string () for specifier in self . specifiers ) ) def to_short_string ( self ) -> str : return create_wrap_around ( concat_comma ( specifier . to_short_string () for specifier in self . specifiers ) )","title":"SpecifierAll"},{"location":"reference/specifiers/#versions.specifiers.is_specifier","text":"Checks if an item is an instance of Specifier . Parameters: Name Type Description Default item Any The item to check. required Returns: Type Description TypeGuard [ Specifier ] Whether the item provided is an instance of Specifier . Source code in versions/specifiers.py 186 187 188 189 190 191 192 193 194 195 def is_specifier ( item : Any ) -> TypeGuard [ Specifier ]: \"\"\"Checks if an `item` is an instance of [`Specifier`][versions.specifiers.Specifier]. Arguments: item: The item to check. Returns: Whether the `item` provided is an instance of [`Specifier`][versions.specifiers.Specifier]. \"\"\" return is_instance ( item , Specifier )","title":"is_specifier()"},{"location":"reference/specifiers/#versions.specifiers.is_specifier_false","text":"Checks if an item is an instance of SpecifierFalse . Parameters: Name Type Description Default item Any The item to check. required Returns: Type Description TypeGuard [ SpecifierFalse ] Whether the item provided is an instance of SpecifierFalse . Source code in versions/specifiers.py 198 199 200 201 202 203 204 205 206 207 208 209 def is_specifier_false ( item : Any ) -> TypeGuard [ SpecifierFalse ]: \"\"\"Checks if an `item` is an instance of [`SpecifierFalse`][versions.specifiers.SpecifierFalse]. Arguments: item: The item to check. Returns: Whether the `item` provided is an instance of [`SpecifierFalse`][versions.specifiers.SpecifierFalse]. \"\"\" return is_instance ( item , SpecifierFalse )","title":"is_specifier_false()"},{"location":"reference/specifiers/#versions.specifiers.is_specifier_true","text":"Checks if an item is an instance of SpecifierTrue . Parameters: Name Type Description Default item Any The item to check. required Returns: Type Description TypeGuard [ SpecifierTrue ] Whether the item provided is an instance of SpecifierTrue . Source code in versions/specifiers.py 212 213 214 215 216 217 218 219 220 221 222 223 def is_specifier_true ( item : Any ) -> TypeGuard [ SpecifierTrue ]: \"\"\"Checks if an `item` is an instance of [`SpecifierTrue`][versions.specifiers.SpecifierTrue]. Arguments: item: The item to check. Returns: Whether the `item` provided is an instance of [`SpecifierTrue`][versions.specifiers.SpecifierTrue]. \"\"\" return is_instance ( item , SpecifierTrue )","title":"is_specifier_true()"},{"location":"reference/specifiers/#versions.specifiers.is_specifier_single","text":"Checks if an item is an instance of SpecifierSingle . Parameters: Name Type Description Default item Any The item to check. required Returns: Type Description TypeGuard [ SpecifierSingle ] Whether the item provided is an instance of SpecifierSingle . Source code in versions/specifiers.py 226 227 228 229 230 231 232 233 234 235 236 237 def is_specifier_single ( item : Any ) -> TypeGuard [ SpecifierSingle ]: \"\"\"Checks if an `item` is an instance of [`SpecifierSingle`][versions.specifiers.SpecifierSingle]. Arguments: item: The item to check. Returns: Whether the `item` provided is an instance of [`SpecifierSingle`][versions.specifiers.SpecifierSingle]. \"\"\" return is_instance ( item , SpecifierSingle )","title":"is_specifier_single()"},{"location":"reference/specifiers/#versions.specifiers.is_specifier_any","text":"Checks if an item is an instance of SpecifierAny . Parameters: Name Type Description Default item Any The item to check. required Returns: Type Description TypeGuard [ SpecifierAny ] Whether the item provided is an instance of SpecifierAny . Source code in versions/specifiers.py 240 241 242 243 244 245 246 247 248 249 250 251 def is_specifier_any ( item : Any ) -> TypeGuard [ SpecifierAny ]: \"\"\"Checks if an `item` is an instance of [`SpecifierAny`][versions.specifiers.SpecifierAny]. Arguments: item: The item to check. Returns: Whether the `item` provided is an instance of [`SpecifierAny`][versions.specifiers.SpecifierAny]. \"\"\" return is_instance ( item , SpecifierAny )","title":"is_specifier_any()"},{"location":"reference/specifiers/#versions.specifiers.is_specifier_all","text":"Checks if an item is an instance of SpecifierAll . Parameters: Name Type Description Default item Any The item to check. required Returns: Type Description TypeGuard [ SpecifierAll ] Whether the item provided is an instance of SpecifierAll . Source code in versions/specifiers.py 254 255 256 257 258 259 260 261 262 263 264 265 def is_specifier_all ( item : Any ) -> TypeGuard [ SpecifierAll ]: \"\"\"Checks if an `item` is an instance of [`SpecifierAll`][versions.specifiers.SpecifierAll]. Arguments: item: The item to check. Returns: Whether the `item` provided is an instance of [`SpecifierAll`][versions.specifiers.SpecifierAll]. \"\"\" return is_instance ( item , SpecifierAll )","title":"is_specifier_all()"},{"location":"reference/types/","text":"infinity = Infinity () module-attribute The singleton instance of Infinity . negative_infinity = NegativeInfinity () module-attribute The singleton instance of NegativeInfinity . AnyInfinity = Union [ Infinity , NegativeInfinity ] module-attribute The union of Infinity and NegativeInfinity . Ordering Bases: Enum Represents ordering. Source code in versions/types.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 class Ordering ( Enum ): \"\"\"Represents ordering.\"\"\" LESS = - 1 \"\"\"The left item is *less* than the right item.\"\"\" EQUAL = 0 \"\"\"The left item is *equal* to the right item.\"\"\" GREATER = 1 \"\"\"The left item is *greater* than the right item.\"\"\" def is_less ( self ) -> bool : \"\"\"Checks if the ordering is [`LESS`][versions.types.Ordering.LESS]. Returns: Whether the ordering is [`LESS`][versions.types.Ordering.LESS]. \"\"\" return self is type ( self ) . LESS def is_equal ( self ) -> bool : \"\"\"Checks if the ordering is [`EQUAL`][versions.types.Ordering.EQUAL]. Returns: Whether the ordering is [`EQUAL`][versions.types.Ordering.EQUAL]. \"\"\" return self is type ( self ) . EQUAL def is_greater ( self ) -> bool : \"\"\"Checks if the ordering is [`GREATER`][versions.types.Ordering.GREATER]. Returns: Whether the ordering is [`GREATER`][versions.types.Ordering.GREATER]. \"\"\" return self is type ( self ) . GREATER def is_less_or_equal ( self ) -> bool : \"\"\"Checks if the ordering is [`LESS`][versions.types.Ordering.LESS] or [`EQUAL`][versions.types.Ordering.EQUAL]. This is equivalent to: ```python ordering.is_less() or ordering.is_equal() ``` Returns: Whether the ordering is [`LESS`][versions.types.Ordering.LESS] or [`EQUAL`][versions.types.Ordering.EQUAL]. \"\"\" return self . is_less () or self . is_equal () def is_not_equal ( self ) -> bool : \"\"\"Checks if the ordering is not [`EQUAL`][versions.types.Ordering.EQUAL]. This is equivalent to: ```python not ordering.is_equal() ``` Returns: Whether the ordering is not [`EQUAL`][versions.types.Ordering.EQUAL]. \"\"\" return not self . is_equal () def is_greater_or_equal ( self ) -> bool : \"\"\"Checks if the ordering is [`GREATER`][versions.types.Ordering.GREATER] or [`EQUAL`][versions.types.Ordering.EQUAL]. This is equivalent to: ```python ordering.is_greater() or ordering.is_equal() ``` Returns: Whether the ordering is [`GREATER`][versions.types.Ordering.GREATER] or [`EQUAL`][versions.types.Ordering.EQUAL]. \"\"\" return self . is_greater () or self . is_equal () LESS = - 1 class-attribute The left item is less than the right item. EQUAL = 0 class-attribute The left item is equal to the right item. GREATER = 1 class-attribute The left item is greater than the right item. is_less () -> bool Checks if the ordering is LESS . Returns: Type Description bool Whether the ordering is LESS . Source code in versions/types.py 43 44 45 46 47 48 49 def is_less ( self ) -> bool : \"\"\"Checks if the ordering is [`LESS`][versions.types.Ordering.LESS]. Returns: Whether the ordering is [`LESS`][versions.types.Ordering.LESS]. \"\"\" return self is type ( self ) . LESS is_equal () -> bool Checks if the ordering is EQUAL . Returns: Type Description bool Whether the ordering is EQUAL . Source code in versions/types.py 51 52 53 54 55 56 57 def is_equal ( self ) -> bool : \"\"\"Checks if the ordering is [`EQUAL`][versions.types.Ordering.EQUAL]. Returns: Whether the ordering is [`EQUAL`][versions.types.Ordering.EQUAL]. \"\"\" return self is type ( self ) . EQUAL is_greater () -> bool Checks if the ordering is GREATER . Returns: Type Description bool Whether the ordering is GREATER . Source code in versions/types.py 59 60 61 62 63 64 65 def is_greater ( self ) -> bool : \"\"\"Checks if the ordering is [`GREATER`][versions.types.Ordering.GREATER]. Returns: Whether the ordering is [`GREATER`][versions.types.Ordering.GREATER]. \"\"\" return self is type ( self ) . GREATER is_less_or_equal () -> bool Checks if the ordering is LESS or EQUAL . This is equivalent to: ordering . is_less () or ordering . is_equal () Returns: Type Description bool Whether the ordering is LESS or EQUAL . Source code in versions/types.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def is_less_or_equal ( self ) -> bool : \"\"\"Checks if the ordering is [`LESS`][versions.types.Ordering.LESS] or [`EQUAL`][versions.types.Ordering.EQUAL]. This is equivalent to: ```python ordering.is_less() or ordering.is_equal() ``` Returns: Whether the ordering is [`LESS`][versions.types.Ordering.LESS] or [`EQUAL`][versions.types.Ordering.EQUAL]. \"\"\" return self . is_less () or self . is_equal () is_not_equal () -> bool Checks if the ordering is not EQUAL . This is equivalent to: not ordering . is_equal () Returns: Type Description bool Whether the ordering is not EQUAL . Source code in versions/types.py 83 84 85 86 87 88 89 90 91 92 93 94 95 def is_not_equal ( self ) -> bool : \"\"\"Checks if the ordering is not [`EQUAL`][versions.types.Ordering.EQUAL]. This is equivalent to: ```python not ordering.is_equal() ``` Returns: Whether the ordering is not [`EQUAL`][versions.types.Ordering.EQUAL]. \"\"\" return not self . is_equal () is_greater_or_equal () -> bool Checks if the ordering is GREATER or EQUAL . This is equivalent to: ordering . is_greater () or ordering . is_equal () Returns: Type Description bool Whether the ordering is GREATER or EQUAL . Source code in versions/types.py 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def is_greater_or_equal ( self ) -> bool : \"\"\"Checks if the ordering is [`GREATER`][versions.types.Ordering.GREATER] or [`EQUAL`][versions.types.Ordering.EQUAL]. This is equivalent to: ```python ordering.is_greater() or ordering.is_equal() ``` Returns: Whether the ordering is [`GREATER`][versions.types.Ordering.GREATER] or [`EQUAL`][versions.types.Ordering.EQUAL]. \"\"\" return self . is_greater () or self . is_equal () Infinity Bases: Singleton Represents the positive infinity. Source code in versions/types.py 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 class Infinity ( Singleton ): \"\"\"Represents the positive infinity.\"\"\" def __repr__ ( self ) -> str : return INFINITY def __eq__ ( self , other : Any ) -> bool : return self is other def __ne__ ( self , other : Any ) -> bool : return self is not other def __lt__ ( self , other : Any ) -> bool : return False def __le__ ( self , other : Any ) -> bool : return self is other def __gt__ ( self , other : Any ) -> bool : return self is not other def __ge__ ( self , other : Any ) -> bool : return True def __neg__ ( self : Infinity ) -> NegativeInfinity : return negative_infinity NegativeInfinity Bases: Singleton Represents the negative infinity. Source code in versions/types.py 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 class NegativeInfinity ( Singleton ): \"\"\"Represents the negative infinity.\"\"\" def __repr__ ( self ) -> str : return NEGATIVE_INFINITY def __eq__ ( self , other : Any ) -> bool : return self is other def __ne__ ( self , other : Any ) -> bool : return self is not other def __lt__ ( self , other : Any ) -> bool : return self is not other def __le__ ( self , other : Any ) -> bool : return True def __gt__ ( self , other : Any ) -> bool : return False def __ge__ ( self , other : Any ) -> bool : return self is other def __neg__ ( self : NegativeInfinity ) -> Infinity : return infinity is_infinity ( item : Any ) -> TypeGuard [ Infinity ] Checks if an item is an instance of Infinity . Returns: Type Description TypeGuard [ Infinity ] Whether the item is an instance of Infinity . Source code in versions/types.py 178 179 180 181 182 183 184 def is_infinity ( item : Any ) -> TypeGuard [ Infinity ]: \"\"\"Checks if an `item` is an instance of [`Infinity`][versions.types.Infinity]. Returns: Whether the `item` is an instance of [`Infinity`][versions.types.Infinity]. \"\"\" return item is infinity is_negative_infinity ( item : Any ) -> TypeGuard [ NegativeInfinity ] Checks if an item is an instance of NegativeInfinity . Returns: Type Description TypeGuard [ NegativeInfinity ] Whether the item is an instance of NegativeInfinity . Source code in versions/types.py 219 220 221 222 223 224 225 def is_negative_infinity ( item : Any ) -> TypeGuard [ NegativeInfinity ]: \"\"\"Checks if an `item` is an instance of [`NegativeInfinity`][versions.types.NegativeInfinity]. Returns: Whether the `item` is an instance of [`NegativeInfinity`][versions.types.NegativeInfinity]. \"\"\" return item is negative_infinity is_any_infinity ( item : Any ) -> TypeGuard [ AnyInfinity ] Checks if an item is an instance of AnyInfinity . Returns: Type Description TypeGuard [ AnyInfinity ] Whether the item is an instance of AnyInfinity . Source code in versions/types.py 234 235 236 237 238 239 240 def is_any_infinity ( item : Any ) -> TypeGuard [ AnyInfinity ]: \"\"\"Checks if an `item` is an instance of [`AnyInfinity`][versions.types.AnyInfinity]. Returns: Whether the `item` is an instance of [`AnyInfinity`][versions.types.AnyInfinity]. \"\"\" return item is infinity or item is negative_infinity","title":"Types"},{"location":"reference/types/#versions.types.infinity","text":"The singleton instance of Infinity .","title":"infinity"},{"location":"reference/types/#versions.types.negative_infinity","text":"The singleton instance of NegativeInfinity .","title":"negative_infinity"},{"location":"reference/types/#versions.types.AnyInfinity","text":"The union of Infinity and NegativeInfinity .","title":"AnyInfinity"},{"location":"reference/types/#versions.types.Ordering","text":"Bases: Enum Represents ordering. Source code in versions/types.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 class Ordering ( Enum ): \"\"\"Represents ordering.\"\"\" LESS = - 1 \"\"\"The left item is *less* than the right item.\"\"\" EQUAL = 0 \"\"\"The left item is *equal* to the right item.\"\"\" GREATER = 1 \"\"\"The left item is *greater* than the right item.\"\"\" def is_less ( self ) -> bool : \"\"\"Checks if the ordering is [`LESS`][versions.types.Ordering.LESS]. Returns: Whether the ordering is [`LESS`][versions.types.Ordering.LESS]. \"\"\" return self is type ( self ) . LESS def is_equal ( self ) -> bool : \"\"\"Checks if the ordering is [`EQUAL`][versions.types.Ordering.EQUAL]. Returns: Whether the ordering is [`EQUAL`][versions.types.Ordering.EQUAL]. \"\"\" return self is type ( self ) . EQUAL def is_greater ( self ) -> bool : \"\"\"Checks if the ordering is [`GREATER`][versions.types.Ordering.GREATER]. Returns: Whether the ordering is [`GREATER`][versions.types.Ordering.GREATER]. \"\"\" return self is type ( self ) . GREATER def is_less_or_equal ( self ) -> bool : \"\"\"Checks if the ordering is [`LESS`][versions.types.Ordering.LESS] or [`EQUAL`][versions.types.Ordering.EQUAL]. This is equivalent to: ```python ordering.is_less() or ordering.is_equal() ``` Returns: Whether the ordering is [`LESS`][versions.types.Ordering.LESS] or [`EQUAL`][versions.types.Ordering.EQUAL]. \"\"\" return self . is_less () or self . is_equal () def is_not_equal ( self ) -> bool : \"\"\"Checks if the ordering is not [`EQUAL`][versions.types.Ordering.EQUAL]. This is equivalent to: ```python not ordering.is_equal() ``` Returns: Whether the ordering is not [`EQUAL`][versions.types.Ordering.EQUAL]. \"\"\" return not self . is_equal () def is_greater_or_equal ( self ) -> bool : \"\"\"Checks if the ordering is [`GREATER`][versions.types.Ordering.GREATER] or [`EQUAL`][versions.types.Ordering.EQUAL]. This is equivalent to: ```python ordering.is_greater() or ordering.is_equal() ``` Returns: Whether the ordering is [`GREATER`][versions.types.Ordering.GREATER] or [`EQUAL`][versions.types.Ordering.EQUAL]. \"\"\" return self . is_greater () or self . is_equal ()","title":"Ordering"},{"location":"reference/types/#versions.types.Ordering.LESS","text":"The left item is less than the right item.","title":"LESS"},{"location":"reference/types/#versions.types.Ordering.EQUAL","text":"The left item is equal to the right item.","title":"EQUAL"},{"location":"reference/types/#versions.types.Ordering.GREATER","text":"The left item is greater than the right item.","title":"GREATER"},{"location":"reference/types/#versions.types.Ordering.is_less","text":"Checks if the ordering is LESS . Returns: Type Description bool Whether the ordering is LESS . Source code in versions/types.py 43 44 45 46 47 48 49 def is_less ( self ) -> bool : \"\"\"Checks if the ordering is [`LESS`][versions.types.Ordering.LESS]. Returns: Whether the ordering is [`LESS`][versions.types.Ordering.LESS]. \"\"\" return self is type ( self ) . LESS","title":"is_less()"},{"location":"reference/types/#versions.types.Ordering.is_equal","text":"Checks if the ordering is EQUAL . Returns: Type Description bool Whether the ordering is EQUAL . Source code in versions/types.py 51 52 53 54 55 56 57 def is_equal ( self ) -> bool : \"\"\"Checks if the ordering is [`EQUAL`][versions.types.Ordering.EQUAL]. Returns: Whether the ordering is [`EQUAL`][versions.types.Ordering.EQUAL]. \"\"\" return self is type ( self ) . EQUAL","title":"is_equal()"},{"location":"reference/types/#versions.types.Ordering.is_greater","text":"Checks if the ordering is GREATER . Returns: Type Description bool Whether the ordering is GREATER . Source code in versions/types.py 59 60 61 62 63 64 65 def is_greater ( self ) -> bool : \"\"\"Checks if the ordering is [`GREATER`][versions.types.Ordering.GREATER]. Returns: Whether the ordering is [`GREATER`][versions.types.Ordering.GREATER]. \"\"\" return self is type ( self ) . GREATER","title":"is_greater()"},{"location":"reference/types/#versions.types.Ordering.is_less_or_equal","text":"Checks if the ordering is LESS or EQUAL . This is equivalent to: ordering . is_less () or ordering . is_equal () Returns: Type Description bool Whether the ordering is LESS or EQUAL . Source code in versions/types.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def is_less_or_equal ( self ) -> bool : \"\"\"Checks if the ordering is [`LESS`][versions.types.Ordering.LESS] or [`EQUAL`][versions.types.Ordering.EQUAL]. This is equivalent to: ```python ordering.is_less() or ordering.is_equal() ``` Returns: Whether the ordering is [`LESS`][versions.types.Ordering.LESS] or [`EQUAL`][versions.types.Ordering.EQUAL]. \"\"\" return self . is_less () or self . is_equal ()","title":"is_less_or_equal()"},{"location":"reference/types/#versions.types.Ordering.is_not_equal","text":"Checks if the ordering is not EQUAL . This is equivalent to: not ordering . is_equal () Returns: Type Description bool Whether the ordering is not EQUAL . Source code in versions/types.py 83 84 85 86 87 88 89 90 91 92 93 94 95 def is_not_equal ( self ) -> bool : \"\"\"Checks if the ordering is not [`EQUAL`][versions.types.Ordering.EQUAL]. This is equivalent to: ```python not ordering.is_equal() ``` Returns: Whether the ordering is not [`EQUAL`][versions.types.Ordering.EQUAL]. \"\"\" return not self . is_equal ()","title":"is_not_equal()"},{"location":"reference/types/#versions.types.Ordering.is_greater_or_equal","text":"Checks if the ordering is GREATER or EQUAL . This is equivalent to: ordering . is_greater () or ordering . is_equal () Returns: Type Description bool Whether the ordering is GREATER or EQUAL . Source code in versions/types.py 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def is_greater_or_equal ( self ) -> bool : \"\"\"Checks if the ordering is [`GREATER`][versions.types.Ordering.GREATER] or [`EQUAL`][versions.types.Ordering.EQUAL]. This is equivalent to: ```python ordering.is_greater() or ordering.is_equal() ``` Returns: Whether the ordering is [`GREATER`][versions.types.Ordering.GREATER] or [`EQUAL`][versions.types.Ordering.EQUAL]. \"\"\" return self . is_greater () or self . is_equal ()","title":"is_greater_or_equal()"},{"location":"reference/types/#versions.types.Infinity","text":"Bases: Singleton Represents the positive infinity. Source code in versions/types.py 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 class Infinity ( Singleton ): \"\"\"Represents the positive infinity.\"\"\" def __repr__ ( self ) -> str : return INFINITY def __eq__ ( self , other : Any ) -> bool : return self is other def __ne__ ( self , other : Any ) -> bool : return self is not other def __lt__ ( self , other : Any ) -> bool : return False def __le__ ( self , other : Any ) -> bool : return self is other def __gt__ ( self , other : Any ) -> bool : return self is not other def __ge__ ( self , other : Any ) -> bool : return True def __neg__ ( self : Infinity ) -> NegativeInfinity : return negative_infinity","title":"Infinity"},{"location":"reference/types/#versions.types.NegativeInfinity","text":"Bases: Singleton Represents the negative infinity. Source code in versions/types.py 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 class NegativeInfinity ( Singleton ): \"\"\"Represents the negative infinity.\"\"\" def __repr__ ( self ) -> str : return NEGATIVE_INFINITY def __eq__ ( self , other : Any ) -> bool : return self is other def __ne__ ( self , other : Any ) -> bool : return self is not other def __lt__ ( self , other : Any ) -> bool : return self is not other def __le__ ( self , other : Any ) -> bool : return True def __gt__ ( self , other : Any ) -> bool : return False def __ge__ ( self , other : Any ) -> bool : return self is other def __neg__ ( self : NegativeInfinity ) -> Infinity : return infinity","title":"NegativeInfinity"},{"location":"reference/types/#versions.types.is_infinity","text":"Checks if an item is an instance of Infinity . Returns: Type Description TypeGuard [ Infinity ] Whether the item is an instance of Infinity . Source code in versions/types.py 178 179 180 181 182 183 184 def is_infinity ( item : Any ) -> TypeGuard [ Infinity ]: \"\"\"Checks if an `item` is an instance of [`Infinity`][versions.types.Infinity]. Returns: Whether the `item` is an instance of [`Infinity`][versions.types.Infinity]. \"\"\" return item is infinity","title":"is_infinity()"},{"location":"reference/types/#versions.types.is_negative_infinity","text":"Checks if an item is an instance of NegativeInfinity . Returns: Type Description TypeGuard [ NegativeInfinity ] Whether the item is an instance of NegativeInfinity . Source code in versions/types.py 219 220 221 222 223 224 225 def is_negative_infinity ( item : Any ) -> TypeGuard [ NegativeInfinity ]: \"\"\"Checks if an `item` is an instance of [`NegativeInfinity`][versions.types.NegativeInfinity]. Returns: Whether the `item` is an instance of [`NegativeInfinity`][versions.types.NegativeInfinity]. \"\"\" return item is negative_infinity","title":"is_negative_infinity()"},{"location":"reference/types/#versions.types.is_any_infinity","text":"Checks if an item is an instance of AnyInfinity . Returns: Type Description TypeGuard [ AnyInfinity ] Whether the item is an instance of AnyInfinity . Source code in versions/types.py 234 235 236 237 238 239 240 def is_any_infinity ( item : Any ) -> TypeGuard [ AnyInfinity ]: \"\"\"Checks if an `item` is an instance of [`AnyInfinity`][versions.types.AnyInfinity]. Returns: Whether the `item` is an instance of [`AnyInfinity`][versions.types.AnyInfinity]. \"\"\" return item is infinity or item is negative_infinity","title":"is_any_infinity()"},{"location":"reference/version/","text":"Version Bases: Representation , FromString , ToString Represents versions. Source code in versions/version.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 @frozen ( repr = False , eq = True , order = True ) class Version ( Representation , FromString , ToString ): \"\"\"Represents versions.\"\"\" epoch : Epoch = field ( factory = Epoch , eq = False , order = False ) \"\"\"The *epoch* segment of the version.\"\"\" release : Release = field ( factory = Release , eq = False , order = False ) \"\"\"The *release* segment of the version.\"\"\" pre : Optional [ PreTag ] = field ( default = None , eq = False , order = False ) \"\"\"The *pre-release* tag of the version.\"\"\" post : Optional [ PostTag ] = field ( default = None , eq = False , order = False ) \"\"\"The *post-release* tag of the version.\"\"\" dev : Optional [ DevTag ] = field ( default = None , eq = False , order = False ) \"\"\"The *dev-release* tag of the version.\"\"\" local : Optional [ Local ] = field ( default = None , eq = False , order = False ) \"\"\"The *local* segment of the version.\"\"\" compare_key : CompareKey = field ( repr = False , init = False , eq = True , order = True ) def __attrs_post_init__ ( self ) -> None : evolve_in_place ( self , compare_key = self . compute_compare_key ()) @staticmethod def compute_compare_tags ( pre : Optional [ PreTag ], post : Optional [ PostTag ], dev : Optional [ DevTag ] ) -> Tuple [ ComparePreTag , ComparePostTag , CompareDevTag ]: compare_pre : ComparePreTag compare_post : ComparePostTag compare_dev : CompareDevTag if pre is None : if post is None and dev is not None : compare_pre = negative_infinity else : compare_pre = infinity else : compare_pre = pre compare_post = negative_infinity if post is None else post compare_dev = infinity if dev is None else dev return ( compare_pre , compare_post , compare_dev ) @staticmethod def compute_compare_local ( local : Optional [ Local ]) -> CompareLocal : return negative_infinity if local is None else local def compute_compare_key ( self ) -> CompareKey : compare_epoch = self . epoch compare_release = self . release compare_pre , compare_post , compare_dev = self . compute_compare_tags ( self . pre , self . post , self . dev ) compare_local = self . compute_compare_local ( self . local ) return ( compare_epoch , compare_release , compare_pre , compare_post , compare_dev , compare_local , ) @classmethod def from_string ( cls : Type [ V ], string : str ) -> V : \"\"\"Parses a [`Version`][versions.version.Version] from `string`. Arguments: string: The string to parse. Returns: The parsed version. \"\"\" return VersionParser ( cls ) . parse ( string ) def to_string_iterator ( self ) -> Iterator [ str ]: epoch = self . epoch if epoch : yield epoch . to_string () yield EXCLAMATION yield self . release . to_string () pre = self . pre if pre : yield DASH yield pre . to_string () post = self . post if post : yield DASH yield post . to_string () dev = self . dev if dev : yield DASH yield dev . to_string () local = self . local if local : yield PLUS yield local . to_string () def to_short_string_iterator ( self ) -> Iterator [ str ]: epoch = self . epoch if epoch : yield epoch . to_short_string () yield EXCLAMATION yield self . release . to_short_string () pre = self . pre if pre : yield pre . to_short_string () post = self . post if post : yield DOT yield post . to_short_string () dev = self . dev if dev : yield DOT yield dev . to_short_string () local = self . local if local : yield PLUS yield local . to_short_string () def to_string ( self ) -> str : \"\"\"Converts a [`Version`][versions.version.Version] to its string representation. Returns: The version string. \"\"\" return concat_empty ( self . to_string_iterator ()) def to_short_string ( self ) -> str : \"\"\"Converts a [`Version`][versions.version.Version] to its *short* string representation. Returns: The *short* version string. \"\"\" return concat_empty ( self . to_short_string_iterator ()) @property def precision ( self ) -> int : \"\"\"The precision of the [`Release`][versions.segments.Release].\"\"\" return self . release . precision @property def last_index ( self ) -> int : \"\"\"The last index of the [`Release`][versions.segments.Release].\"\"\" return self . release . last_index @property def major ( self ) -> int : \"\"\"The *major* part of the [`Release`][versions.segments.Release].\"\"\" return self . release . major @property def minor ( self ) -> int : \"\"\"The *minor* part of the [`Release`][versions.segments.Release].\"\"\" return self . release . minor @property def micro ( self ) -> int : \"\"\"The *micro* part of the [`Release`][versions.segments.Release].\"\"\" return self . release . micro @property def patch ( self ) -> int : \"\"\"The *patch* part of the [`Release`][versions.segments.Release]. This is equivalent to [`micro`][versions.version.Version.micro]. \"\"\" return self . release . patch @property def extra ( self ) -> Extra : \"\"\"The *extra* parts of the [`Release`][versions.segments.Release].\"\"\" return self . release . extra def get_at ( self , index : int , default : int = DEFAULT_VALUE ) -> int : \"\"\"Gets the [`Release`][versions.segments.Release] part at the `index`, defaulting to `default`. Arguments: index: The index of the part to get. default: The default value to use. Returns: The release part at `index` or the `default` value. \"\"\" return self . release . get_at ( index , default ) def get_at_unchecked ( self , index : int ) -> int : \"\"\"Gets the [`Release`][versions.segments.Release] part at the `index`. Arguments: index: The index of the part to get. Raises: IndexError: The index is *out-of-bounds*. Returns: The release part at the `index`. \"\"\" return self . release . get_at_unchecked ( index ) def is_semantic ( self ) -> bool : \"\"\"Checks if the [`Release`][versions.segments.Release] matches the *semantic versioning* schema. Returns: Whether the release matches the [`semver`](https://semver.org/) schema. \"\"\" return self . release . is_semantic () def to_semantic ( self : V ) -> V : \"\"\"Converts the [`Release`][versions.segments.Release] to match the [`semver`](https://semver.org/) schema. Returns: The converted version. \"\"\" return self . update ( release = self . release . to_semantic ()) def set_major ( self : V , value : int ) -> V : \"\"\"Sets the *major* part of the [`Release`][versions.segments.Release] to the `value`. Arguments: value: The value to set the *major* part to. Returns: The updated version. \"\"\" return self . update ( release = self . release . set_major ( value )) def set_minor ( self : V , value : int ) -> V : \"\"\"Sets the *minor* part of the [`Release`][versions.segments.Release] to the `value`. Arguments: value: The value to set the *minor* part to. Returns: The updated version. \"\"\" return self . update ( release = self . release . set_minor ( value )) def set_micro ( self : V , value : int ) -> V : \"\"\"Sets the *micro* part of the [`Release`][versions.segments.Release] to the `value`. Arguments: value: The value to set the *micro* part to. Returns: The updated version. \"\"\" return self . update ( release = self . release . set_micro ( value )) def set_patch ( self : V , value : int ) -> V : \"\"\"Sets the *patch* part of the [`Release`][versions.segments.Release] to the `value`. This is equivalent to [`set_micro`][versions.version.Version.set_micro]. Arguments: value: The value to set the *patch* part to. Returns: The updated version. \"\"\" return self . update ( release = self . release . set_patch ( value )) def set_at ( self : V , index : int , value : int ) -> V : \"\"\"Sets the [`Release`][versions.segments.Release] part at the `index` to the `value`. Arguments: index: The index to set the `value` at. value: The value to set the part to. Returns: The updated version. \"\"\" return self . update ( release = self . release . set_at ( index , value )) def set_at_unchecked ( self : V , index : int , value : int ) -> V : \"\"\"Sets the [`Release`][versions.segments.Release] part at the `index` to the `value`. Arguments: index: The index to set the `value` at. value: The value to set the part to. Raises: IndexError: The index is *out-of-bounds*. Returns: The updated version. \"\"\" return self . update ( release = self . release . set_at_unchecked ( index , value )) def next_major ( self : V ) -> V : \"\"\"Bumps the *major* part of the [`Release`][versions.segments.Release] if the version is stable, otherwise converts the version to be stable. Returns: The bumped version. \"\"\" release = self . release if self . is_stable (): release = release . next_major () return self . create ( self . epoch , release ) def next_minor ( self : V ) -> V : \"\"\"Bumps the *minor* part of the [`Release`][versions.segments.Release] if the version is stable, otherwise converts the version to be stable. Returns: The bumped version. \"\"\" release = self . release if self . is_stable (): release = release . next_minor () return self . create ( self . epoch , release ) def next_micro ( self : V ) -> V : \"\"\"Bumps the *micro* part of the [`Release`][versions.segments.Release] if the version is stable, otherwise converts the version to be stable. Returns: The bumped version. \"\"\" release = self . release if self . is_stable (): release = release . next_micro () return self . create ( self . epoch , release ) def next_patch ( self : V ) -> V : \"\"\"Bumps the *patch* part of the [`Release`][versions.segments.Release] if the version is stable, otherwise converts the version to be stable. This is equivalent to [`next_micro`][versions.version.Version.next_micro]. Returns: The bumped version. \"\"\" release = self . release if self . is_stable (): release = release . next_patch () return self . create ( self . epoch , release ) def next_at ( self : V , index : int ) -> V : \"\"\"Bumps the part of the [`Release`][versions.segments.Release] at the `index` if the version is stable, otherwise converts the version to be stable. Arguments: index: The index to bump the part at. Returns: The bumped version. \"\"\" release = self . release if self . is_stable (): release = release . next_at ( index ) return self . create ( self . epoch , release ) def has_major ( self ) -> bool : \"\"\"Checks if the [`Release`][versions.segments.Release] has the *major* part. Returns: Whether the *major* part is present. \"\"\" return self . release . has_major () def has_minor ( self ) -> bool : \"\"\"Checks if the [`Release`][versions.segments.Release] has the *minor* part. Returns: Whether the *minor* part is present. \"\"\" return self . release . has_minor () def has_micro ( self ) -> bool : \"\"\"Checks if the [`Release`][versions.segments.Release] has the *micro* part. Returns: Whether the *micro* part is present. \"\"\" return self . release . has_micro () def has_patch ( self ) -> bool : \"\"\"Checks if the [`Release`][versions.segments.Release] has the *patch* part. This is equivalent to [`has_micro`][versions.version.Version.has_micro]. Returns: Whether the *patch* part is present. \"\"\" return self . release . has_patch () def has_extra ( self ) -> bool : \"\"\"Checks if the [`Release`][versions.segments.Release] has any *extra* parts. Returns: Whether the *extra* parts are present. \"\"\" return self . release . has_extra () def has_at ( self , index : int ) -> bool : \"\"\"Checks if the [`Release`][versions.segments.Release] has a part at the `index`. Returns: Whether the part at the `index` is present. \"\"\" return self . release . has_at ( index ) def pad_to ( self : V , length : int , padding : int = DEFAULT_PADDING ) -> V : \"\"\"Pads the [`Release`][versions.segments.Release] to the `length` with `padding`. Arguments: length: The length to pad the release to. padding: The padding to use. Returns: The padded version. \"\"\" return evolve ( self , release = self . release . pad_to ( length , padding )) def pad_to_index ( self : V , index : int , padding : int = DEFAULT_PADDING ) -> V : \"\"\"Pads the [`Release`][versions.segments.Release] to the `index` with `padding`. Arguments: index: The index to pad the release to. padding: The padding to use. Returns: The padded version. \"\"\" return evolve ( self , release = self . release . pad_to_index ( index , padding )) def pad_to_next ( self : V , padding : int = DEFAULT_PADDING ) -> V : \"\"\"Pads the [`Release`][versions.segments.Release] to the next index. Arguments: padding: The padding to use. Returns: The padded version. \"\"\" return evolve ( self , release = self . release . pad_to_next ( padding )) def is_pre_release ( self ) -> bool : \"\"\"Checks if the version is *pre-release*. Returns: Whether the version is *pre-release*. \"\"\" return self . pre is not None def is_post_release ( self ) -> bool : \"\"\"Checks if the version is *post-release*. Returns: Whether the version is *post-release*. \"\"\" return self . post is not None def is_dev_release ( self ) -> bool : \"\"\"Checks if the version is *dev-release*. Returns: Whether the version is *dev-release*. \"\"\" return self . dev is not None def is_local ( self ) -> bool : \"\"\"Checks if the version is *local*. Returns: Whether the version is *local*. \"\"\" return self . local is not None def is_unstable ( self ) -> bool : \"\"\"Checks if the version is *unstable*. Returns: Whether the version is *unstable*. \"\"\" return self . is_pre_release () or self . is_dev_release () def is_stable ( self ) -> bool : \"\"\"Checks if the version is *stable*. Returns: Whether the version is *stable*. \"\"\" return not self . is_unstable () def next_pre ( self : V ) -> V : \"\"\"Bumps the [`PreTag`][versions.segments.PreTag] if it is present, otherwise adds one to the version. Returns: The bumped version. \"\"\" pre = self . pre if pre is None : pre = PreTag () else : pre = pre . next () return self . create ( self . epoch , self . release , pre ) def next_pre_phase ( self : V ) -> Optional [ V ]: \"\"\"Bumps the [`PreTag`][versions.segments.PreTag] phase if it is present (and if possible), otherwise adds one to the version. Returns: The bumped version (if the next [`PreTag`][versions.segments.PreTag] is present). \"\"\" pre = self . pre if pre is None : pre = PreTag () else : pre = pre . next_phase () if pre is None : return None return self . create ( self . epoch , self . release , pre ) def next_post ( self : V ) -> V : \"\"\"Bumps the [`PostTag`][versions.segments.PostTag] if it is present, otherwise adds one to the version. Returns: The bumped version. \"\"\" post = self . post if post is None : post = PostTag () else : post = post . next () return self . create ( self . epoch , self . release , self . pre , post , self . dev ) def next_dev ( self : V ) -> V : \"\"\"Bumps the [`DevTag`][versions.segments.DevTag] if it is present, otherwise adds one to the version. Returns: The bumped version. \"\"\" dev = self . dev if dev is None : dev = DevTag () else : dev = dev . next () return self . create ( self . epoch , self . release , self . pre , self . post , dev ) def with_pre ( self : V , pre : PreTag ) -> V : \"\"\"Updates a version to include [`PreTag`][versions.segments.PreTag]. Arguments: pre: The *pre-release* tag to include. Returns: The updated version. \"\"\" return self . update ( pre = pre ) def with_post ( self : V , post : PostTag ) -> V : \"\"\"Updates a version to include [`PostTag`][versions.segments.PostTag]. Arguments: post: The *post-release* tag to include. Returns: The updated version. \"\"\" return self . update ( post = post ) def with_dev ( self : V , dev : DevTag ) -> V : \"\"\"Updates a version to include [`DevTag`][versions.segments.DevTag]. Arguments: dev: The *dev-release* tag to include. Returns: The updated version. \"\"\" return self . update ( dev = dev ) def with_local ( self : V , local : Local ) -> V : \"\"\"Updates a version to include [`Local`][versions.segments.Local]. Arguments: local: The *local* segment to include. Returns: The updated version. \"\"\" return self . update ( local = local ) def without_pre ( self : V ) -> V : \"\"\"Updates a version, removing any [`PreTag`][versions.segments.PreTag] from it. Returns: The updated version. \"\"\" return self . update ( pre = None ) def without_post ( self : V ) -> V : \"\"\"Updates a version, removing any [`PostTag`][versions.segments.PostTag] from it. Returns: The updated version. \"\"\" return self . update ( post = None ) def without_dev ( self : V ) -> V : \"\"\"Updates a version, removing any [`DevTag`][versions.segments.DevTag] from it. Returns: The updated version. \"\"\" return self . update ( dev = None ) def without_local ( self : V ) -> V : \"\"\"Updates a version, removing any [`Local`][versions.segments.Local] segment from it. Returns: The updated version. \"\"\" return self . update ( local = None ) def update ( self : V , ** changes : Any ) -> V : \"\"\"Updates a version with `changes`. Arguments: **changes: The changes to apply. Returns: The updated version. \"\"\" return evolve ( self , ** changes ) def weaken ( self , other : W ) -> W : \"\"\"Weakens the `other` version for further comparison. Arguments: other: The version to weaken. Returns: The weakened version. \"\"\" if not self . is_local () and other . is_local (): other = other . without_local () if not self . is_post_release () and other . is_post_release (): other = other . without_post () return other def to_stable ( self : V ) -> V : \"\"\"Forces a version to be stable. Returns: The stable version. \"\"\" return self if self . is_stable () else self . create ( self . epoch , self . release ) def next_breaking ( self : V ) -> V : \"\"\"Returns the next breaking version. This function is slightly convoluted due to how `0.x.y` versions are handled: | version | next breaking | |---------|---------------| | `1.2.3` | `2.0.0` | | `1.2.0` | `2.0.0` | | `1.0.0` | `2.0.0` | | `0.2.3` | `0.3.0` | | `0.0.3` | `0.0.4` | | `0.0.0` | `0.0.1` | | `0.0` | `0.1.0` | | `0` | `1.0.0` | Returns: The next breaking [`Version`][versions.version.Version]. \"\"\" if not self . major : if self . minor : return self . next_minor () if self . has_micro (): return self . next_micro () if self . has_minor (): return self . next_minor () return self . next_major () return self . to_stable () . next_major () def normalize ( self : V ) -> V : \"\"\"Normalizes all version tags. Returns: The normalized version. \"\"\" pre = self . pre if pre is not None : pre = pre . normalize () post = self . post if post is not None : post = post . normalize () dev = self . dev if dev is not None : dev = dev . normalize () return self . update ( pre = pre , post = post , dev = dev ) @classmethod def create ( cls : Type [ V ], epoch : Optional [ Epoch ] = None , release : Optional [ Release ] = None , pre : Optional [ PreTag ] = None , post : Optional [ PostTag ] = None , dev : Optional [ DevTag ] = None , local : Optional [ Local ] = None , ) -> V : \"\"\"Creates a [`Version`][versions.version.Version] from `epoch`, `release`, `pre`, `post`, `dev` and `local`. Arguments: epoch: The *epoch* to use. release: The *release* to use. pre: The *pre-release* tag to use. post: The *post-release* tag to use. dev: The *dev-release* tag to use. local: The *local* segment to use. Returns: The newly created [`Version`][versions.version.Version]. \"\"\" if epoch is None : epoch = Epoch () if release is None : release = Release () return cls ( epoch , release , pre , post , dev , local ) @classmethod def from_parts ( cls : Type [ V ], major : int = DEFAULT_VALUE , minor : int = DEFAULT_VALUE , micro : int = DEFAULT_VALUE , * extra : int , epoch : Optional [ Epoch ] = None , pre : Optional [ PreTag ] = None , post : Optional [ PostTag ] = None , dev : Optional [ DevTag ] = None , local : Optional [ Local ] = None , ) -> V : \"\"\"Creates a [`Version`][versions.version.Version] from `major`, `minor`, `micro` and `extra` parts; `epoch`, `pre`, `post`, `dev` and `local`. Arguments: major: The *major* part to use. minor: The *minor* part to use. micro: The *micro* part to use. *extra: The *extra* parts to use. epoch: The *epoch* to use. pre: The *pre-release* tag to use. post: The *post-release* tag to use. dev: The *dev-release* tag to use. local: The *local* segment to use. Returns: The newly created [`Version`][versions.version.Version]. \"\"\" release = Release . from_parts ( major , minor , micro , * extra ) return cls . create ( epoch , release , pre , post , dev , local ) def matches ( self , specification : Specification ) -> bool : \"\"\"Checks if a version matches the `specification`. Arguments: specification: The specification to check the version against. Returns: Whether the version matches the specification. \"\"\" return specification . accepts ( self ) epoch : Epoch = field ( factory = Epoch , eq = False , order = False ) class-attribute The epoch segment of the version. release : Release = field ( factory = Release , eq = False , order = False ) class-attribute The release segment of the version. pre : Optional [ PreTag ] = field ( default = None , eq = False , order = False ) class-attribute The pre-release tag of the version. post : Optional [ PostTag ] = field ( default = None , eq = False , order = False ) class-attribute The post-release tag of the version. dev : Optional [ DevTag ] = field ( default = None , eq = False , order = False ) class-attribute The dev-release tag of the version. local : Optional [ Local ] = field ( default = None , eq = False , order = False ) class-attribute The local segment of the version. from_string ( string : str ) -> V classmethod Parses a Version from string . Parameters: Name Type Description Default string str The string to parse. required Returns: Type Description V The parsed version. Source code in versions/version.py 119 120 121 122 123 124 125 126 127 128 129 @classmethod def from_string ( cls : Type [ V ], string : str ) -> V : \"\"\"Parses a [`Version`][versions.version.Version] from `string`. Arguments: string: The string to parse. Returns: The parsed version. \"\"\" return VersionParser ( cls ) . parse ( string ) to_string () -> str Converts a Version to its string representation. Returns: Type Description str The version string. Source code in versions/version.py 196 197 198 199 200 201 202 def to_string ( self ) -> str : \"\"\"Converts a [`Version`][versions.version.Version] to its string representation. Returns: The version string. \"\"\" return concat_empty ( self . to_string_iterator ()) to_short_string () -> str Converts a Version to its short string representation. Returns: Type Description str The short version string. Source code in versions/version.py 204 205 206 207 208 209 210 def to_short_string ( self ) -> str : \"\"\"Converts a [`Version`][versions.version.Version] to its *short* string representation. Returns: The *short* version string. \"\"\" return concat_empty ( self . to_short_string_iterator ()) precision () -> int property The precision of the Release . Source code in versions/version.py 212 213 214 215 @property def precision ( self ) -> int : \"\"\"The precision of the [`Release`][versions.segments.Release].\"\"\" return self . release . precision last_index () -> int property The last index of the Release . Source code in versions/version.py 217 218 219 220 @property def last_index ( self ) -> int : \"\"\"The last index of the [`Release`][versions.segments.Release].\"\"\" return self . release . last_index major () -> int property The major part of the Release . Source code in versions/version.py 222 223 224 225 @property def major ( self ) -> int : \"\"\"The *major* part of the [`Release`][versions.segments.Release].\"\"\" return self . release . major minor () -> int property The minor part of the Release . Source code in versions/version.py 227 228 229 230 @property def minor ( self ) -> int : \"\"\"The *minor* part of the [`Release`][versions.segments.Release].\"\"\" return self . release . minor micro () -> int property The micro part of the Release . Source code in versions/version.py 232 233 234 235 @property def micro ( self ) -> int : \"\"\"The *micro* part of the [`Release`][versions.segments.Release].\"\"\" return self . release . micro patch () -> int property The patch part of the Release . This is equivalent to micro . Source code in versions/version.py 237 238 239 240 241 242 243 @property def patch ( self ) -> int : \"\"\"The *patch* part of the [`Release`][versions.segments.Release]. This is equivalent to [`micro`][versions.version.Version.micro]. \"\"\" return self . release . patch extra () -> Extra property The extra parts of the Release . Source code in versions/version.py 245 246 247 248 @property def extra ( self ) -> Extra : \"\"\"The *extra* parts of the [`Release`][versions.segments.Release].\"\"\" return self . release . extra get_at ( index : int , default : int = DEFAULT_VALUE ) -> int Gets the Release part at the index , defaulting to default . Parameters: Name Type Description Default index int The index of the part to get. required default int The default value to use. DEFAULT_VALUE Returns: Type Description int The release part at index or the default value. Source code in versions/version.py 250 251 252 253 254 255 256 257 258 259 260 261 def get_at ( self , index : int , default : int = DEFAULT_VALUE ) -> int : \"\"\"Gets the [`Release`][versions.segments.Release] part at the `index`, defaulting to `default`. Arguments: index: The index of the part to get. default: The default value to use. Returns: The release part at `index` or the `default` value. \"\"\" return self . release . get_at ( index , default ) get_at_unchecked ( index : int ) -> int Gets the Release part at the index . Parameters: Name Type Description Default index int The index of the part to get. required Raises: Type Description IndexError The index is out-of-bounds . Returns: Type Description int The release part at the index . Source code in versions/version.py 263 264 265 266 267 268 269 270 271 272 273 274 275 def get_at_unchecked ( self , index : int ) -> int : \"\"\"Gets the [`Release`][versions.segments.Release] part at the `index`. Arguments: index: The index of the part to get. Raises: IndexError: The index is *out-of-bounds*. Returns: The release part at the `index`. \"\"\" return self . release . get_at_unchecked ( index ) is_semantic () -> bool Checks if the Release matches the semantic versioning schema. Returns: Type Description bool Whether the release matches the semver schema. Source code in versions/version.py 277 278 279 280 281 282 283 284 def is_semantic ( self ) -> bool : \"\"\"Checks if the [`Release`][versions.segments.Release] matches the *semantic versioning* schema. Returns: Whether the release matches the [`semver`](https://semver.org/) schema. \"\"\" return self . release . is_semantic () to_semantic () -> V Converts the Release to match the semver schema. Returns: Type Description V The converted version. Source code in versions/version.py 286 287 288 289 290 291 292 293 def to_semantic ( self : V ) -> V : \"\"\"Converts the [`Release`][versions.segments.Release] to match the [`semver`](https://semver.org/) schema. Returns: The converted version. \"\"\" return self . update ( release = self . release . to_semantic ()) set_major ( value : int ) -> V Sets the major part of the Release to the value . Parameters: Name Type Description Default value int The value to set the major part to. required Returns: Type Description V The updated version. Source code in versions/version.py 295 296 297 298 299 300 301 302 303 304 def set_major ( self : V , value : int ) -> V : \"\"\"Sets the *major* part of the [`Release`][versions.segments.Release] to the `value`. Arguments: value: The value to set the *major* part to. Returns: The updated version. \"\"\" return self . update ( release = self . release . set_major ( value )) set_minor ( value : int ) -> V Sets the minor part of the Release to the value . Parameters: Name Type Description Default value int The value to set the minor part to. required Returns: Type Description V The updated version. Source code in versions/version.py 306 307 308 309 310 311 312 313 314 315 def set_minor ( self : V , value : int ) -> V : \"\"\"Sets the *minor* part of the [`Release`][versions.segments.Release] to the `value`. Arguments: value: The value to set the *minor* part to. Returns: The updated version. \"\"\" return self . update ( release = self . release . set_minor ( value )) set_micro ( value : int ) -> V Sets the micro part of the Release to the value . Parameters: Name Type Description Default value int The value to set the micro part to. required Returns: Type Description V The updated version. Source code in versions/version.py 317 318 319 320 321 322 323 324 325 326 def set_micro ( self : V , value : int ) -> V : \"\"\"Sets the *micro* part of the [`Release`][versions.segments.Release] to the `value`. Arguments: value: The value to set the *micro* part to. Returns: The updated version. \"\"\" return self . update ( release = self . release . set_micro ( value )) set_patch ( value : int ) -> V Sets the patch part of the Release to the value . This is equivalent to set_micro . Parameters: Name Type Description Default value int The value to set the patch part to. required Returns: Type Description V The updated version. Source code in versions/version.py 328 329 330 331 332 333 334 335 336 337 338 339 def set_patch ( self : V , value : int ) -> V : \"\"\"Sets the *patch* part of the [`Release`][versions.segments.Release] to the `value`. This is equivalent to [`set_micro`][versions.version.Version.set_micro]. Arguments: value: The value to set the *patch* part to. Returns: The updated version. \"\"\" return self . update ( release = self . release . set_patch ( value )) set_at ( index : int , value : int ) -> V Sets the Release part at the index to the value . Parameters: Name Type Description Default index int The index to set the value at. required value int The value to set the part to. required Returns: Type Description V The updated version. Source code in versions/version.py 341 342 343 344 345 346 347 348 349 350 351 def set_at ( self : V , index : int , value : int ) -> V : \"\"\"Sets the [`Release`][versions.segments.Release] part at the `index` to the `value`. Arguments: index: The index to set the `value` at. value: The value to set the part to. Returns: The updated version. \"\"\" return self . update ( release = self . release . set_at ( index , value )) set_at_unchecked ( index : int , value : int ) -> V Sets the Release part at the index to the value . Parameters: Name Type Description Default index int The index to set the value at. required value int The value to set the part to. required Raises: Type Description IndexError The index is out-of-bounds . Returns: Type Description V The updated version. Source code in versions/version.py 353 354 355 356 357 358 359 360 361 362 363 364 365 366 def set_at_unchecked ( self : V , index : int , value : int ) -> V : \"\"\"Sets the [`Release`][versions.segments.Release] part at the `index` to the `value`. Arguments: index: The index to set the `value` at. value: The value to set the part to. Raises: IndexError: The index is *out-of-bounds*. Returns: The updated version. \"\"\" return self . update ( release = self . release . set_at_unchecked ( index , value )) next_major () -> V Bumps the major part of the Release if the version is stable, otherwise converts the version to be stable. Returns: Type Description V The bumped version. Source code in versions/version.py 368 369 370 371 372 373 374 375 376 377 378 379 380 def next_major ( self : V ) -> V : \"\"\"Bumps the *major* part of the [`Release`][versions.segments.Release] if the version is stable, otherwise converts the version to be stable. Returns: The bumped version. \"\"\" release = self . release if self . is_stable (): release = release . next_major () return self . create ( self . epoch , release ) next_minor () -> V Bumps the minor part of the Release if the version is stable, otherwise converts the version to be stable. Returns: Type Description V The bumped version. Source code in versions/version.py 382 383 384 385 386 387 388 389 390 391 392 393 394 def next_minor ( self : V ) -> V : \"\"\"Bumps the *minor* part of the [`Release`][versions.segments.Release] if the version is stable, otherwise converts the version to be stable. Returns: The bumped version. \"\"\" release = self . release if self . is_stable (): release = release . next_minor () return self . create ( self . epoch , release ) next_micro () -> V Bumps the micro part of the Release if the version is stable, otherwise converts the version to be stable. Returns: Type Description V The bumped version. Source code in versions/version.py 396 397 398 399 400 401 402 403 404 405 406 407 408 def next_micro ( self : V ) -> V : \"\"\"Bumps the *micro* part of the [`Release`][versions.segments.Release] if the version is stable, otherwise converts the version to be stable. Returns: The bumped version. \"\"\" release = self . release if self . is_stable (): release = release . next_micro () return self . create ( self . epoch , release ) next_patch () -> V Bumps the patch part of the Release if the version is stable, otherwise converts the version to be stable. This is equivalent to next_micro . Returns: Type Description V The bumped version. Source code in versions/version.py 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 def next_patch ( self : V ) -> V : \"\"\"Bumps the *patch* part of the [`Release`][versions.segments.Release] if the version is stable, otherwise converts the version to be stable. This is equivalent to [`next_micro`][versions.version.Version.next_micro]. Returns: The bumped version. \"\"\" release = self . release if self . is_stable (): release = release . next_patch () return self . create ( self . epoch , release ) next_at ( index : int ) -> V Bumps the part of the Release at the index if the version is stable, otherwise converts the version to be stable. Parameters: Name Type Description Default index int The index to bump the part at. required Returns: Type Description V The bumped version. Source code in versions/version.py 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 def next_at ( self : V , index : int ) -> V : \"\"\"Bumps the part of the [`Release`][versions.segments.Release] at the `index` if the version is stable, otherwise converts the version to be stable. Arguments: index: The index to bump the part at. Returns: The bumped version. \"\"\" release = self . release if self . is_stable (): release = release . next_at ( index ) return self . create ( self . epoch , release ) has_major () -> bool Checks if the Release has the major part. Returns: Type Description bool Whether the major part is present. Source code in versions/version.py 443 444 445 446 447 448 449 def has_major ( self ) -> bool : \"\"\"Checks if the [`Release`][versions.segments.Release] has the *major* part. Returns: Whether the *major* part is present. \"\"\" return self . release . has_major () has_minor () -> bool Checks if the Release has the minor part. Returns: Type Description bool Whether the minor part is present. Source code in versions/version.py 451 452 453 454 455 456 457 def has_minor ( self ) -> bool : \"\"\"Checks if the [`Release`][versions.segments.Release] has the *minor* part. Returns: Whether the *minor* part is present. \"\"\" return self . release . has_minor () has_micro () -> bool Checks if the Release has the micro part. Returns: Type Description bool Whether the micro part is present. Source code in versions/version.py 459 460 461 462 463 464 465 def has_micro ( self ) -> bool : \"\"\"Checks if the [`Release`][versions.segments.Release] has the *micro* part. Returns: Whether the *micro* part is present. \"\"\" return self . release . has_micro () has_patch () -> bool Checks if the Release has the patch part. This is equivalent to has_micro . Returns: Type Description bool Whether the patch part is present. Source code in versions/version.py 467 468 469 470 471 472 473 474 475 def has_patch ( self ) -> bool : \"\"\"Checks if the [`Release`][versions.segments.Release] has the *patch* part. This is equivalent to [`has_micro`][versions.version.Version.has_micro]. Returns: Whether the *patch* part is present. \"\"\" return self . release . has_patch () has_extra () -> bool Checks if the Release has any extra parts. Returns: Type Description bool Whether the extra parts are present. Source code in versions/version.py 477 478 479 480 481 482 483 def has_extra ( self ) -> bool : \"\"\"Checks if the [`Release`][versions.segments.Release] has any *extra* parts. Returns: Whether the *extra* parts are present. \"\"\" return self . release . has_extra () has_at ( index : int ) -> bool Checks if the Release has a part at the index . Returns: Type Description bool Whether the part at the index is present. Source code in versions/version.py 485 486 487 488 489 490 491 def has_at ( self , index : int ) -> bool : \"\"\"Checks if the [`Release`][versions.segments.Release] has a part at the `index`. Returns: Whether the part at the `index` is present. \"\"\" return self . release . has_at ( index ) pad_to ( length : int , padding : int = DEFAULT_PADDING ) -> V Pads the Release to the length with padding . Parameters: Name Type Description Default length int The length to pad the release to. required padding int The padding to use. DEFAULT_PADDING Returns: Type Description V The padded version. Source code in versions/version.py 493 494 495 496 497 498 499 500 501 502 503 def pad_to ( self : V , length : int , padding : int = DEFAULT_PADDING ) -> V : \"\"\"Pads the [`Release`][versions.segments.Release] to the `length` with `padding`. Arguments: length: The length to pad the release to. padding: The padding to use. Returns: The padded version. \"\"\" return evolve ( self , release = self . release . pad_to ( length , padding )) pad_to_index ( index : int , padding : int = DEFAULT_PADDING ) -> V Pads the Release to the index with padding . Parameters: Name Type Description Default index int The index to pad the release to. required padding int The padding to use. DEFAULT_PADDING Returns: Type Description V The padded version. Source code in versions/version.py 505 506 507 508 509 510 511 512 513 514 515 def pad_to_index ( self : V , index : int , padding : int = DEFAULT_PADDING ) -> V : \"\"\"Pads the [`Release`][versions.segments.Release] to the `index` with `padding`. Arguments: index: The index to pad the release to. padding: The padding to use. Returns: The padded version. \"\"\" return evolve ( self , release = self . release . pad_to_index ( index , padding )) pad_to_next ( padding : int = DEFAULT_PADDING ) -> V Pads the Release to the next index. Parameters: Name Type Description Default padding int The padding to use. DEFAULT_PADDING Returns: Type Description V The padded version. Source code in versions/version.py 517 518 519 520 521 522 523 524 525 526 def pad_to_next ( self : V , padding : int = DEFAULT_PADDING ) -> V : \"\"\"Pads the [`Release`][versions.segments.Release] to the next index. Arguments: padding: The padding to use. Returns: The padded version. \"\"\" return evolve ( self , release = self . release . pad_to_next ( padding )) is_pre_release () -> bool Checks if the version is pre-release . Returns: Type Description bool Whether the version is pre-release . Source code in versions/version.py 528 529 530 531 532 533 534 def is_pre_release ( self ) -> bool : \"\"\"Checks if the version is *pre-release*. Returns: Whether the version is *pre-release*. \"\"\" return self . pre is not None is_post_release () -> bool Checks if the version is post-release . Returns: Type Description bool Whether the version is post-release . Source code in versions/version.py 536 537 538 539 540 541 542 def is_post_release ( self ) -> bool : \"\"\"Checks if the version is *post-release*. Returns: Whether the version is *post-release*. \"\"\" return self . post is not None is_dev_release () -> bool Checks if the version is dev-release . Returns: Type Description bool Whether the version is dev-release . Source code in versions/version.py 544 545 546 547 548 549 550 def is_dev_release ( self ) -> bool : \"\"\"Checks if the version is *dev-release*. Returns: Whether the version is *dev-release*. \"\"\" return self . dev is not None is_local () -> bool Checks if the version is local . Returns: Type Description bool Whether the version is local . Source code in versions/version.py 552 553 554 555 556 557 558 def is_local ( self ) -> bool : \"\"\"Checks if the version is *local*. Returns: Whether the version is *local*. \"\"\" return self . local is not None is_unstable () -> bool Checks if the version is unstable . Returns: Type Description bool Whether the version is unstable . Source code in versions/version.py 560 561 562 563 564 565 566 def is_unstable ( self ) -> bool : \"\"\"Checks if the version is *unstable*. Returns: Whether the version is *unstable*. \"\"\" return self . is_pre_release () or self . is_dev_release () is_stable () -> bool Checks if the version is stable . Returns: Type Description bool Whether the version is stable . Source code in versions/version.py 568 569 570 571 572 573 574 def is_stable ( self ) -> bool : \"\"\"Checks if the version is *stable*. Returns: Whether the version is *stable*. \"\"\" return not self . is_unstable () next_pre () -> V Bumps the PreTag if it is present, otherwise adds one to the version. Returns: Type Description V The bumped version. Source code in versions/version.py 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 def next_pre ( self : V ) -> V : \"\"\"Bumps the [`PreTag`][versions.segments.PreTag] if it is present, otherwise adds one to the version. Returns: The bumped version. \"\"\" pre = self . pre if pre is None : pre = PreTag () else : pre = pre . next () return self . create ( self . epoch , self . release , pre ) next_pre_phase () -> Optional [ V ] Bumps the PreTag phase if it is present (and if possible), otherwise adds one to the version. Returns: Type Description Optional [ V ] The bumped version (if the next PreTag is present). Source code in versions/version.py 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 def next_pre_phase ( self : V ) -> Optional [ V ]: \"\"\"Bumps the [`PreTag`][versions.segments.PreTag] phase if it is present (and if possible), otherwise adds one to the version. Returns: The bumped version (if the next [`PreTag`][versions.segments.PreTag] is present). \"\"\" pre = self . pre if pre is None : pre = PreTag () else : pre = pre . next_phase () if pre is None : return None return self . create ( self . epoch , self . release , pre ) next_post () -> V Bumps the PostTag if it is present, otherwise adds one to the version. Returns: Type Description V The bumped version. Source code in versions/version.py 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 def next_post ( self : V ) -> V : \"\"\"Bumps the [`PostTag`][versions.segments.PostTag] if it is present, otherwise adds one to the version. Returns: The bumped version. \"\"\" post = self . post if post is None : post = PostTag () else : post = post . next () return self . create ( self . epoch , self . release , self . pre , post , self . dev ) next_dev () -> V Bumps the DevTag if it is present, otherwise adds one to the version. Returns: Type Description V The bumped version. Source code in versions/version.py 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 def next_dev ( self : V ) -> V : \"\"\"Bumps the [`DevTag`][versions.segments.DevTag] if it is present, otherwise adds one to the version. Returns: The bumped version. \"\"\" dev = self . dev if dev is None : dev = DevTag () else : dev = dev . next () return self . create ( self . epoch , self . release , self . pre , self . post , dev ) with_pre ( pre : PreTag ) -> V Updates a version to include PreTag . Parameters: Name Type Description Default pre PreTag The pre-release tag to include. required Returns: Type Description V The updated version. Source code in versions/version.py 647 648 649 650 651 652 653 654 655 656 def with_pre ( self : V , pre : PreTag ) -> V : \"\"\"Updates a version to include [`PreTag`][versions.segments.PreTag]. Arguments: pre: The *pre-release* tag to include. Returns: The updated version. \"\"\" return self . update ( pre = pre ) with_post ( post : PostTag ) -> V Updates a version to include PostTag . Parameters: Name Type Description Default post PostTag The post-release tag to include. required Returns: Type Description V The updated version. Source code in versions/version.py 658 659 660 661 662 663 664 665 666 667 def with_post ( self : V , post : PostTag ) -> V : \"\"\"Updates a version to include [`PostTag`][versions.segments.PostTag]. Arguments: post: The *post-release* tag to include. Returns: The updated version. \"\"\" return self . update ( post = post ) with_dev ( dev : DevTag ) -> V Updates a version to include DevTag . Parameters: Name Type Description Default dev DevTag The dev-release tag to include. required Returns: Type Description V The updated version. Source code in versions/version.py 669 670 671 672 673 674 675 676 677 678 def with_dev ( self : V , dev : DevTag ) -> V : \"\"\"Updates a version to include [`DevTag`][versions.segments.DevTag]. Arguments: dev: The *dev-release* tag to include. Returns: The updated version. \"\"\" return self . update ( dev = dev ) with_local ( local : Local ) -> V Updates a version to include Local . Parameters: Name Type Description Default local Local The local segment to include. required Returns: Type Description V The updated version. Source code in versions/version.py 680 681 682 683 684 685 686 687 688 689 def with_local ( self : V , local : Local ) -> V : \"\"\"Updates a version to include [`Local`][versions.segments.Local]. Arguments: local: The *local* segment to include. Returns: The updated version. \"\"\" return self . update ( local = local ) without_pre () -> V Updates a version, removing any PreTag from it. Returns: Type Description V The updated version. Source code in versions/version.py 691 692 693 694 695 696 697 def without_pre ( self : V ) -> V : \"\"\"Updates a version, removing any [`PreTag`][versions.segments.PreTag] from it. Returns: The updated version. \"\"\" return self . update ( pre = None ) without_post () -> V Updates a version, removing any PostTag from it. Returns: Type Description V The updated version. Source code in versions/version.py 699 700 701 702 703 704 705 def without_post ( self : V ) -> V : \"\"\"Updates a version, removing any [`PostTag`][versions.segments.PostTag] from it. Returns: The updated version. \"\"\" return self . update ( post = None ) without_dev () -> V Updates a version, removing any DevTag from it. Returns: Type Description V The updated version. Source code in versions/version.py 707 708 709 710 711 712 713 def without_dev ( self : V ) -> V : \"\"\"Updates a version, removing any [`DevTag`][versions.segments.DevTag] from it. Returns: The updated version. \"\"\" return self . update ( dev = None ) without_local () -> V Updates a version, removing any Local segment from it. Returns: Type Description V The updated version. Source code in versions/version.py 715 716 717 718 719 720 721 def without_local ( self : V ) -> V : \"\"\"Updates a version, removing any [`Local`][versions.segments.Local] segment from it. Returns: The updated version. \"\"\" return self . update ( local = None ) update ( ** changes : Any ) -> V Updates a version with changes . Parameters: Name Type Description Default **changes Any The changes to apply. {} Returns: Type Description V The updated version. Source code in versions/version.py 723 724 725 726 727 728 729 730 731 732 def update ( self : V , ** changes : Any ) -> V : \"\"\"Updates a version with `changes`. Arguments: **changes: The changes to apply. Returns: The updated version. \"\"\" return evolve ( self , ** changes ) weaken ( other : W ) -> W Weakens the other version for further comparison. Parameters: Name Type Description Default other W The version to weaken. required Returns: Type Description W The weakened version. Source code in versions/version.py 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 def weaken ( self , other : W ) -> W : \"\"\"Weakens the `other` version for further comparison. Arguments: other: The version to weaken. Returns: The weakened version. \"\"\" if not self . is_local () and other . is_local (): other = other . without_local () if not self . is_post_release () and other . is_post_release (): other = other . without_post () return other to_stable () -> V Forces a version to be stable. Returns: Type Description V The stable version. Source code in versions/version.py 751 752 753 754 755 756 757 def to_stable ( self : V ) -> V : \"\"\"Forces a version to be stable. Returns: The stable version. \"\"\" return self if self . is_stable () else self . create ( self . epoch , self . release ) next_breaking () -> V Returns the next breaking version. This function is slightly convoluted due to how 0.x.y versions are handled: version next breaking 1.2.3 2.0.0 1.2.0 2.0.0 1.0.0 2.0.0 0.2.3 0.3.0 0.0.3 0.0.4 0.0.0 0.0.1 0.0 0.1.0 0 1.0.0 Returns: Type Description V The next breaking Version . Source code in versions/version.py 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 def next_breaking ( self : V ) -> V : \"\"\"Returns the next breaking version. This function is slightly convoluted due to how `0.x.y` versions are handled: | version | next breaking | |---------|---------------| | `1.2.3` | `2.0.0` | | `1.2.0` | `2.0.0` | | `1.0.0` | `2.0.0` | | `0.2.3` | `0.3.0` | | `0.0.3` | `0.0.4` | | `0.0.0` | `0.0.1` | | `0.0` | `0.1.0` | | `0` | `1.0.0` | Returns: The next breaking [`Version`][versions.version.Version]. \"\"\" if not self . major : if self . minor : return self . next_minor () if self . has_micro (): return self . next_micro () if self . has_minor (): return self . next_minor () return self . next_major () return self . to_stable () . next_major () normalize () -> V Normalizes all version tags. Returns: Type Description V The normalized version. Source code in versions/version.py 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 def normalize ( self : V ) -> V : \"\"\"Normalizes all version tags. Returns: The normalized version. \"\"\" pre = self . pre if pre is not None : pre = pre . normalize () post = self . post if post is not None : post = post . normalize () dev = self . dev if dev is not None : dev = dev . normalize () return self . update ( pre = pre , post = post , dev = dev ) create ( epoch : Optional [ Epoch ] = None , release : Optional [ Release ] = None , pre : Optional [ PreTag ] = None , post : Optional [ PostTag ] = None , dev : Optional [ DevTag ] = None , local : Optional [ Local ] = None ) -> V classmethod Creates a Version from epoch , release , pre , post , dev and local . Parameters: Name Type Description Default epoch Optional [ Epoch ] The epoch to use. None release Optional [ Release ] The release to use. None pre Optional [ PreTag ] The pre-release tag to use. None post Optional [ PostTag ] The post-release tag to use. None dev Optional [ DevTag ] The dev-release tag to use. None local Optional [ Local ] The local segment to use. None Returns: Type Description V The newly created Version . Source code in versions/version.py 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 @classmethod def create ( cls : Type [ V ], epoch : Optional [ Epoch ] = None , release : Optional [ Release ] = None , pre : Optional [ PreTag ] = None , post : Optional [ PostTag ] = None , dev : Optional [ DevTag ] = None , local : Optional [ Local ] = None , ) -> V : \"\"\"Creates a [`Version`][versions.version.Version] from `epoch`, `release`, `pre`, `post`, `dev` and `local`. Arguments: epoch: The *epoch* to use. release: The *release* to use. pre: The *pre-release* tag to use. post: The *post-release* tag to use. dev: The *dev-release* tag to use. local: The *local* segment to use. Returns: The newly created [`Version`][versions.version.Version]. \"\"\" if epoch is None : epoch = Epoch () if release is None : release = Release () return cls ( epoch , release , pre , post , dev , local ) from_parts ( major : int = DEFAULT_VALUE , minor : int = DEFAULT_VALUE , micro : int = DEFAULT_VALUE , * extra : int , epoch : Optional [ Epoch ] = None , pre : Optional [ PreTag ] = None , post : Optional [ PostTag ] = None , dev : Optional [ DevTag ] = None , local : Optional [ Local ] = None ) -> V classmethod Creates a Version from major , minor , micro and extra parts; epoch , pre , post , dev and local . Parameters: Name Type Description Default major int The major part to use. DEFAULT_VALUE minor int The minor part to use. DEFAULT_VALUE micro int The micro part to use. DEFAULT_VALUE *extra int The extra parts to use. () epoch Optional [ Epoch ] The epoch to use. None pre Optional [ PreTag ] The pre-release tag to use. None post Optional [ PostTag ] The post-release tag to use. None dev Optional [ DevTag ] The dev-release tag to use. None local Optional [ Local ] The local segment to use. None Returns: Type Description V The newly created Version . Source code in versions/version.py 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 @classmethod def from_parts ( cls : Type [ V ], major : int = DEFAULT_VALUE , minor : int = DEFAULT_VALUE , micro : int = DEFAULT_VALUE , * extra : int , epoch : Optional [ Epoch ] = None , pre : Optional [ PreTag ] = None , post : Optional [ PostTag ] = None , dev : Optional [ DevTag ] = None , local : Optional [ Local ] = None , ) -> V : \"\"\"Creates a [`Version`][versions.version.Version] from `major`, `minor`, `micro` and `extra` parts; `epoch`, `pre`, `post`, `dev` and `local`. Arguments: major: The *major* part to use. minor: The *minor* part to use. micro: The *micro* part to use. *extra: The *extra* parts to use. epoch: The *epoch* to use. pre: The *pre-release* tag to use. post: The *post-release* tag to use. dev: The *dev-release* tag to use. local: The *local* segment to use. Returns: The newly created [`Version`][versions.version.Version]. \"\"\" release = Release . from_parts ( major , minor , micro , * extra ) return cls . create ( epoch , release , pre , post , dev , local ) matches ( specification : Specification ) -> bool Checks if a version matches the specification . Parameters: Name Type Description Default specification Specification The specification to check the version against. required Returns: Type Description bool Whether the version matches the specification. Source code in versions/version.py 881 882 883 884 885 886 887 888 889 890 def matches ( self , specification : Specification ) -> bool : \"\"\"Checks if a version matches the `specification`. Arguments: specification: The specification to check the version against. Returns: Whether the version matches the specification. \"\"\" return specification . accepts ( self )","title":"Version"},{"location":"reference/version/#versions.version.Version","text":"Bases: Representation , FromString , ToString Represents versions. Source code in versions/version.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 @frozen ( repr = False , eq = True , order = True ) class Version ( Representation , FromString , ToString ): \"\"\"Represents versions.\"\"\" epoch : Epoch = field ( factory = Epoch , eq = False , order = False ) \"\"\"The *epoch* segment of the version.\"\"\" release : Release = field ( factory = Release , eq = False , order = False ) \"\"\"The *release* segment of the version.\"\"\" pre : Optional [ PreTag ] = field ( default = None , eq = False , order = False ) \"\"\"The *pre-release* tag of the version.\"\"\" post : Optional [ PostTag ] = field ( default = None , eq = False , order = False ) \"\"\"The *post-release* tag of the version.\"\"\" dev : Optional [ DevTag ] = field ( default = None , eq = False , order = False ) \"\"\"The *dev-release* tag of the version.\"\"\" local : Optional [ Local ] = field ( default = None , eq = False , order = False ) \"\"\"The *local* segment of the version.\"\"\" compare_key : CompareKey = field ( repr = False , init = False , eq = True , order = True ) def __attrs_post_init__ ( self ) -> None : evolve_in_place ( self , compare_key = self . compute_compare_key ()) @staticmethod def compute_compare_tags ( pre : Optional [ PreTag ], post : Optional [ PostTag ], dev : Optional [ DevTag ] ) -> Tuple [ ComparePreTag , ComparePostTag , CompareDevTag ]: compare_pre : ComparePreTag compare_post : ComparePostTag compare_dev : CompareDevTag if pre is None : if post is None and dev is not None : compare_pre = negative_infinity else : compare_pre = infinity else : compare_pre = pre compare_post = negative_infinity if post is None else post compare_dev = infinity if dev is None else dev return ( compare_pre , compare_post , compare_dev ) @staticmethod def compute_compare_local ( local : Optional [ Local ]) -> CompareLocal : return negative_infinity if local is None else local def compute_compare_key ( self ) -> CompareKey : compare_epoch = self . epoch compare_release = self . release compare_pre , compare_post , compare_dev = self . compute_compare_tags ( self . pre , self . post , self . dev ) compare_local = self . compute_compare_local ( self . local ) return ( compare_epoch , compare_release , compare_pre , compare_post , compare_dev , compare_local , ) @classmethod def from_string ( cls : Type [ V ], string : str ) -> V : \"\"\"Parses a [`Version`][versions.version.Version] from `string`. Arguments: string: The string to parse. Returns: The parsed version. \"\"\" return VersionParser ( cls ) . parse ( string ) def to_string_iterator ( self ) -> Iterator [ str ]: epoch = self . epoch if epoch : yield epoch . to_string () yield EXCLAMATION yield self . release . to_string () pre = self . pre if pre : yield DASH yield pre . to_string () post = self . post if post : yield DASH yield post . to_string () dev = self . dev if dev : yield DASH yield dev . to_string () local = self . local if local : yield PLUS yield local . to_string () def to_short_string_iterator ( self ) -> Iterator [ str ]: epoch = self . epoch if epoch : yield epoch . to_short_string () yield EXCLAMATION yield self . release . to_short_string () pre = self . pre if pre : yield pre . to_short_string () post = self . post if post : yield DOT yield post . to_short_string () dev = self . dev if dev : yield DOT yield dev . to_short_string () local = self . local if local : yield PLUS yield local . to_short_string () def to_string ( self ) -> str : \"\"\"Converts a [`Version`][versions.version.Version] to its string representation. Returns: The version string. \"\"\" return concat_empty ( self . to_string_iterator ()) def to_short_string ( self ) -> str : \"\"\"Converts a [`Version`][versions.version.Version] to its *short* string representation. Returns: The *short* version string. \"\"\" return concat_empty ( self . to_short_string_iterator ()) @property def precision ( self ) -> int : \"\"\"The precision of the [`Release`][versions.segments.Release].\"\"\" return self . release . precision @property def last_index ( self ) -> int : \"\"\"The last index of the [`Release`][versions.segments.Release].\"\"\" return self . release . last_index @property def major ( self ) -> int : \"\"\"The *major* part of the [`Release`][versions.segments.Release].\"\"\" return self . release . major @property def minor ( self ) -> int : \"\"\"The *minor* part of the [`Release`][versions.segments.Release].\"\"\" return self . release . minor @property def micro ( self ) -> int : \"\"\"The *micro* part of the [`Release`][versions.segments.Release].\"\"\" return self . release . micro @property def patch ( self ) -> int : \"\"\"The *patch* part of the [`Release`][versions.segments.Release]. This is equivalent to [`micro`][versions.version.Version.micro]. \"\"\" return self . release . patch @property def extra ( self ) -> Extra : \"\"\"The *extra* parts of the [`Release`][versions.segments.Release].\"\"\" return self . release . extra def get_at ( self , index : int , default : int = DEFAULT_VALUE ) -> int : \"\"\"Gets the [`Release`][versions.segments.Release] part at the `index`, defaulting to `default`. Arguments: index: The index of the part to get. default: The default value to use. Returns: The release part at `index` or the `default` value. \"\"\" return self . release . get_at ( index , default ) def get_at_unchecked ( self , index : int ) -> int : \"\"\"Gets the [`Release`][versions.segments.Release] part at the `index`. Arguments: index: The index of the part to get. Raises: IndexError: The index is *out-of-bounds*. Returns: The release part at the `index`. \"\"\" return self . release . get_at_unchecked ( index ) def is_semantic ( self ) -> bool : \"\"\"Checks if the [`Release`][versions.segments.Release] matches the *semantic versioning* schema. Returns: Whether the release matches the [`semver`](https://semver.org/) schema. \"\"\" return self . release . is_semantic () def to_semantic ( self : V ) -> V : \"\"\"Converts the [`Release`][versions.segments.Release] to match the [`semver`](https://semver.org/) schema. Returns: The converted version. \"\"\" return self . update ( release = self . release . to_semantic ()) def set_major ( self : V , value : int ) -> V : \"\"\"Sets the *major* part of the [`Release`][versions.segments.Release] to the `value`. Arguments: value: The value to set the *major* part to. Returns: The updated version. \"\"\" return self . update ( release = self . release . set_major ( value )) def set_minor ( self : V , value : int ) -> V : \"\"\"Sets the *minor* part of the [`Release`][versions.segments.Release] to the `value`. Arguments: value: The value to set the *minor* part to. Returns: The updated version. \"\"\" return self . update ( release = self . release . set_minor ( value )) def set_micro ( self : V , value : int ) -> V : \"\"\"Sets the *micro* part of the [`Release`][versions.segments.Release] to the `value`. Arguments: value: The value to set the *micro* part to. Returns: The updated version. \"\"\" return self . update ( release = self . release . set_micro ( value )) def set_patch ( self : V , value : int ) -> V : \"\"\"Sets the *patch* part of the [`Release`][versions.segments.Release] to the `value`. This is equivalent to [`set_micro`][versions.version.Version.set_micro]. Arguments: value: The value to set the *patch* part to. Returns: The updated version. \"\"\" return self . update ( release = self . release . set_patch ( value )) def set_at ( self : V , index : int , value : int ) -> V : \"\"\"Sets the [`Release`][versions.segments.Release] part at the `index` to the `value`. Arguments: index: The index to set the `value` at. value: The value to set the part to. Returns: The updated version. \"\"\" return self . update ( release = self . release . set_at ( index , value )) def set_at_unchecked ( self : V , index : int , value : int ) -> V : \"\"\"Sets the [`Release`][versions.segments.Release] part at the `index` to the `value`. Arguments: index: The index to set the `value` at. value: The value to set the part to. Raises: IndexError: The index is *out-of-bounds*. Returns: The updated version. \"\"\" return self . update ( release = self . release . set_at_unchecked ( index , value )) def next_major ( self : V ) -> V : \"\"\"Bumps the *major* part of the [`Release`][versions.segments.Release] if the version is stable, otherwise converts the version to be stable. Returns: The bumped version. \"\"\" release = self . release if self . is_stable (): release = release . next_major () return self . create ( self . epoch , release ) def next_minor ( self : V ) -> V : \"\"\"Bumps the *minor* part of the [`Release`][versions.segments.Release] if the version is stable, otherwise converts the version to be stable. Returns: The bumped version. \"\"\" release = self . release if self . is_stable (): release = release . next_minor () return self . create ( self . epoch , release ) def next_micro ( self : V ) -> V : \"\"\"Bumps the *micro* part of the [`Release`][versions.segments.Release] if the version is stable, otherwise converts the version to be stable. Returns: The bumped version. \"\"\" release = self . release if self . is_stable (): release = release . next_micro () return self . create ( self . epoch , release ) def next_patch ( self : V ) -> V : \"\"\"Bumps the *patch* part of the [`Release`][versions.segments.Release] if the version is stable, otherwise converts the version to be stable. This is equivalent to [`next_micro`][versions.version.Version.next_micro]. Returns: The bumped version. \"\"\" release = self . release if self . is_stable (): release = release . next_patch () return self . create ( self . epoch , release ) def next_at ( self : V , index : int ) -> V : \"\"\"Bumps the part of the [`Release`][versions.segments.Release] at the `index` if the version is stable, otherwise converts the version to be stable. Arguments: index: The index to bump the part at. Returns: The bumped version. \"\"\" release = self . release if self . is_stable (): release = release . next_at ( index ) return self . create ( self . epoch , release ) def has_major ( self ) -> bool : \"\"\"Checks if the [`Release`][versions.segments.Release] has the *major* part. Returns: Whether the *major* part is present. \"\"\" return self . release . has_major () def has_minor ( self ) -> bool : \"\"\"Checks if the [`Release`][versions.segments.Release] has the *minor* part. Returns: Whether the *minor* part is present. \"\"\" return self . release . has_minor () def has_micro ( self ) -> bool : \"\"\"Checks if the [`Release`][versions.segments.Release] has the *micro* part. Returns: Whether the *micro* part is present. \"\"\" return self . release . has_micro () def has_patch ( self ) -> bool : \"\"\"Checks if the [`Release`][versions.segments.Release] has the *patch* part. This is equivalent to [`has_micro`][versions.version.Version.has_micro]. Returns: Whether the *patch* part is present. \"\"\" return self . release . has_patch () def has_extra ( self ) -> bool : \"\"\"Checks if the [`Release`][versions.segments.Release] has any *extra* parts. Returns: Whether the *extra* parts are present. \"\"\" return self . release . has_extra () def has_at ( self , index : int ) -> bool : \"\"\"Checks if the [`Release`][versions.segments.Release] has a part at the `index`. Returns: Whether the part at the `index` is present. \"\"\" return self . release . has_at ( index ) def pad_to ( self : V , length : int , padding : int = DEFAULT_PADDING ) -> V : \"\"\"Pads the [`Release`][versions.segments.Release] to the `length` with `padding`. Arguments: length: The length to pad the release to. padding: The padding to use. Returns: The padded version. \"\"\" return evolve ( self , release = self . release . pad_to ( length , padding )) def pad_to_index ( self : V , index : int , padding : int = DEFAULT_PADDING ) -> V : \"\"\"Pads the [`Release`][versions.segments.Release] to the `index` with `padding`. Arguments: index: The index to pad the release to. padding: The padding to use. Returns: The padded version. \"\"\" return evolve ( self , release = self . release . pad_to_index ( index , padding )) def pad_to_next ( self : V , padding : int = DEFAULT_PADDING ) -> V : \"\"\"Pads the [`Release`][versions.segments.Release] to the next index. Arguments: padding: The padding to use. Returns: The padded version. \"\"\" return evolve ( self , release = self . release . pad_to_next ( padding )) def is_pre_release ( self ) -> bool : \"\"\"Checks if the version is *pre-release*. Returns: Whether the version is *pre-release*. \"\"\" return self . pre is not None def is_post_release ( self ) -> bool : \"\"\"Checks if the version is *post-release*. Returns: Whether the version is *post-release*. \"\"\" return self . post is not None def is_dev_release ( self ) -> bool : \"\"\"Checks if the version is *dev-release*. Returns: Whether the version is *dev-release*. \"\"\" return self . dev is not None def is_local ( self ) -> bool : \"\"\"Checks if the version is *local*. Returns: Whether the version is *local*. \"\"\" return self . local is not None def is_unstable ( self ) -> bool : \"\"\"Checks if the version is *unstable*. Returns: Whether the version is *unstable*. \"\"\" return self . is_pre_release () or self . is_dev_release () def is_stable ( self ) -> bool : \"\"\"Checks if the version is *stable*. Returns: Whether the version is *stable*. \"\"\" return not self . is_unstable () def next_pre ( self : V ) -> V : \"\"\"Bumps the [`PreTag`][versions.segments.PreTag] if it is present, otherwise adds one to the version. Returns: The bumped version. \"\"\" pre = self . pre if pre is None : pre = PreTag () else : pre = pre . next () return self . create ( self . epoch , self . release , pre ) def next_pre_phase ( self : V ) -> Optional [ V ]: \"\"\"Bumps the [`PreTag`][versions.segments.PreTag] phase if it is present (and if possible), otherwise adds one to the version. Returns: The bumped version (if the next [`PreTag`][versions.segments.PreTag] is present). \"\"\" pre = self . pre if pre is None : pre = PreTag () else : pre = pre . next_phase () if pre is None : return None return self . create ( self . epoch , self . release , pre ) def next_post ( self : V ) -> V : \"\"\"Bumps the [`PostTag`][versions.segments.PostTag] if it is present, otherwise adds one to the version. Returns: The bumped version. \"\"\" post = self . post if post is None : post = PostTag () else : post = post . next () return self . create ( self . epoch , self . release , self . pre , post , self . dev ) def next_dev ( self : V ) -> V : \"\"\"Bumps the [`DevTag`][versions.segments.DevTag] if it is present, otherwise adds one to the version. Returns: The bumped version. \"\"\" dev = self . dev if dev is None : dev = DevTag () else : dev = dev . next () return self . create ( self . epoch , self . release , self . pre , self . post , dev ) def with_pre ( self : V , pre : PreTag ) -> V : \"\"\"Updates a version to include [`PreTag`][versions.segments.PreTag]. Arguments: pre: The *pre-release* tag to include. Returns: The updated version. \"\"\" return self . update ( pre = pre ) def with_post ( self : V , post : PostTag ) -> V : \"\"\"Updates a version to include [`PostTag`][versions.segments.PostTag]. Arguments: post: The *post-release* tag to include. Returns: The updated version. \"\"\" return self . update ( post = post ) def with_dev ( self : V , dev : DevTag ) -> V : \"\"\"Updates a version to include [`DevTag`][versions.segments.DevTag]. Arguments: dev: The *dev-release* tag to include. Returns: The updated version. \"\"\" return self . update ( dev = dev ) def with_local ( self : V , local : Local ) -> V : \"\"\"Updates a version to include [`Local`][versions.segments.Local]. Arguments: local: The *local* segment to include. Returns: The updated version. \"\"\" return self . update ( local = local ) def without_pre ( self : V ) -> V : \"\"\"Updates a version, removing any [`PreTag`][versions.segments.PreTag] from it. Returns: The updated version. \"\"\" return self . update ( pre = None ) def without_post ( self : V ) -> V : \"\"\"Updates a version, removing any [`PostTag`][versions.segments.PostTag] from it. Returns: The updated version. \"\"\" return self . update ( post = None ) def without_dev ( self : V ) -> V : \"\"\"Updates a version, removing any [`DevTag`][versions.segments.DevTag] from it. Returns: The updated version. \"\"\" return self . update ( dev = None ) def without_local ( self : V ) -> V : \"\"\"Updates a version, removing any [`Local`][versions.segments.Local] segment from it. Returns: The updated version. \"\"\" return self . update ( local = None ) def update ( self : V , ** changes : Any ) -> V : \"\"\"Updates a version with `changes`. Arguments: **changes: The changes to apply. Returns: The updated version. \"\"\" return evolve ( self , ** changes ) def weaken ( self , other : W ) -> W : \"\"\"Weakens the `other` version for further comparison. Arguments: other: The version to weaken. Returns: The weakened version. \"\"\" if not self . is_local () and other . is_local (): other = other . without_local () if not self . is_post_release () and other . is_post_release (): other = other . without_post () return other def to_stable ( self : V ) -> V : \"\"\"Forces a version to be stable. Returns: The stable version. \"\"\" return self if self . is_stable () else self . create ( self . epoch , self . release ) def next_breaking ( self : V ) -> V : \"\"\"Returns the next breaking version. This function is slightly convoluted due to how `0.x.y` versions are handled: | version | next breaking | |---------|---------------| | `1.2.3` | `2.0.0` | | `1.2.0` | `2.0.0` | | `1.0.0` | `2.0.0` | | `0.2.3` | `0.3.0` | | `0.0.3` | `0.0.4` | | `0.0.0` | `0.0.1` | | `0.0` | `0.1.0` | | `0` | `1.0.0` | Returns: The next breaking [`Version`][versions.version.Version]. \"\"\" if not self . major : if self . minor : return self . next_minor () if self . has_micro (): return self . next_micro () if self . has_minor (): return self . next_minor () return self . next_major () return self . to_stable () . next_major () def normalize ( self : V ) -> V : \"\"\"Normalizes all version tags. Returns: The normalized version. \"\"\" pre = self . pre if pre is not None : pre = pre . normalize () post = self . post if post is not None : post = post . normalize () dev = self . dev if dev is not None : dev = dev . normalize () return self . update ( pre = pre , post = post , dev = dev ) @classmethod def create ( cls : Type [ V ], epoch : Optional [ Epoch ] = None , release : Optional [ Release ] = None , pre : Optional [ PreTag ] = None , post : Optional [ PostTag ] = None , dev : Optional [ DevTag ] = None , local : Optional [ Local ] = None , ) -> V : \"\"\"Creates a [`Version`][versions.version.Version] from `epoch`, `release`, `pre`, `post`, `dev` and `local`. Arguments: epoch: The *epoch* to use. release: The *release* to use. pre: The *pre-release* tag to use. post: The *post-release* tag to use. dev: The *dev-release* tag to use. local: The *local* segment to use. Returns: The newly created [`Version`][versions.version.Version]. \"\"\" if epoch is None : epoch = Epoch () if release is None : release = Release () return cls ( epoch , release , pre , post , dev , local ) @classmethod def from_parts ( cls : Type [ V ], major : int = DEFAULT_VALUE , minor : int = DEFAULT_VALUE , micro : int = DEFAULT_VALUE , * extra : int , epoch : Optional [ Epoch ] = None , pre : Optional [ PreTag ] = None , post : Optional [ PostTag ] = None , dev : Optional [ DevTag ] = None , local : Optional [ Local ] = None , ) -> V : \"\"\"Creates a [`Version`][versions.version.Version] from `major`, `minor`, `micro` and `extra` parts; `epoch`, `pre`, `post`, `dev` and `local`. Arguments: major: The *major* part to use. minor: The *minor* part to use. micro: The *micro* part to use. *extra: The *extra* parts to use. epoch: The *epoch* to use. pre: The *pre-release* tag to use. post: The *post-release* tag to use. dev: The *dev-release* tag to use. local: The *local* segment to use. Returns: The newly created [`Version`][versions.version.Version]. \"\"\" release = Release . from_parts ( major , minor , micro , * extra ) return cls . create ( epoch , release , pre , post , dev , local ) def matches ( self , specification : Specification ) -> bool : \"\"\"Checks if a version matches the `specification`. Arguments: specification: The specification to check the version against. Returns: Whether the version matches the specification. \"\"\" return specification . accepts ( self )","title":"Version"},{"location":"reference/version/#versions.version.Version.epoch","text":"The epoch segment of the version.","title":"epoch"},{"location":"reference/version/#versions.version.Version.release","text":"The release segment of the version.","title":"release"},{"location":"reference/version/#versions.version.Version.pre","text":"The pre-release tag of the version.","title":"pre"},{"location":"reference/version/#versions.version.Version.post","text":"The post-release tag of the version.","title":"post"},{"location":"reference/version/#versions.version.Version.dev","text":"The dev-release tag of the version.","title":"dev"},{"location":"reference/version/#versions.version.Version.local","text":"The local segment of the version.","title":"local"},{"location":"reference/version/#versions.version.Version.from_string","text":"Parses a Version from string . Parameters: Name Type Description Default string str The string to parse. required Returns: Type Description V The parsed version. Source code in versions/version.py 119 120 121 122 123 124 125 126 127 128 129 @classmethod def from_string ( cls : Type [ V ], string : str ) -> V : \"\"\"Parses a [`Version`][versions.version.Version] from `string`. Arguments: string: The string to parse. Returns: The parsed version. \"\"\" return VersionParser ( cls ) . parse ( string )","title":"from_string()"},{"location":"reference/version/#versions.version.Version.to_string","text":"Converts a Version to its string representation. Returns: Type Description str The version string. Source code in versions/version.py 196 197 198 199 200 201 202 def to_string ( self ) -> str : \"\"\"Converts a [`Version`][versions.version.Version] to its string representation. Returns: The version string. \"\"\" return concat_empty ( self . to_string_iterator ())","title":"to_string()"},{"location":"reference/version/#versions.version.Version.to_short_string","text":"Converts a Version to its short string representation. Returns: Type Description str The short version string. Source code in versions/version.py 204 205 206 207 208 209 210 def to_short_string ( self ) -> str : \"\"\"Converts a [`Version`][versions.version.Version] to its *short* string representation. Returns: The *short* version string. \"\"\" return concat_empty ( self . to_short_string_iterator ())","title":"to_short_string()"},{"location":"reference/version/#versions.version.Version.precision","text":"The precision of the Release . Source code in versions/version.py 212 213 214 215 @property def precision ( self ) -> int : \"\"\"The precision of the [`Release`][versions.segments.Release].\"\"\" return self . release . precision","title":"precision()"},{"location":"reference/version/#versions.version.Version.last_index","text":"The last index of the Release . Source code in versions/version.py 217 218 219 220 @property def last_index ( self ) -> int : \"\"\"The last index of the [`Release`][versions.segments.Release].\"\"\" return self . release . last_index","title":"last_index()"},{"location":"reference/version/#versions.version.Version.major","text":"The major part of the Release . Source code in versions/version.py 222 223 224 225 @property def major ( self ) -> int : \"\"\"The *major* part of the [`Release`][versions.segments.Release].\"\"\" return self . release . major","title":"major()"},{"location":"reference/version/#versions.version.Version.minor","text":"The minor part of the Release . Source code in versions/version.py 227 228 229 230 @property def minor ( self ) -> int : \"\"\"The *minor* part of the [`Release`][versions.segments.Release].\"\"\" return self . release . minor","title":"minor()"},{"location":"reference/version/#versions.version.Version.micro","text":"The micro part of the Release . Source code in versions/version.py 232 233 234 235 @property def micro ( self ) -> int : \"\"\"The *micro* part of the [`Release`][versions.segments.Release].\"\"\" return self . release . micro","title":"micro()"},{"location":"reference/version/#versions.version.Version.patch","text":"The patch part of the Release . This is equivalent to micro . Source code in versions/version.py 237 238 239 240 241 242 243 @property def patch ( self ) -> int : \"\"\"The *patch* part of the [`Release`][versions.segments.Release]. This is equivalent to [`micro`][versions.version.Version.micro]. \"\"\" return self . release . patch","title":"patch()"},{"location":"reference/version/#versions.version.Version.extra","text":"The extra parts of the Release . Source code in versions/version.py 245 246 247 248 @property def extra ( self ) -> Extra : \"\"\"The *extra* parts of the [`Release`][versions.segments.Release].\"\"\" return self . release . extra","title":"extra()"},{"location":"reference/version/#versions.version.Version.get_at","text":"Gets the Release part at the index , defaulting to default . Parameters: Name Type Description Default index int The index of the part to get. required default int The default value to use. DEFAULT_VALUE Returns: Type Description int The release part at index or the default value. Source code in versions/version.py 250 251 252 253 254 255 256 257 258 259 260 261 def get_at ( self , index : int , default : int = DEFAULT_VALUE ) -> int : \"\"\"Gets the [`Release`][versions.segments.Release] part at the `index`, defaulting to `default`. Arguments: index: The index of the part to get. default: The default value to use. Returns: The release part at `index` or the `default` value. \"\"\" return self . release . get_at ( index , default )","title":"get_at()"},{"location":"reference/version/#versions.version.Version.get_at_unchecked","text":"Gets the Release part at the index . Parameters: Name Type Description Default index int The index of the part to get. required Raises: Type Description IndexError The index is out-of-bounds . Returns: Type Description int The release part at the index . Source code in versions/version.py 263 264 265 266 267 268 269 270 271 272 273 274 275 def get_at_unchecked ( self , index : int ) -> int : \"\"\"Gets the [`Release`][versions.segments.Release] part at the `index`. Arguments: index: The index of the part to get. Raises: IndexError: The index is *out-of-bounds*. Returns: The release part at the `index`. \"\"\" return self . release . get_at_unchecked ( index )","title":"get_at_unchecked()"},{"location":"reference/version/#versions.version.Version.is_semantic","text":"Checks if the Release matches the semantic versioning schema. Returns: Type Description bool Whether the release matches the semver schema. Source code in versions/version.py 277 278 279 280 281 282 283 284 def is_semantic ( self ) -> bool : \"\"\"Checks if the [`Release`][versions.segments.Release] matches the *semantic versioning* schema. Returns: Whether the release matches the [`semver`](https://semver.org/) schema. \"\"\" return self . release . is_semantic ()","title":"is_semantic()"},{"location":"reference/version/#versions.version.Version.to_semantic","text":"Converts the Release to match the semver schema. Returns: Type Description V The converted version. Source code in versions/version.py 286 287 288 289 290 291 292 293 def to_semantic ( self : V ) -> V : \"\"\"Converts the [`Release`][versions.segments.Release] to match the [`semver`](https://semver.org/) schema. Returns: The converted version. \"\"\" return self . update ( release = self . release . to_semantic ())","title":"to_semantic()"},{"location":"reference/version/#versions.version.Version.set_major","text":"Sets the major part of the Release to the value . Parameters: Name Type Description Default value int The value to set the major part to. required Returns: Type Description V The updated version. Source code in versions/version.py 295 296 297 298 299 300 301 302 303 304 def set_major ( self : V , value : int ) -> V : \"\"\"Sets the *major* part of the [`Release`][versions.segments.Release] to the `value`. Arguments: value: The value to set the *major* part to. Returns: The updated version. \"\"\" return self . update ( release = self . release . set_major ( value ))","title":"set_major()"},{"location":"reference/version/#versions.version.Version.set_minor","text":"Sets the minor part of the Release to the value . Parameters: Name Type Description Default value int The value to set the minor part to. required Returns: Type Description V The updated version. Source code in versions/version.py 306 307 308 309 310 311 312 313 314 315 def set_minor ( self : V , value : int ) -> V : \"\"\"Sets the *minor* part of the [`Release`][versions.segments.Release] to the `value`. Arguments: value: The value to set the *minor* part to. Returns: The updated version. \"\"\" return self . update ( release = self . release . set_minor ( value ))","title":"set_minor()"},{"location":"reference/version/#versions.version.Version.set_micro","text":"Sets the micro part of the Release to the value . Parameters: Name Type Description Default value int The value to set the micro part to. required Returns: Type Description V The updated version. Source code in versions/version.py 317 318 319 320 321 322 323 324 325 326 def set_micro ( self : V , value : int ) -> V : \"\"\"Sets the *micro* part of the [`Release`][versions.segments.Release] to the `value`. Arguments: value: The value to set the *micro* part to. Returns: The updated version. \"\"\" return self . update ( release = self . release . set_micro ( value ))","title":"set_micro()"},{"location":"reference/version/#versions.version.Version.set_patch","text":"Sets the patch part of the Release to the value . This is equivalent to set_micro . Parameters: Name Type Description Default value int The value to set the patch part to. required Returns: Type Description V The updated version. Source code in versions/version.py 328 329 330 331 332 333 334 335 336 337 338 339 def set_patch ( self : V , value : int ) -> V : \"\"\"Sets the *patch* part of the [`Release`][versions.segments.Release] to the `value`. This is equivalent to [`set_micro`][versions.version.Version.set_micro]. Arguments: value: The value to set the *patch* part to. Returns: The updated version. \"\"\" return self . update ( release = self . release . set_patch ( value ))","title":"set_patch()"},{"location":"reference/version/#versions.version.Version.set_at","text":"Sets the Release part at the index to the value . Parameters: Name Type Description Default index int The index to set the value at. required value int The value to set the part to. required Returns: Type Description V The updated version. Source code in versions/version.py 341 342 343 344 345 346 347 348 349 350 351 def set_at ( self : V , index : int , value : int ) -> V : \"\"\"Sets the [`Release`][versions.segments.Release] part at the `index` to the `value`. Arguments: index: The index to set the `value` at. value: The value to set the part to. Returns: The updated version. \"\"\" return self . update ( release = self . release . set_at ( index , value ))","title":"set_at()"},{"location":"reference/version/#versions.version.Version.set_at_unchecked","text":"Sets the Release part at the index to the value . Parameters: Name Type Description Default index int The index to set the value at. required value int The value to set the part to. required Raises: Type Description IndexError The index is out-of-bounds . Returns: Type Description V The updated version. Source code in versions/version.py 353 354 355 356 357 358 359 360 361 362 363 364 365 366 def set_at_unchecked ( self : V , index : int , value : int ) -> V : \"\"\"Sets the [`Release`][versions.segments.Release] part at the `index` to the `value`. Arguments: index: The index to set the `value` at. value: The value to set the part to. Raises: IndexError: The index is *out-of-bounds*. Returns: The updated version. \"\"\" return self . update ( release = self . release . set_at_unchecked ( index , value ))","title":"set_at_unchecked()"},{"location":"reference/version/#versions.version.Version.next_major","text":"Bumps the major part of the Release if the version is stable, otherwise converts the version to be stable. Returns: Type Description V The bumped version. Source code in versions/version.py 368 369 370 371 372 373 374 375 376 377 378 379 380 def next_major ( self : V ) -> V : \"\"\"Bumps the *major* part of the [`Release`][versions.segments.Release] if the version is stable, otherwise converts the version to be stable. Returns: The bumped version. \"\"\" release = self . release if self . is_stable (): release = release . next_major () return self . create ( self . epoch , release )","title":"next_major()"},{"location":"reference/version/#versions.version.Version.next_minor","text":"Bumps the minor part of the Release if the version is stable, otherwise converts the version to be stable. Returns: Type Description V The bumped version. Source code in versions/version.py 382 383 384 385 386 387 388 389 390 391 392 393 394 def next_minor ( self : V ) -> V : \"\"\"Bumps the *minor* part of the [`Release`][versions.segments.Release] if the version is stable, otherwise converts the version to be stable. Returns: The bumped version. \"\"\" release = self . release if self . is_stable (): release = release . next_minor () return self . create ( self . epoch , release )","title":"next_minor()"},{"location":"reference/version/#versions.version.Version.next_micro","text":"Bumps the micro part of the Release if the version is stable, otherwise converts the version to be stable. Returns: Type Description V The bumped version. Source code in versions/version.py 396 397 398 399 400 401 402 403 404 405 406 407 408 def next_micro ( self : V ) -> V : \"\"\"Bumps the *micro* part of the [`Release`][versions.segments.Release] if the version is stable, otherwise converts the version to be stable. Returns: The bumped version. \"\"\" release = self . release if self . is_stable (): release = release . next_micro () return self . create ( self . epoch , release )","title":"next_micro()"},{"location":"reference/version/#versions.version.Version.next_patch","text":"Bumps the patch part of the Release if the version is stable, otherwise converts the version to be stable. This is equivalent to next_micro . Returns: Type Description V The bumped version. Source code in versions/version.py 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 def next_patch ( self : V ) -> V : \"\"\"Bumps the *patch* part of the [`Release`][versions.segments.Release] if the version is stable, otherwise converts the version to be stable. This is equivalent to [`next_micro`][versions.version.Version.next_micro]. Returns: The bumped version. \"\"\" release = self . release if self . is_stable (): release = release . next_patch () return self . create ( self . epoch , release )","title":"next_patch()"},{"location":"reference/version/#versions.version.Version.next_at","text":"Bumps the part of the Release at the index if the version is stable, otherwise converts the version to be stable. Parameters: Name Type Description Default index int The index to bump the part at. required Returns: Type Description V The bumped version. Source code in versions/version.py 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 def next_at ( self : V , index : int ) -> V : \"\"\"Bumps the part of the [`Release`][versions.segments.Release] at the `index` if the version is stable, otherwise converts the version to be stable. Arguments: index: The index to bump the part at. Returns: The bumped version. \"\"\" release = self . release if self . is_stable (): release = release . next_at ( index ) return self . create ( self . epoch , release )","title":"next_at()"},{"location":"reference/version/#versions.version.Version.has_major","text":"Checks if the Release has the major part. Returns: Type Description bool Whether the major part is present. Source code in versions/version.py 443 444 445 446 447 448 449 def has_major ( self ) -> bool : \"\"\"Checks if the [`Release`][versions.segments.Release] has the *major* part. Returns: Whether the *major* part is present. \"\"\" return self . release . has_major ()","title":"has_major()"},{"location":"reference/version/#versions.version.Version.has_minor","text":"Checks if the Release has the minor part. Returns: Type Description bool Whether the minor part is present. Source code in versions/version.py 451 452 453 454 455 456 457 def has_minor ( self ) -> bool : \"\"\"Checks if the [`Release`][versions.segments.Release] has the *minor* part. Returns: Whether the *minor* part is present. \"\"\" return self . release . has_minor ()","title":"has_minor()"},{"location":"reference/version/#versions.version.Version.has_micro","text":"Checks if the Release has the micro part. Returns: Type Description bool Whether the micro part is present. Source code in versions/version.py 459 460 461 462 463 464 465 def has_micro ( self ) -> bool : \"\"\"Checks if the [`Release`][versions.segments.Release] has the *micro* part. Returns: Whether the *micro* part is present. \"\"\" return self . release . has_micro ()","title":"has_micro()"},{"location":"reference/version/#versions.version.Version.has_patch","text":"Checks if the Release has the patch part. This is equivalent to has_micro . Returns: Type Description bool Whether the patch part is present. Source code in versions/version.py 467 468 469 470 471 472 473 474 475 def has_patch ( self ) -> bool : \"\"\"Checks if the [`Release`][versions.segments.Release] has the *patch* part. This is equivalent to [`has_micro`][versions.version.Version.has_micro]. Returns: Whether the *patch* part is present. \"\"\" return self . release . has_patch ()","title":"has_patch()"},{"location":"reference/version/#versions.version.Version.has_extra","text":"Checks if the Release has any extra parts. Returns: Type Description bool Whether the extra parts are present. Source code in versions/version.py 477 478 479 480 481 482 483 def has_extra ( self ) -> bool : \"\"\"Checks if the [`Release`][versions.segments.Release] has any *extra* parts. Returns: Whether the *extra* parts are present. \"\"\" return self . release . has_extra ()","title":"has_extra()"},{"location":"reference/version/#versions.version.Version.has_at","text":"Checks if the Release has a part at the index . Returns: Type Description bool Whether the part at the index is present. Source code in versions/version.py 485 486 487 488 489 490 491 def has_at ( self , index : int ) -> bool : \"\"\"Checks if the [`Release`][versions.segments.Release] has a part at the `index`. Returns: Whether the part at the `index` is present. \"\"\" return self . release . has_at ( index )","title":"has_at()"},{"location":"reference/version/#versions.version.Version.pad_to","text":"Pads the Release to the length with padding . Parameters: Name Type Description Default length int The length to pad the release to. required padding int The padding to use. DEFAULT_PADDING Returns: Type Description V The padded version. Source code in versions/version.py 493 494 495 496 497 498 499 500 501 502 503 def pad_to ( self : V , length : int , padding : int = DEFAULT_PADDING ) -> V : \"\"\"Pads the [`Release`][versions.segments.Release] to the `length` with `padding`. Arguments: length: The length to pad the release to. padding: The padding to use. Returns: The padded version. \"\"\" return evolve ( self , release = self . release . pad_to ( length , padding ))","title":"pad_to()"},{"location":"reference/version/#versions.version.Version.pad_to_index","text":"Pads the Release to the index with padding . Parameters: Name Type Description Default index int The index to pad the release to. required padding int The padding to use. DEFAULT_PADDING Returns: Type Description V The padded version. Source code in versions/version.py 505 506 507 508 509 510 511 512 513 514 515 def pad_to_index ( self : V , index : int , padding : int = DEFAULT_PADDING ) -> V : \"\"\"Pads the [`Release`][versions.segments.Release] to the `index` with `padding`. Arguments: index: The index to pad the release to. padding: The padding to use. Returns: The padded version. \"\"\" return evolve ( self , release = self . release . pad_to_index ( index , padding ))","title":"pad_to_index()"},{"location":"reference/version/#versions.version.Version.pad_to_next","text":"Pads the Release to the next index. Parameters: Name Type Description Default padding int The padding to use. DEFAULT_PADDING Returns: Type Description V The padded version. Source code in versions/version.py 517 518 519 520 521 522 523 524 525 526 def pad_to_next ( self : V , padding : int = DEFAULT_PADDING ) -> V : \"\"\"Pads the [`Release`][versions.segments.Release] to the next index. Arguments: padding: The padding to use. Returns: The padded version. \"\"\" return evolve ( self , release = self . release . pad_to_next ( padding ))","title":"pad_to_next()"},{"location":"reference/version/#versions.version.Version.is_pre_release","text":"Checks if the version is pre-release . Returns: Type Description bool Whether the version is pre-release . Source code in versions/version.py 528 529 530 531 532 533 534 def is_pre_release ( self ) -> bool : \"\"\"Checks if the version is *pre-release*. Returns: Whether the version is *pre-release*. \"\"\" return self . pre is not None","title":"is_pre_release()"},{"location":"reference/version/#versions.version.Version.is_post_release","text":"Checks if the version is post-release . Returns: Type Description bool Whether the version is post-release . Source code in versions/version.py 536 537 538 539 540 541 542 def is_post_release ( self ) -> bool : \"\"\"Checks if the version is *post-release*. Returns: Whether the version is *post-release*. \"\"\" return self . post is not None","title":"is_post_release()"},{"location":"reference/version/#versions.version.Version.is_dev_release","text":"Checks if the version is dev-release . Returns: Type Description bool Whether the version is dev-release . Source code in versions/version.py 544 545 546 547 548 549 550 def is_dev_release ( self ) -> bool : \"\"\"Checks if the version is *dev-release*. Returns: Whether the version is *dev-release*. \"\"\" return self . dev is not None","title":"is_dev_release()"},{"location":"reference/version/#versions.version.Version.is_local","text":"Checks if the version is local . Returns: Type Description bool Whether the version is local . Source code in versions/version.py 552 553 554 555 556 557 558 def is_local ( self ) -> bool : \"\"\"Checks if the version is *local*. Returns: Whether the version is *local*. \"\"\" return self . local is not None","title":"is_local()"},{"location":"reference/version/#versions.version.Version.is_unstable","text":"Checks if the version is unstable . Returns: Type Description bool Whether the version is unstable . Source code in versions/version.py 560 561 562 563 564 565 566 def is_unstable ( self ) -> bool : \"\"\"Checks if the version is *unstable*. Returns: Whether the version is *unstable*. \"\"\" return self . is_pre_release () or self . is_dev_release ()","title":"is_unstable()"},{"location":"reference/version/#versions.version.Version.is_stable","text":"Checks if the version is stable . Returns: Type Description bool Whether the version is stable . Source code in versions/version.py 568 569 570 571 572 573 574 def is_stable ( self ) -> bool : \"\"\"Checks if the version is *stable*. Returns: Whether the version is *stable*. \"\"\" return not self . is_unstable ()","title":"is_stable()"},{"location":"reference/version/#versions.version.Version.next_pre","text":"Bumps the PreTag if it is present, otherwise adds one to the version. Returns: Type Description V The bumped version. Source code in versions/version.py 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 def next_pre ( self : V ) -> V : \"\"\"Bumps the [`PreTag`][versions.segments.PreTag] if it is present, otherwise adds one to the version. Returns: The bumped version. \"\"\" pre = self . pre if pre is None : pre = PreTag () else : pre = pre . next () return self . create ( self . epoch , self . release , pre )","title":"next_pre()"},{"location":"reference/version/#versions.version.Version.next_pre_phase","text":"Bumps the PreTag phase if it is present (and if possible), otherwise adds one to the version. Returns: Type Description Optional [ V ] The bumped version (if the next PreTag is present). Source code in versions/version.py 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 def next_pre_phase ( self : V ) -> Optional [ V ]: \"\"\"Bumps the [`PreTag`][versions.segments.PreTag] phase if it is present (and if possible), otherwise adds one to the version. Returns: The bumped version (if the next [`PreTag`][versions.segments.PreTag] is present). \"\"\" pre = self . pre if pre is None : pre = PreTag () else : pre = pre . next_phase () if pre is None : return None return self . create ( self . epoch , self . release , pre )","title":"next_pre_phase()"},{"location":"reference/version/#versions.version.Version.next_post","text":"Bumps the PostTag if it is present, otherwise adds one to the version. Returns: Type Description V The bumped version. Source code in versions/version.py 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 def next_post ( self : V ) -> V : \"\"\"Bumps the [`PostTag`][versions.segments.PostTag] if it is present, otherwise adds one to the version. Returns: The bumped version. \"\"\" post = self . post if post is None : post = PostTag () else : post = post . next () return self . create ( self . epoch , self . release , self . pre , post , self . dev )","title":"next_post()"},{"location":"reference/version/#versions.version.Version.next_dev","text":"Bumps the DevTag if it is present, otherwise adds one to the version. Returns: Type Description V The bumped version. Source code in versions/version.py 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 def next_dev ( self : V ) -> V : \"\"\"Bumps the [`DevTag`][versions.segments.DevTag] if it is present, otherwise adds one to the version. Returns: The bumped version. \"\"\" dev = self . dev if dev is None : dev = DevTag () else : dev = dev . next () return self . create ( self . epoch , self . release , self . pre , self . post , dev )","title":"next_dev()"},{"location":"reference/version/#versions.version.Version.with_pre","text":"Updates a version to include PreTag . Parameters: Name Type Description Default pre PreTag The pre-release tag to include. required Returns: Type Description V The updated version. Source code in versions/version.py 647 648 649 650 651 652 653 654 655 656 def with_pre ( self : V , pre : PreTag ) -> V : \"\"\"Updates a version to include [`PreTag`][versions.segments.PreTag]. Arguments: pre: The *pre-release* tag to include. Returns: The updated version. \"\"\" return self . update ( pre = pre )","title":"with_pre()"},{"location":"reference/version/#versions.version.Version.with_post","text":"Updates a version to include PostTag . Parameters: Name Type Description Default post PostTag The post-release tag to include. required Returns: Type Description V The updated version. Source code in versions/version.py 658 659 660 661 662 663 664 665 666 667 def with_post ( self : V , post : PostTag ) -> V : \"\"\"Updates a version to include [`PostTag`][versions.segments.PostTag]. Arguments: post: The *post-release* tag to include. Returns: The updated version. \"\"\" return self . update ( post = post )","title":"with_post()"},{"location":"reference/version/#versions.version.Version.with_dev","text":"Updates a version to include DevTag . Parameters: Name Type Description Default dev DevTag The dev-release tag to include. required Returns: Type Description V The updated version. Source code in versions/version.py 669 670 671 672 673 674 675 676 677 678 def with_dev ( self : V , dev : DevTag ) -> V : \"\"\"Updates a version to include [`DevTag`][versions.segments.DevTag]. Arguments: dev: The *dev-release* tag to include. Returns: The updated version. \"\"\" return self . update ( dev = dev )","title":"with_dev()"},{"location":"reference/version/#versions.version.Version.with_local","text":"Updates a version to include Local . Parameters: Name Type Description Default local Local The local segment to include. required Returns: Type Description V The updated version. Source code in versions/version.py 680 681 682 683 684 685 686 687 688 689 def with_local ( self : V , local : Local ) -> V : \"\"\"Updates a version to include [`Local`][versions.segments.Local]. Arguments: local: The *local* segment to include. Returns: The updated version. \"\"\" return self . update ( local = local )","title":"with_local()"},{"location":"reference/version/#versions.version.Version.without_pre","text":"Updates a version, removing any PreTag from it. Returns: Type Description V The updated version. Source code in versions/version.py 691 692 693 694 695 696 697 def without_pre ( self : V ) -> V : \"\"\"Updates a version, removing any [`PreTag`][versions.segments.PreTag] from it. Returns: The updated version. \"\"\" return self . update ( pre = None )","title":"without_pre()"},{"location":"reference/version/#versions.version.Version.without_post","text":"Updates a version, removing any PostTag from it. Returns: Type Description V The updated version. Source code in versions/version.py 699 700 701 702 703 704 705 def without_post ( self : V ) -> V : \"\"\"Updates a version, removing any [`PostTag`][versions.segments.PostTag] from it. Returns: The updated version. \"\"\" return self . update ( post = None )","title":"without_post()"},{"location":"reference/version/#versions.version.Version.without_dev","text":"Updates a version, removing any DevTag from it. Returns: Type Description V The updated version. Source code in versions/version.py 707 708 709 710 711 712 713 def without_dev ( self : V ) -> V : \"\"\"Updates a version, removing any [`DevTag`][versions.segments.DevTag] from it. Returns: The updated version. \"\"\" return self . update ( dev = None )","title":"without_dev()"},{"location":"reference/version/#versions.version.Version.without_local","text":"Updates a version, removing any Local segment from it. Returns: Type Description V The updated version. Source code in versions/version.py 715 716 717 718 719 720 721 def without_local ( self : V ) -> V : \"\"\"Updates a version, removing any [`Local`][versions.segments.Local] segment from it. Returns: The updated version. \"\"\" return self . update ( local = None )","title":"without_local()"},{"location":"reference/version/#versions.version.Version.update","text":"Updates a version with changes . Parameters: Name Type Description Default **changes Any The changes to apply. {} Returns: Type Description V The updated version. Source code in versions/version.py 723 724 725 726 727 728 729 730 731 732 def update ( self : V , ** changes : Any ) -> V : \"\"\"Updates a version with `changes`. Arguments: **changes: The changes to apply. Returns: The updated version. \"\"\" return evolve ( self , ** changes )","title":"update()"},{"location":"reference/version/#versions.version.Version.weaken","text":"Weakens the other version for further comparison. Parameters: Name Type Description Default other W The version to weaken. required Returns: Type Description W The weakened version. Source code in versions/version.py 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 def weaken ( self , other : W ) -> W : \"\"\"Weakens the `other` version for further comparison. Arguments: other: The version to weaken. Returns: The weakened version. \"\"\" if not self . is_local () and other . is_local (): other = other . without_local () if not self . is_post_release () and other . is_post_release (): other = other . without_post () return other","title":"weaken()"},{"location":"reference/version/#versions.version.Version.to_stable","text":"Forces a version to be stable. Returns: Type Description V The stable version. Source code in versions/version.py 751 752 753 754 755 756 757 def to_stable ( self : V ) -> V : \"\"\"Forces a version to be stable. Returns: The stable version. \"\"\" return self if self . is_stable () else self . create ( self . epoch , self . release )","title":"to_stable()"},{"location":"reference/version/#versions.version.Version.next_breaking","text":"Returns the next breaking version. This function is slightly convoluted due to how 0.x.y versions are handled: version next breaking 1.2.3 2.0.0 1.2.0 2.0.0 1.0.0 2.0.0 0.2.3 0.3.0 0.0.3 0.0.4 0.0.0 0.0.1 0.0 0.1.0 0 1.0.0 Returns: Type Description V The next breaking Version . Source code in versions/version.py 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 def next_breaking ( self : V ) -> V : \"\"\"Returns the next breaking version. This function is slightly convoluted due to how `0.x.y` versions are handled: | version | next breaking | |---------|---------------| | `1.2.3` | `2.0.0` | | `1.2.0` | `2.0.0` | | `1.0.0` | `2.0.0` | | `0.2.3` | `0.3.0` | | `0.0.3` | `0.0.4` | | `0.0.0` | `0.0.1` | | `0.0` | `0.1.0` | | `0` | `1.0.0` | Returns: The next breaking [`Version`][versions.version.Version]. \"\"\" if not self . major : if self . minor : return self . next_minor () if self . has_micro (): return self . next_micro () if self . has_minor (): return self . next_minor () return self . next_major () return self . to_stable () . next_major ()","title":"next_breaking()"},{"location":"reference/version/#versions.version.Version.normalize","text":"Normalizes all version tags. Returns: Type Description V The normalized version. Source code in versions/version.py 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 def normalize ( self : V ) -> V : \"\"\"Normalizes all version tags. Returns: The normalized version. \"\"\" pre = self . pre if pre is not None : pre = pre . normalize () post = self . post if post is not None : post = post . normalize () dev = self . dev if dev is not None : dev = dev . normalize () return self . update ( pre = pre , post = post , dev = dev )","title":"normalize()"},{"location":"reference/version/#versions.version.Version.create","text":"Creates a Version from epoch , release , pre , post , dev and local . Parameters: Name Type Description Default epoch Optional [ Epoch ] The epoch to use. None release Optional [ Release ] The release to use. None pre Optional [ PreTag ] The pre-release tag to use. None post Optional [ PostTag ] The post-release tag to use. None dev Optional [ DevTag ] The dev-release tag to use. None local Optional [ Local ] The local segment to use. None Returns: Type Description V The newly created Version . Source code in versions/version.py 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 @classmethod def create ( cls : Type [ V ], epoch : Optional [ Epoch ] = None , release : Optional [ Release ] = None , pre : Optional [ PreTag ] = None , post : Optional [ PostTag ] = None , dev : Optional [ DevTag ] = None , local : Optional [ Local ] = None , ) -> V : \"\"\"Creates a [`Version`][versions.version.Version] from `epoch`, `release`, `pre`, `post`, `dev` and `local`. Arguments: epoch: The *epoch* to use. release: The *release* to use. pre: The *pre-release* tag to use. post: The *post-release* tag to use. dev: The *dev-release* tag to use. local: The *local* segment to use. Returns: The newly created [`Version`][versions.version.Version]. \"\"\" if epoch is None : epoch = Epoch () if release is None : release = Release () return cls ( epoch , release , pre , post , dev , local )","title":"create()"},{"location":"reference/version/#versions.version.Version.from_parts","text":"Creates a Version from major , minor , micro and extra parts; epoch , pre , post , dev and local . Parameters: Name Type Description Default major int The major part to use. DEFAULT_VALUE minor int The minor part to use. DEFAULT_VALUE micro int The micro part to use. DEFAULT_VALUE *extra int The extra parts to use. () epoch Optional [ Epoch ] The epoch to use. None pre Optional [ PreTag ] The pre-release tag to use. None post Optional [ PostTag ] The post-release tag to use. None dev Optional [ DevTag ] The dev-release tag to use. None local Optional [ Local ] The local segment to use. None Returns: Type Description V The newly created Version . Source code in versions/version.py 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 @classmethod def from_parts ( cls : Type [ V ], major : int = DEFAULT_VALUE , minor : int = DEFAULT_VALUE , micro : int = DEFAULT_VALUE , * extra : int , epoch : Optional [ Epoch ] = None , pre : Optional [ PreTag ] = None , post : Optional [ PostTag ] = None , dev : Optional [ DevTag ] = None , local : Optional [ Local ] = None , ) -> V : \"\"\"Creates a [`Version`][versions.version.Version] from `major`, `minor`, `micro` and `extra` parts; `epoch`, `pre`, `post`, `dev` and `local`. Arguments: major: The *major* part to use. minor: The *minor* part to use. micro: The *micro* part to use. *extra: The *extra* parts to use. epoch: The *epoch* to use. pre: The *pre-release* tag to use. post: The *post-release* tag to use. dev: The *dev-release* tag to use. local: The *local* segment to use. Returns: The newly created [`Version`][versions.version.Version]. \"\"\" release = Release . from_parts ( major , minor , micro , * extra ) return cls . create ( epoch , release , pre , post , dev , local )","title":"from_parts()"},{"location":"reference/version/#versions.version.Version.matches","text":"Checks if a version matches the specification . Parameters: Name Type Description Default specification Specification The specification to check the version against. required Returns: Type Description bool Whether the version matches the specification. Source code in versions/version.py 881 882 883 884 885 886 887 888 889 890 def matches ( self , specification : Specification ) -> bool : \"\"\"Checks if a version matches the `specification`. Arguments: specification: The specification to check the version against. Returns: Whether the version matches the specification. \"\"\" return specification . accepts ( self )","title":"matches()"},{"location":"reference/version_sets/","text":"VersionSet = Union [ VersionEmpty , VersionPoint , VersionRange , VersionUnion ] module-attribute The union of the following types: VersionEmpty VersionPoint VersionRange VersionUnion VersionItem = Union [ VersionPoint , VersionRange ] module-attribute The union of VersionPoint and VersionRange . VersionSetProtocol Bases: Specification , Protocol Source code in versions/version_sets.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 @runtime_checkable class VersionSetProtocol ( Specification , Protocol ): @abstractmethod def is_empty ( self ) -> bool : \"\"\"Checks if the set is *empty*. Returns: Whether the set is *empty*. \"\"\" raise NotImplementedError @abstractmethod def is_universe ( self ) -> bool : \"\"\"Checks if the set is the *universal*. Returns: Whether the set is *universal*. \"\"\" raise NotImplementedError @abstractmethod def includes ( self , version_set : VersionSet ) -> bool : \"\"\"Checks if the set includes `version_set`. Returns: Whether the set includes `version_set`. \"\"\" raise NotImplementedError @abstractmethod def intersects ( self , version_set : VersionSet ) -> bool : \"\"\"Checks if the set intersects `version_set`. Returns: Whether the set intersects `version_set`. \"\"\" raise NotImplementedError @abstractmethod def contains ( self , version : Version ) -> bool : \"\"\"Checks if the set contains some `version`. Returns: Whether the `version` is contained within the set. \"\"\" raise NotImplementedError def accepts ( self , version : Version ) -> bool : \"\"\"Checks if the set contains some `version`. This is an implementation of the [`accepts`][versions.specification.Specification.accepts] method of [`Specification`][versions.specification.Specification] protocol, equivalent to [`self.contains(version)`][versions.version_sets.VersionSetProtocol.contains]. Returns: Whether the `version` is accepted by the set. \"\"\" return self . contains ( version ) @abstractmethod def intersection ( self , version_set : VersionSet ) -> VersionSet : \"\"\"Computes the *intersection* of `self` and `version_set`. Returns: The set representing the *intersection* of `self` and `version_set`. \"\"\" raise NotImplementedError @abstractmethod def union ( self , version_set : VersionSet ) -> VersionSet : \"\"\"Computes the *union* of `self` and `version_set`. Returns: The set representing the *union* of `self` and `version_set`. \"\"\" raise NotImplementedError @abstractmethod def difference ( self , version_set : VersionSet ) -> VersionSet : \"\"\"Computes the *difference* of `self` and `version_set`. Returns: The set representing the *difference* of `self` and `version_set`. \"\"\" raise NotImplementedError @abstractmethod def complement ( self ) -> VersionSet : \"\"\"Computes the *complement* of `self`. Returns: The set representing the *complement* of `self`. \"\"\" raise NotImplementedError def symmetric_difference ( self , version_set : VersionSet ) -> VersionSet : \"\"\"Computes the *symmetric difference* of `self` and `version_set`. Equivalent to [`self.union(version_set).difference(self.intersection(version_set))`] [versions.version_sets.VersionSetProtocol.difference]. Returns: The set representing the *symmetric difference* of `self` and `version_set`. \"\"\" return self . union ( version_set ) . difference ( self . intersection ( version_set )) def __contains__ ( self , version : Version ) -> bool : \"\"\"Checks if the set contains some `version` via the *contains* (`in`) operation. Returns: Whether the `version` is contained within the set. \"\"\" return self . contains ( version ) def __and__ ( self , version_set : VersionSet ) -> VersionSet : \"\"\"Computes the *intersection* of `self` and `version_set` via the *and* (`&`) operation. This is equivalent to [`self.intersection(version_set)`] [versions.version_sets.VersionSetProtocol.intersection]. Returns: The set representing the *intersection* of `self` and `version_set`. \"\"\" return self . intersection ( version_set ) def __iand__ ( self , version_set : VersionSet ) -> VersionSet : \"\"\"Computes the *intersection* of `self` and `version_set` via the *and-assign* (`&=`) operation. This is equivalent to [`self.intersection(version_set)`] [versions.version_sets.VersionSetProtocol.intersection]. Returns: The set representing the *intersection* of `self` and `version_set`. \"\"\" return self . intersection ( version_set ) def __or__ ( self , version_set : VersionSet ) -> VersionSet : \"\"\"Computes the *union* of `self` and `version_set` via the *or* (`|`) operation. This is equivalent to [`self.union(version_set)`] [versions.version_sets.VersionSetProtocol.union]. Returns: The set representing the *union* of `self` and `version_set`. \"\"\" return self . union ( version_set ) def __ior__ ( self , version_set : VersionSet ) -> VersionSet : \"\"\"Computes the *union* of `self` and `version_set` via the *or-assign* (`|=`) operation. This is equivalent to [`self.union(version_set)`] [versions.version_sets.VersionSetProtocol.union]. Returns: The set representing the *union* of `self` and `version_set`. \"\"\" return self . union ( version_set ) def __sub__ ( self , version_set : VersionSet ) -> VersionSet : \"\"\"Computes the *difference* of `self` and `version_set` via the *sub* (`-`) operation. This is equivalent to [`self.difference(version_set)`] [versions.version_sets.VersionSetProtocol.difference]. Returns: The set representing the *difference* of `self` and `version_set`. \"\"\" return self . difference ( version_set ) def __isub__ ( self , version_set : VersionSet ) -> VersionSet : \"\"\"Computes the *difference* of `self` and `version_set` via the *sub-assign* (`-=`) operation. This is equivalent to [`self.difference(version_set)`] [versions.version_sets.VersionSetProtocol.difference]. Returns: The set representing the *difference* of `self` and `version_set`. \"\"\" return self . difference ( version_set ) def __xor__ ( self , version_set : VersionSet ) -> VersionSet : \"\"\"Computes the *symmetric difference* of `self` and `version_set` via the *xor* (`^`) operation. This is equivalent to [`self.symmetric_difference(version_set)`] [versions.version_sets.VersionSetProtocol.symmetric_difference]. Returns: The set representing the *symmetric difference* of `self` and `version_set`. \"\"\" return self . symmetric_difference ( version_set ) def __ixor__ ( self , version_set : VersionSet ) -> VersionSet : \"\"\"Computes the *symmetric difference* of `self` and `version_set` via the *xor-assign* (`^=`) operation. This is equivalent to [`self.symmetric_difference(version_set)`] [versions.version_sets.VersionSetProtocol.symmetric_difference]. Returns: The set representing the *symmetric difference* of `self` and `version_set`. \"\"\" return self . symmetric_difference ( version_set ) def __negate__ ( self ) -> VersionSet : \"\"\"Computes the *complement* of `self` via the *negate* (`~`) operation. This is equivalent to [`self.complement()`] [versions.version_sets.VersionSetProtocol.complement]. Returns: The set representing the *complement* of `self`. \"\"\" return self . complement () is_empty () -> bool abstractmethod Checks if the set is empty . Returns: Type Description bool Whether the set is empty . Source code in versions/version_sets.py 52 53 54 55 56 57 58 59 @abstractmethod def is_empty ( self ) -> bool : \"\"\"Checks if the set is *empty*. Returns: Whether the set is *empty*. \"\"\" raise NotImplementedError is_universe () -> bool abstractmethod Checks if the set is the universal . Returns: Type Description bool Whether the set is universal . Source code in versions/version_sets.py 61 62 63 64 65 66 67 68 @abstractmethod def is_universe ( self ) -> bool : \"\"\"Checks if the set is the *universal*. Returns: Whether the set is *universal*. \"\"\" raise NotImplementedError includes ( version_set : VersionSet ) -> bool abstractmethod Checks if the set includes version_set . Returns: Type Description bool Whether the set includes version_set . Source code in versions/version_sets.py 70 71 72 73 74 75 76 77 @abstractmethod def includes ( self , version_set : VersionSet ) -> bool : \"\"\"Checks if the set includes `version_set`. Returns: Whether the set includes `version_set`. \"\"\" raise NotImplementedError intersects ( version_set : VersionSet ) -> bool abstractmethod Checks if the set intersects version_set . Returns: Type Description bool Whether the set intersects version_set . Source code in versions/version_sets.py 79 80 81 82 83 84 85 86 @abstractmethod def intersects ( self , version_set : VersionSet ) -> bool : \"\"\"Checks if the set intersects `version_set`. Returns: Whether the set intersects `version_set`. \"\"\" raise NotImplementedError contains ( version : Version ) -> bool abstractmethod Checks if the set contains some version . Returns: Type Description bool Whether the version is contained within the set. Source code in versions/version_sets.py 88 89 90 91 92 93 94 95 @abstractmethod def contains ( self , version : Version ) -> bool : \"\"\"Checks if the set contains some `version`. Returns: Whether the `version` is contained within the set. \"\"\" raise NotImplementedError accepts ( version : Version ) -> bool Checks if the set contains some version . This is an implementation of the accepts method of Specification protocol, equivalent to self.contains(version) . Returns: Type Description bool Whether the version is accepted by the set. Source code in versions/version_sets.py 97 98 99 100 101 102 103 104 105 106 107 def accepts ( self , version : Version ) -> bool : \"\"\"Checks if the set contains some `version`. This is an implementation of the [`accepts`][versions.specification.Specification.accepts] method of [`Specification`][versions.specification.Specification] protocol, equivalent to [`self.contains(version)`][versions.version_sets.VersionSetProtocol.contains]. Returns: Whether the `version` is accepted by the set. \"\"\" return self . contains ( version ) intersection ( version_set : VersionSet ) -> VersionSet abstractmethod Computes the intersection of self and version_set . Returns: Type Description VersionSet The set representing the intersection of self and version_set . Source code in versions/version_sets.py 109 110 111 112 113 114 115 116 @abstractmethod def intersection ( self , version_set : VersionSet ) -> VersionSet : \"\"\"Computes the *intersection* of `self` and `version_set`. Returns: The set representing the *intersection* of `self` and `version_set`. \"\"\" raise NotImplementedError union ( version_set : VersionSet ) -> VersionSet abstractmethod Computes the union of self and version_set . Returns: Type Description VersionSet The set representing the union of self and version_set . Source code in versions/version_sets.py 118 119 120 121 122 123 124 125 @abstractmethod def union ( self , version_set : VersionSet ) -> VersionSet : \"\"\"Computes the *union* of `self` and `version_set`. Returns: The set representing the *union* of `self` and `version_set`. \"\"\" raise NotImplementedError difference ( version_set : VersionSet ) -> VersionSet abstractmethod Computes the difference of self and version_set . Returns: Type Description VersionSet The set representing the difference of self and version_set . Source code in versions/version_sets.py 127 128 129 130 131 132 133 134 @abstractmethod def difference ( self , version_set : VersionSet ) -> VersionSet : \"\"\"Computes the *difference* of `self` and `version_set`. Returns: The set representing the *difference* of `self` and `version_set`. \"\"\" raise NotImplementedError complement () -> VersionSet abstractmethod Computes the complement of self . Returns: Type Description VersionSet The set representing the complement of self . Source code in versions/version_sets.py 136 137 138 139 140 141 142 143 @abstractmethod def complement ( self ) -> VersionSet : \"\"\"Computes the *complement* of `self`. Returns: The set representing the *complement* of `self`. \"\"\" raise NotImplementedError symmetric_difference ( version_set : VersionSet ) -> VersionSet Computes the symmetric difference of self and version_set . Equivalent to self.union(version_set).difference(self.intersection(version_set)) . Returns: Type Description VersionSet The set representing the symmetric difference of self and version_set . Source code in versions/version_sets.py 145 146 147 148 149 150 151 152 153 154 def symmetric_difference ( self , version_set : VersionSet ) -> VersionSet : \"\"\"Computes the *symmetric difference* of `self` and `version_set`. Equivalent to [`self.union(version_set).difference(self.intersection(version_set))`] [versions.version_sets.VersionSetProtocol.difference]. Returns: The set representing the *symmetric difference* of `self` and `version_set`. \"\"\" return self . union ( version_set ) . difference ( self . intersection ( version_set )) __contains__ ( version : Version ) -> bool Checks if the set contains some version via the contains ( in ) operation. Returns: Type Description bool Whether the version is contained within the set. Source code in versions/version_sets.py 156 157 158 159 160 161 162 def __contains__ ( self , version : Version ) -> bool : \"\"\"Checks if the set contains some `version` via the *contains* (`in`) operation. Returns: Whether the `version` is contained within the set. \"\"\" return self . contains ( version ) __and__ ( version_set : VersionSet ) -> VersionSet Computes the intersection of self and version_set via the and ( & ) operation. This is equivalent to self.intersection(version_set) . Returns: Type Description VersionSet The set representing the intersection of self and version_set . Source code in versions/version_sets.py 164 165 166 167 168 169 170 171 172 173 def __and__ ( self , version_set : VersionSet ) -> VersionSet : \"\"\"Computes the *intersection* of `self` and `version_set` via the *and* (`&`) operation. This is equivalent to [`self.intersection(version_set)`] [versions.version_sets.VersionSetProtocol.intersection]. Returns: The set representing the *intersection* of `self` and `version_set`. \"\"\" return self . intersection ( version_set ) __iand__ ( version_set : VersionSet ) -> VersionSet Computes the intersection of self and version_set via the and-assign ( &= ) operation. This is equivalent to self.intersection(version_set) . Returns: Type Description VersionSet The set representing the intersection of self and version_set . Source code in versions/version_sets.py 175 176 177 178 179 180 181 182 183 184 185 def __iand__ ( self , version_set : VersionSet ) -> VersionSet : \"\"\"Computes the *intersection* of `self` and `version_set` via the *and-assign* (`&=`) operation. This is equivalent to [`self.intersection(version_set)`] [versions.version_sets.VersionSetProtocol.intersection]. Returns: The set representing the *intersection* of `self` and `version_set`. \"\"\" return self . intersection ( version_set ) __or__ ( version_set : VersionSet ) -> VersionSet Computes the union of self and version_set via the or ( | ) operation. This is equivalent to self.union(version_set) . Returns: Type Description VersionSet The set representing the union of self and version_set . Source code in versions/version_sets.py 187 188 189 190 191 192 193 194 195 196 def __or__ ( self , version_set : VersionSet ) -> VersionSet : \"\"\"Computes the *union* of `self` and `version_set` via the *or* (`|`) operation. This is equivalent to [`self.union(version_set)`] [versions.version_sets.VersionSetProtocol.union]. Returns: The set representing the *union* of `self` and `version_set`. \"\"\" return self . union ( version_set ) __ior__ ( version_set : VersionSet ) -> VersionSet Computes the union of self and version_set via the or-assign ( |= ) operation. This is equivalent to self.union(version_set) . Returns: Type Description VersionSet The set representing the union of self and version_set . Source code in versions/version_sets.py 198 199 200 201 202 203 204 205 206 207 def __ior__ ( self , version_set : VersionSet ) -> VersionSet : \"\"\"Computes the *union* of `self` and `version_set` via the *or-assign* (`|=`) operation. This is equivalent to [`self.union(version_set)`] [versions.version_sets.VersionSetProtocol.union]. Returns: The set representing the *union* of `self` and `version_set`. \"\"\" return self . union ( version_set ) __sub__ ( version_set : VersionSet ) -> VersionSet Computes the difference of self and version_set via the sub ( - ) operation. This is equivalent to self.difference(version_set) . Returns: Type Description VersionSet The set representing the difference of self and version_set . Source code in versions/version_sets.py 209 210 211 212 213 214 215 216 217 218 def __sub__ ( self , version_set : VersionSet ) -> VersionSet : \"\"\"Computes the *difference* of `self` and `version_set` via the *sub* (`-`) operation. This is equivalent to [`self.difference(version_set)`] [versions.version_sets.VersionSetProtocol.difference]. Returns: The set representing the *difference* of `self` and `version_set`. \"\"\" return self . difference ( version_set ) __isub__ ( version_set : VersionSet ) -> VersionSet Computes the difference of self and version_set via the sub-assign ( -= ) operation. This is equivalent to self.difference(version_set) . Returns: Type Description VersionSet The set representing the difference of self and version_set . Source code in versions/version_sets.py 220 221 222 223 224 225 226 227 228 229 230 def __isub__ ( self , version_set : VersionSet ) -> VersionSet : \"\"\"Computes the *difference* of `self` and `version_set` via the *sub-assign* (`-=`) operation. This is equivalent to [`self.difference(version_set)`] [versions.version_sets.VersionSetProtocol.difference]. Returns: The set representing the *difference* of `self` and `version_set`. \"\"\" return self . difference ( version_set ) __xor__ ( version_set : VersionSet ) -> VersionSet Computes the symmetric difference of self and version_set via the xor ( ^ ) operation. This is equivalent to self.symmetric_difference(version_set) . Returns: Type Description VersionSet The set representing the symmetric difference of self and version_set . Source code in versions/version_sets.py 232 233 234 235 236 237 238 239 240 241 242 def __xor__ ( self , version_set : VersionSet ) -> VersionSet : \"\"\"Computes the *symmetric difference* of `self` and `version_set` via the *xor* (`^`) operation. This is equivalent to [`self.symmetric_difference(version_set)`] [versions.version_sets.VersionSetProtocol.symmetric_difference]. Returns: The set representing the *symmetric difference* of `self` and `version_set`. \"\"\" return self . symmetric_difference ( version_set ) __ixor__ ( version_set : VersionSet ) -> VersionSet Computes the symmetric difference of self and version_set via the xor-assign ( ^= ) operation. This is equivalent to self.symmetric_difference(version_set) . Returns: Type Description VersionSet The set representing the symmetric difference of self and version_set . Source code in versions/version_sets.py 244 245 246 247 248 249 250 251 252 253 254 def __ixor__ ( self , version_set : VersionSet ) -> VersionSet : \"\"\"Computes the *symmetric difference* of `self` and `version_set` via the *xor-assign* (`^=`) operation. This is equivalent to [`self.symmetric_difference(version_set)`] [versions.version_sets.VersionSetProtocol.symmetric_difference]. Returns: The set representing the *symmetric difference* of `self` and `version_set`. \"\"\" return self . symmetric_difference ( version_set ) __negate__ () -> VersionSet Computes the complement of self via the negate ( ~ ) operation. This is equivalent to self.complement() . Returns: Type Description VersionSet The set representing the complement of self . Source code in versions/version_sets.py 256 257 258 259 260 261 262 263 264 265 def __negate__ ( self ) -> VersionSet : \"\"\"Computes the *complement* of `self` via the *negate* (`~`) operation. This is equivalent to [`self.complement()`] [versions.version_sets.VersionSetProtocol.complement]. Returns: The set representing the *complement* of `self`. \"\"\" return self . complement () VersionEmpty Bases: Representation , ToString , VersionSetProtocol Represents empty version sets ( {} ). Source code in versions/version_sets.py 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 @frozen ( repr = False , order = False ) class VersionEmpty ( Representation , ToString , VersionSetProtocol ): \"\"\"Represents empty version sets (`{}`).\"\"\" def is_empty ( self ) -> Literal [ True ]: return True def is_universe ( self ) -> Literal [ False ]: return False def includes ( self , version_set : VersionSet ) -> bool : return version_set . is_empty () def intersects ( self , version_set : VersionSet ) -> Literal [ False ]: return False def contains ( self , version : Version ) -> Literal [ False ]: return False def intersection ( self : E , version_set : VersionSet ) -> E : return self def union ( self , version_set : S ) -> S : return version_set def difference ( self : E , version_set : VersionSet ) -> E : return self def symmetric_difference ( self , version_set : S ) -> S : return version_set def complement ( self ) -> VersionRange : return VersionRange () def to_string ( self ) -> str : return EMPTY_VERSION VersionRange Bases: Representation , ToString , VersionRangeProtocol , VersionSetProtocol Represents version ranges ( (x, y) , (x, y] , [x, y) and [x, y] ). Source code in versions/version_sets.py 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 @frozen ( repr = False , eq = False , order = False ) class VersionRange ( Representation , ToString , VersionRangeProtocol , VersionSetProtocol ): \"\"\"Represents version ranges (`(x, y)`, `(x, y]`, `[x, y)` and `[x, y]`).\"\"\" min : Optional [ Version ] = None max : Optional [ Version ] = None include_min : bool = False include_max : bool = False def __attrs_post_init__ ( self ) -> None : if self . min is None : evolve_in_place ( self , include_min = False ) if self . max is None : evolve_in_place ( self , include_max = False ) if self . comparable_min > self . comparable_max : raise ValueError ( MIN_MAX_CONSTRAINT ) def is_empty ( self ) -> bool : return self . is_empty_or_point () and not self . is_closed () def is_point ( self ) -> bool : return self . is_empty_or_point () and self . is_closed () def is_universe ( self ) -> bool : return self . is_unbounded () @property def version ( self ) -> Version : version = self . min or self . max if version is None : raise ValueError ( RANGE_NOT_POINT ) if self . is_point (): return version raise ValueError ( RANGE_NOT_POINT ) def contains ( self , version : Version ) -> bool : comparable_min = self . comparable_min comparable_max = self . comparable_max if version < comparable_min : return False if self . exclude_min and version == comparable_min : return False if version > comparable_max : return False if self . exclude_max and version == comparable_max : return False return True accepts = contains def includes ( self , version_set : VersionSet ) -> bool : if is_version_empty ( version_set ): return True if is_version_point ( version_set ): return self . contains ( version_set . version ) if is_version_range ( version_set ): return not version_set . is_lower ( self ) and not version_set . is_higher ( self ) if is_version_union ( version_set ): return all ( self . includes ( item ) for item in version_set . items ) raise TypeError ( UNEXPECTED_VERSION_SET . format ( repr ( version_set ))) def intersects ( self , version_set : VersionSet ) -> bool : if is_version_empty ( version_set ): return False if is_version_point ( version_set ): return self . contains ( version_set . version ) if is_version_range ( version_set ): return self . intersects_range ( version_set ) if is_version_union ( version_set ): return any ( self . intersects ( item ) for item in version_set . items ) raise TypeError ( UNEXPECTED_VERSION_SET . format ( repr ( version_set ))) def intersects_range ( self , range : VersionRange ) -> bool : return not range . is_strictly_lower ( self ) and not range . is_strictly_higher ( self ) def intersection ( self , version_set : VersionSet ) -> VersionSet : if is_version_empty ( version_set ): return VersionEmpty () if is_version_point ( version_set ): return version_set . intersection ( self ) if is_version_range ( version_set ): if self . is_lower ( version_set ): if self . is_strictly_lower ( version_set ): return VersionEmpty () intersection_min = version_set . min intersection_include_min = version_set . include_min else : if self . is_strictly_higher ( version_set ): return VersionEmpty () intersection_min = self . min intersection_include_min = self . include_min if self . is_higher ( version_set ): intersection_max = version_set . max intersection_include_max = version_set . include_max else : intersection_max = self . max intersection_include_max = self . include_max # if we reached here, there is an actual range intersection = VersionRange ( intersection_min , intersection_max , intersection_include_min , intersection_include_max , ) if intersection . is_point (): return VersionPoint ( intersection . version ) return intersection if is_version_union ( version_set ): return version_set . intersection ( self ) raise TypeError ( UNEXPECTED_VERSION_SET . format ( repr ( version_set ))) def union ( self , version_set : VersionSet ) -> VersionSet : if is_version_empty ( version_set ): return self if is_version_point ( version_set ): version = version_set . version if self . contains ( version ): return self if version == self . min : return evolve ( self , include_min = True ) if version == self . max : return evolve ( self , include_max = True ) return VersionUnion . of ( self , version_set ) if is_version_range ( version_set ): if not self . is_adjacent ( version_set ) and not self . intersects ( version_set ): return VersionUnion . of ( self , version_set ) if self . is_lower ( version_set ): union_min = self . min union_include_min = self . include_min else : union_min = version_set . min union_include_min = version_set . include_min if self . is_higher ( version_set ): union_max = self . max union_include_max = self . include_max else : union_max = version_set . max union_include_max = version_set . include_max return VersionRange ( union_min , union_max , union_include_min , union_include_max , ) if is_version_union ( version_set ): return version_set . union ( self ) raise TypeError ( UNEXPECTED_VERSION_SET . format ( repr ( version_set ))) def difference ( self , version_set : VersionSet ) -> VersionSet : if is_version_empty ( version_set ): return self if is_version_point ( version_set ): version = version_set . version if not self . contains ( version ): return self if version == self . min : if self . exclude_min : return self return evolve ( self , include_min = False ) if version == self . max : if self . exclude_max : return self return evolve ( self , include_max = False ) return VersionUnion . of ( evolve ( self , max = version , include_max = False ), evolve ( self , min = version , include_min = False ), ) if is_version_range ( version_set ): if not self . intersects ( version_set ): return self before : Optional [ VersionItem ] if not self . is_lower ( version_set ): before = None elif self . min == version_set . min : before = VersionPoint ( self . min ) # type: ignore else : before = evolve ( self , max = version_set . min , include_max = version_set . exclude_min ) after : Optional [ VersionItem ] if not self . is_higher ( version_set ): after = None elif self . max == version_set . max : after = VersionPoint ( self . max ) # type: ignore else : after = evolve ( self , min = version_set . max , include_min = version_set . exclude_max ) if before is None and after is None : return VersionEmpty () if before is None : return after # type: ignore if after is None : return before # type: ignore return VersionUnion . of ( before , after ) if is_version_union ( version_set ): return VersionUnion . of_iterable ( self . difference_iterator ( version_set )) raise TypeError ( UNEXPECTED_VERSION_SET . format ( repr ( version_set ))) def difference_iterator ( self , version_union : VersionUnion ) -> Iterator [ VersionItem ]: current : VersionItem = self for item in version_union . items : if item . is_strictly_lower ( current ): continue if item . is_strictly_higher ( current ): break difference = current . difference ( item ) if is_version_union ( difference ): item , current = difference . items yield item if is_version_item ( difference ): current = difference yield current def complement ( self ) -> VersionSet : return VersionRange () . difference ( self ) def to_string_iterator ( self ) -> Iterator [ str ]: if self . is_empty (): yield EMPTY_VERSION return if self . is_point (): yield self . version . to_string () return if self . is_universe (): yield UNIVERSE_VERSION return min = self . min if min : min_type = OperatorType . GREATER_OR_EQUAL if self . include_min else OperatorType . GREATER min_operator = Operator ( min_type , min ) yield min_operator . to_string () max = self . max if max : max_type = OperatorType . LESS_OR_EQUAL if self . include_max else OperatorType . LESS max_operator = Operator ( max_type , max ) yield max_operator . to_string () def to_short_string_iterator ( self ) -> Iterator [ str ]: if self . is_empty (): yield EMPTY_VERSION return if self . is_point (): yield self . version . to_short_string () return if self . is_universe (): yield UNIVERSE_VERSION return min = self . min if min : min_type = OperatorType . GREATER_OR_EQUAL if self . include_min else OperatorType . GREATER min_operator = Operator ( min_type , min ) yield min_operator . to_short_string () max = self . max if max : max_type = OperatorType . LESS_OR_EQUAL if self . include_max else OperatorType . LESS max_operator = Operator ( max_type , max ) yield max_operator . to_short_string () def to_string ( self ) -> str : return concat_comma_space ( self . to_string_iterator ()) def to_short_string ( self ) -> str : return concat_comma ( self . to_short_string_iterator ()) VersionPoint Bases: Representation , ToString , VersionRangeProtocol , VersionSetProtocol Represents version points ( [v, v] aka {v} ). Source code in versions/version_sets.py 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 @frozen ( repr = False , eq = False , order = False ) class VersionPoint ( Representation , ToString , VersionRangeProtocol , VersionSetProtocol ): \"\"\"Represents version points (`[v, v]` aka `{v}`).\"\"\" version : Version @property def min ( self ) -> Optional [ Version ]: # type: ignore return self . version @property def max ( self ) -> Optional [ Version ]: # type: ignore return self . version @property def include_min ( self ) -> bool : # type: ignore return True @property def include_max ( self ) -> bool : # type: ignore return True def is_empty ( self ) -> bool : return False def is_point ( self ) -> bool : return True def is_universe ( self ) -> bool : return False def contains ( self , version : Version ) -> bool : # version = self.version.weaken(version) return self . version == version accepts = contains def includes ( self , version_set : VersionSet ) -> bool : return version_set . is_empty () or ( is_version_point ( version_set ) and self . contains ( version_set . version ) ) def intersects ( self , version_set : VersionSet ) -> bool : return version_set . contains ( self . version ) def intersection ( self , version_set : VersionSet ) -> VersionSet : return self if version_set . contains ( self . version ) else VersionEmpty () def union ( self , version_set : VersionSet ) -> VersionSet : if is_version_empty ( version_set ): return self if is_version_point ( version_set ): if self . contains ( version_set . version ): return self return VersionUnion . of ( self , version_set ) if version_set . contains ( self . version ): return version_set if is_version_range ( version_set ) or is_version_union ( version_set ): return VersionUnion . of ( self , version_set ) raise TypeError ( UNEXPECTED_VERSION_SET . format ( repr ( version_set ))) def difference ( self , version_set : VersionSet ) -> VersionSet : return VersionEmpty () if version_set . contains ( self . version ) else self def complement ( self ) -> VersionSet : return VersionRange () . difference ( self ) def to_string ( self ) -> str : return self . version . to_string () def to_short_string ( self ) -> str : return self . version . to_short_string () VersionUnion Bases: Representation , ToString , Specification Represents version unions. Source code in versions/version_sets.py 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 @frozen ( repr = False , order = False ) class VersionUnion ( Representation , ToString , Specification ): \"\"\"Represents version unions.\"\"\" items : VersionItems = field () @items . validator def check_items ( self , attribute : Attribute [ VersionItems ], items : VersionItems ) -> None : check_items ( items ) @classmethod def extract ( cls , version_set : VersionSet ) -> Iterator [ VersionItem ]: if is_version_union ( version_set ): yield from version_set . items if is_version_item ( version_set ): yield version_set @classmethod def of ( cls , * version_sets : VersionSet ) -> VersionSet : return cls . of_iterable ( version_sets ) @classmethod def of_iterable ( cls , iterable : Iterable [ VersionSet ]) -> VersionSet : extracted = list ( flatten ( map ( cls . extract , iterable ))) if not extracted : return VersionEmpty () if any ( item . is_universe () for item in extracted ): return VersionRange () extracted . sort () merged : List [ VersionItem ] = [] for item in extracted : if not merged : merged . append ( item ) else : last_item = last ( merged ) if last_item . intersects ( item ) or last_item . is_adjacent ( item ): result = last_item . union ( item ) if is_version_item ( result ): set_last ( merged , result ) else : # pragma: no cover raise InternalError ( UNEXPECTED_UNION ) else : merged . append ( item ) if contains_only_item ( merged ): return first ( merged ) return cls ( tuple ( merged )) @property def exclude_version ( self ) -> Optional [ Version ]: complement = self . complement () return complement . version if is_version_point ( complement ) else None def is_empty ( self ) -> bool : return False def is_universe ( self ) -> bool : return False def contains ( self , version : Version ) -> bool : return any ( item . contains ( version ) for item in self . items ) accepts = contains def includes ( self , version_set : VersionSet ) -> bool : self_items = iter ( self . items ) items = self . extract ( version_set ) self_item = next_or_none ( self_items ) item = next_or_none ( items ) while self_item and item : if self_item . includes ( item ): item = next_or_none ( items ) else : self_item = next_or_none ( self_items ) return item is None # all items are covered def intersects ( self , version_set : VersionSet ) -> bool : self_items = iter ( self . items ) items = self . extract ( version_set ) self_item = next_or_none ( self_items ) item = next_or_none ( items ) while self_item and item : if self_item . intersects ( item ): return True if item . is_higher ( self_item ): self_item = next_or_none ( self_items ) else : item = next_or_none ( items ) return False # none of the items are allowed def intersection_iterator ( self , version_set : VersionSet ) -> Iterator [ VersionItem ]: self_items = iter ( self . items ) items = self . extract ( version_set ) self_item = next_or_none ( self_items ) item = next_or_none ( items ) while self_item and item : intersection = self_item . intersection ( item ) if is_version_item ( intersection ): yield intersection if item . is_higher ( self_item ): self_item = next_or_none ( self_items ) else : item = next_or_none ( items ) def intersection ( self , version_set : VersionSet ) -> VersionSet : return self . of_iterable ( self . intersection_iterator ( version_set )) def union ( self , version_set : VersionSet ) -> VersionSet : return self . of ( self , version_set ) def difference ( self , version_set : VersionSet ) -> VersionSet : items_difference = ItemsDifference ( iter ( self . items ), self . extract ( version_set )) return self . of_iterable ( items_difference . compute ()) def complement ( self ) -> VersionSet : return VersionRange () . difference ( self ) def to_string ( self ) -> str : exclude_version = self . exclude_version if exclude_version : operator = Operator ( OperatorType . NOT_EQUAL , exclude_version ) return operator . to_string () return concat_pipes_spaced ( item . to_string () for item in self . items ) def to_short_string ( self ) -> str : exclude_version = self . exclude_version if exclude_version : operator = Operator ( OperatorType . NOT_EQUAL , exclude_version ) return operator . to_short_string () return concat_pipes ( item . to_short_string () for item in self . items ) is_version_empty ( item : Any ) -> TypeGuard [ VersionEmpty ] Checks if an item is an instance of VersionEmpty . Returns: Type Description TypeGuard [ VersionEmpty ] Whether the item provided is an instance of VersionEmpty . Source code in versions/version_sets.py 268 269 270 271 272 273 274 275 def is_version_empty ( item : Any ) -> TypeGuard [ VersionEmpty ]: \"\"\"Checks if an `item` is an instance of [`VersionEmpty`][versions.version_sets.VersionEmpty]. Returns: Whether the `item` provided is an instance of [`VersionEmpty`][versions.version_sets.VersionEmpty]. \"\"\" return is_instance ( item , VersionEmpty ) is_version_point ( item : Any ) -> TypeGuard [ VersionPoint ] Checks if an item is an instance of VersionPoint . Returns: Type Description TypeGuard [ VersionPoint ] Whether the item provided is an instance of VersionPoint . Source code in versions/version_sets.py 278 279 280 281 282 283 284 285 def is_version_point ( item : Any ) -> TypeGuard [ VersionPoint ]: \"\"\"Checks if an `item` is an instance of [`VersionPoint`][versions.version_sets.VersionPoint]. Returns: Whether the `item` provided is an instance of [`VersionPoint`][versions.version_sets.VersionPoint]. \"\"\" return is_instance ( item , VersionPoint ) is_version_range ( item : Any ) -> TypeGuard [ VersionRange ] Checks if an item is an instance of VersionRange . Returns: Type Description TypeGuard [ VersionRange ] Whether the item provided is an instance of VersionRange . Source code in versions/version_sets.py 288 289 290 291 292 293 294 295 def is_version_range ( item : Any ) -> TypeGuard [ VersionRange ]: \"\"\"Checks if an `item` is an instance of [`VersionRange`][versions.version_sets.VersionRange]. Returns: Whether the `item` provided is an instance of [`VersionRange`][versions.version_sets.VersionRange]. \"\"\" return is_instance ( item , VersionRange ) is_version_union ( item : Any ) -> TypeGuard [ VersionUnion ] Checks if an item is an instance of VersionUnion . Returns: Type Description TypeGuard [ VersionUnion ] Whether the item provided is an instance of VersionUnion . Source code in versions/version_sets.py 298 299 300 301 302 303 304 305 def is_version_union ( item : Any ) -> TypeGuard [ VersionUnion ]: \"\"\"Checks if an `item` is an instance of [`VersionUnion`][versions.version_sets.VersionUnion]. Returns: Whether the `item` provided is an instance of [`VersionUnion`][versions.version_sets.VersionUnion]. \"\"\" return is_instance ( item , VersionUnion ) is_version_item ( item : Any ) -> TypeGuard [ VersionItem ] Checks if an item is an instance of VersionItem . Returns: Type Description TypeGuard [ VersionItem ] Whether the item provided is an instance of VersionItem . Source code in versions/version_sets.py 308 309 310 311 312 313 314 315 def is_version_item ( item : Any ) -> TypeGuard [ VersionItem ]: \"\"\"Checks if an `item` is an instance of [`VersionItem`][versions.version_sets.VersionItem]. Returns: Whether the `item` provided is an instance of [`VersionItem`][versions.version_sets.VersionItem]. \"\"\" return is_instance ( item , VersionItemTypes ) is_version_set ( item : Any ) -> TypeGuard [ VersionSet ] Checks if an item is an instance of VersionSet . Returns: Type Description TypeGuard [ VersionSet ] Whether the item provided is an instance of VersionSet . Source code in versions/version_sets.py 318 319 320 321 322 323 324 325 def is_version_set ( item : Any ) -> TypeGuard [ VersionSet ]: \"\"\"Checks if an `item` is an instance of [`VersionSet`][versions.version_sets.VersionSet]. Returns: Whether the `item` provided is an instance of [`VersionSet`][versions.version_sets.VersionSet]. \"\"\" return is_instance ( item , VersionSetTypes )","title":"Version Sets"},{"location":"reference/version_sets/#versions.version_sets.VersionSet","text":"The union of the following types: VersionEmpty VersionPoint VersionRange VersionUnion","title":"VersionSet"},{"location":"reference/version_sets/#versions.version_sets.VersionItem","text":"The union of VersionPoint and VersionRange .","title":"VersionItem"},{"location":"reference/version_sets/#versions.version_sets.VersionSetProtocol","text":"Bases: Specification , Protocol Source code in versions/version_sets.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 @runtime_checkable class VersionSetProtocol ( Specification , Protocol ): @abstractmethod def is_empty ( self ) -> bool : \"\"\"Checks if the set is *empty*. Returns: Whether the set is *empty*. \"\"\" raise NotImplementedError @abstractmethod def is_universe ( self ) -> bool : \"\"\"Checks if the set is the *universal*. Returns: Whether the set is *universal*. \"\"\" raise NotImplementedError @abstractmethod def includes ( self , version_set : VersionSet ) -> bool : \"\"\"Checks if the set includes `version_set`. Returns: Whether the set includes `version_set`. \"\"\" raise NotImplementedError @abstractmethod def intersects ( self , version_set : VersionSet ) -> bool : \"\"\"Checks if the set intersects `version_set`. Returns: Whether the set intersects `version_set`. \"\"\" raise NotImplementedError @abstractmethod def contains ( self , version : Version ) -> bool : \"\"\"Checks if the set contains some `version`. Returns: Whether the `version` is contained within the set. \"\"\" raise NotImplementedError def accepts ( self , version : Version ) -> bool : \"\"\"Checks if the set contains some `version`. This is an implementation of the [`accepts`][versions.specification.Specification.accepts] method of [`Specification`][versions.specification.Specification] protocol, equivalent to [`self.contains(version)`][versions.version_sets.VersionSetProtocol.contains]. Returns: Whether the `version` is accepted by the set. \"\"\" return self . contains ( version ) @abstractmethod def intersection ( self , version_set : VersionSet ) -> VersionSet : \"\"\"Computes the *intersection* of `self` and `version_set`. Returns: The set representing the *intersection* of `self` and `version_set`. \"\"\" raise NotImplementedError @abstractmethod def union ( self , version_set : VersionSet ) -> VersionSet : \"\"\"Computes the *union* of `self` and `version_set`. Returns: The set representing the *union* of `self` and `version_set`. \"\"\" raise NotImplementedError @abstractmethod def difference ( self , version_set : VersionSet ) -> VersionSet : \"\"\"Computes the *difference* of `self` and `version_set`. Returns: The set representing the *difference* of `self` and `version_set`. \"\"\" raise NotImplementedError @abstractmethod def complement ( self ) -> VersionSet : \"\"\"Computes the *complement* of `self`. Returns: The set representing the *complement* of `self`. \"\"\" raise NotImplementedError def symmetric_difference ( self , version_set : VersionSet ) -> VersionSet : \"\"\"Computes the *symmetric difference* of `self` and `version_set`. Equivalent to [`self.union(version_set).difference(self.intersection(version_set))`] [versions.version_sets.VersionSetProtocol.difference]. Returns: The set representing the *symmetric difference* of `self` and `version_set`. \"\"\" return self . union ( version_set ) . difference ( self . intersection ( version_set )) def __contains__ ( self , version : Version ) -> bool : \"\"\"Checks if the set contains some `version` via the *contains* (`in`) operation. Returns: Whether the `version` is contained within the set. \"\"\" return self . contains ( version ) def __and__ ( self , version_set : VersionSet ) -> VersionSet : \"\"\"Computes the *intersection* of `self` and `version_set` via the *and* (`&`) operation. This is equivalent to [`self.intersection(version_set)`] [versions.version_sets.VersionSetProtocol.intersection]. Returns: The set representing the *intersection* of `self` and `version_set`. \"\"\" return self . intersection ( version_set ) def __iand__ ( self , version_set : VersionSet ) -> VersionSet : \"\"\"Computes the *intersection* of `self` and `version_set` via the *and-assign* (`&=`) operation. This is equivalent to [`self.intersection(version_set)`] [versions.version_sets.VersionSetProtocol.intersection]. Returns: The set representing the *intersection* of `self` and `version_set`. \"\"\" return self . intersection ( version_set ) def __or__ ( self , version_set : VersionSet ) -> VersionSet : \"\"\"Computes the *union* of `self` and `version_set` via the *or* (`|`) operation. This is equivalent to [`self.union(version_set)`] [versions.version_sets.VersionSetProtocol.union]. Returns: The set representing the *union* of `self` and `version_set`. \"\"\" return self . union ( version_set ) def __ior__ ( self , version_set : VersionSet ) -> VersionSet : \"\"\"Computes the *union* of `self` and `version_set` via the *or-assign* (`|=`) operation. This is equivalent to [`self.union(version_set)`] [versions.version_sets.VersionSetProtocol.union]. Returns: The set representing the *union* of `self` and `version_set`. \"\"\" return self . union ( version_set ) def __sub__ ( self , version_set : VersionSet ) -> VersionSet : \"\"\"Computes the *difference* of `self` and `version_set` via the *sub* (`-`) operation. This is equivalent to [`self.difference(version_set)`] [versions.version_sets.VersionSetProtocol.difference]. Returns: The set representing the *difference* of `self` and `version_set`. \"\"\" return self . difference ( version_set ) def __isub__ ( self , version_set : VersionSet ) -> VersionSet : \"\"\"Computes the *difference* of `self` and `version_set` via the *sub-assign* (`-=`) operation. This is equivalent to [`self.difference(version_set)`] [versions.version_sets.VersionSetProtocol.difference]. Returns: The set representing the *difference* of `self` and `version_set`. \"\"\" return self . difference ( version_set ) def __xor__ ( self , version_set : VersionSet ) -> VersionSet : \"\"\"Computes the *symmetric difference* of `self` and `version_set` via the *xor* (`^`) operation. This is equivalent to [`self.symmetric_difference(version_set)`] [versions.version_sets.VersionSetProtocol.symmetric_difference]. Returns: The set representing the *symmetric difference* of `self` and `version_set`. \"\"\" return self . symmetric_difference ( version_set ) def __ixor__ ( self , version_set : VersionSet ) -> VersionSet : \"\"\"Computes the *symmetric difference* of `self` and `version_set` via the *xor-assign* (`^=`) operation. This is equivalent to [`self.symmetric_difference(version_set)`] [versions.version_sets.VersionSetProtocol.symmetric_difference]. Returns: The set representing the *symmetric difference* of `self` and `version_set`. \"\"\" return self . symmetric_difference ( version_set ) def __negate__ ( self ) -> VersionSet : \"\"\"Computes the *complement* of `self` via the *negate* (`~`) operation. This is equivalent to [`self.complement()`] [versions.version_sets.VersionSetProtocol.complement]. Returns: The set representing the *complement* of `self`. \"\"\" return self . complement ()","title":"VersionSetProtocol"},{"location":"reference/version_sets/#versions.version_sets.VersionSetProtocol.is_empty","text":"Checks if the set is empty . Returns: Type Description bool Whether the set is empty . Source code in versions/version_sets.py 52 53 54 55 56 57 58 59 @abstractmethod def is_empty ( self ) -> bool : \"\"\"Checks if the set is *empty*. Returns: Whether the set is *empty*. \"\"\" raise NotImplementedError","title":"is_empty()"},{"location":"reference/version_sets/#versions.version_sets.VersionSetProtocol.is_universe","text":"Checks if the set is the universal . Returns: Type Description bool Whether the set is universal . Source code in versions/version_sets.py 61 62 63 64 65 66 67 68 @abstractmethod def is_universe ( self ) -> bool : \"\"\"Checks if the set is the *universal*. Returns: Whether the set is *universal*. \"\"\" raise NotImplementedError","title":"is_universe()"},{"location":"reference/version_sets/#versions.version_sets.VersionSetProtocol.includes","text":"Checks if the set includes version_set . Returns: Type Description bool Whether the set includes version_set . Source code in versions/version_sets.py 70 71 72 73 74 75 76 77 @abstractmethod def includes ( self , version_set : VersionSet ) -> bool : \"\"\"Checks if the set includes `version_set`. Returns: Whether the set includes `version_set`. \"\"\" raise NotImplementedError","title":"includes()"},{"location":"reference/version_sets/#versions.version_sets.VersionSetProtocol.intersects","text":"Checks if the set intersects version_set . Returns: Type Description bool Whether the set intersects version_set . Source code in versions/version_sets.py 79 80 81 82 83 84 85 86 @abstractmethod def intersects ( self , version_set : VersionSet ) -> bool : \"\"\"Checks if the set intersects `version_set`. Returns: Whether the set intersects `version_set`. \"\"\" raise NotImplementedError","title":"intersects()"},{"location":"reference/version_sets/#versions.version_sets.VersionSetProtocol.contains","text":"Checks if the set contains some version . Returns: Type Description bool Whether the version is contained within the set. Source code in versions/version_sets.py 88 89 90 91 92 93 94 95 @abstractmethod def contains ( self , version : Version ) -> bool : \"\"\"Checks if the set contains some `version`. Returns: Whether the `version` is contained within the set. \"\"\" raise NotImplementedError","title":"contains()"},{"location":"reference/version_sets/#versions.version_sets.VersionSetProtocol.accepts","text":"Checks if the set contains some version . This is an implementation of the accepts method of Specification protocol, equivalent to self.contains(version) . Returns: Type Description bool Whether the version is accepted by the set. Source code in versions/version_sets.py 97 98 99 100 101 102 103 104 105 106 107 def accepts ( self , version : Version ) -> bool : \"\"\"Checks if the set contains some `version`. This is an implementation of the [`accepts`][versions.specification.Specification.accepts] method of [`Specification`][versions.specification.Specification] protocol, equivalent to [`self.contains(version)`][versions.version_sets.VersionSetProtocol.contains]. Returns: Whether the `version` is accepted by the set. \"\"\" return self . contains ( version )","title":"accepts()"},{"location":"reference/version_sets/#versions.version_sets.VersionSetProtocol.intersection","text":"Computes the intersection of self and version_set . Returns: Type Description VersionSet The set representing the intersection of self and version_set . Source code in versions/version_sets.py 109 110 111 112 113 114 115 116 @abstractmethod def intersection ( self , version_set : VersionSet ) -> VersionSet : \"\"\"Computes the *intersection* of `self` and `version_set`. Returns: The set representing the *intersection* of `self` and `version_set`. \"\"\" raise NotImplementedError","title":"intersection()"},{"location":"reference/version_sets/#versions.version_sets.VersionSetProtocol.union","text":"Computes the union of self and version_set . Returns: Type Description VersionSet The set representing the union of self and version_set . Source code in versions/version_sets.py 118 119 120 121 122 123 124 125 @abstractmethod def union ( self , version_set : VersionSet ) -> VersionSet : \"\"\"Computes the *union* of `self` and `version_set`. Returns: The set representing the *union* of `self` and `version_set`. \"\"\" raise NotImplementedError","title":"union()"},{"location":"reference/version_sets/#versions.version_sets.VersionSetProtocol.difference","text":"Computes the difference of self and version_set . Returns: Type Description VersionSet The set representing the difference of self and version_set . Source code in versions/version_sets.py 127 128 129 130 131 132 133 134 @abstractmethod def difference ( self , version_set : VersionSet ) -> VersionSet : \"\"\"Computes the *difference* of `self` and `version_set`. Returns: The set representing the *difference* of `self` and `version_set`. \"\"\" raise NotImplementedError","title":"difference()"},{"location":"reference/version_sets/#versions.version_sets.VersionSetProtocol.complement","text":"Computes the complement of self . Returns: Type Description VersionSet The set representing the complement of self . Source code in versions/version_sets.py 136 137 138 139 140 141 142 143 @abstractmethod def complement ( self ) -> VersionSet : \"\"\"Computes the *complement* of `self`. Returns: The set representing the *complement* of `self`. \"\"\" raise NotImplementedError","title":"complement()"},{"location":"reference/version_sets/#versions.version_sets.VersionSetProtocol.symmetric_difference","text":"Computes the symmetric difference of self and version_set . Equivalent to self.union(version_set).difference(self.intersection(version_set)) . Returns: Type Description VersionSet The set representing the symmetric difference of self and version_set . Source code in versions/version_sets.py 145 146 147 148 149 150 151 152 153 154 def symmetric_difference ( self , version_set : VersionSet ) -> VersionSet : \"\"\"Computes the *symmetric difference* of `self` and `version_set`. Equivalent to [`self.union(version_set).difference(self.intersection(version_set))`] [versions.version_sets.VersionSetProtocol.difference]. Returns: The set representing the *symmetric difference* of `self` and `version_set`. \"\"\" return self . union ( version_set ) . difference ( self . intersection ( version_set ))","title":"symmetric_difference()"},{"location":"reference/version_sets/#versions.version_sets.VersionSetProtocol.__contains__","text":"Checks if the set contains some version via the contains ( in ) operation. Returns: Type Description bool Whether the version is contained within the set. Source code in versions/version_sets.py 156 157 158 159 160 161 162 def __contains__ ( self , version : Version ) -> bool : \"\"\"Checks if the set contains some `version` via the *contains* (`in`) operation. Returns: Whether the `version` is contained within the set. \"\"\" return self . contains ( version )","title":"__contains__()"},{"location":"reference/version_sets/#versions.version_sets.VersionSetProtocol.__and__","text":"Computes the intersection of self and version_set via the and ( & ) operation. This is equivalent to self.intersection(version_set) . Returns: Type Description VersionSet The set representing the intersection of self and version_set . Source code in versions/version_sets.py 164 165 166 167 168 169 170 171 172 173 def __and__ ( self , version_set : VersionSet ) -> VersionSet : \"\"\"Computes the *intersection* of `self` and `version_set` via the *and* (`&`) operation. This is equivalent to [`self.intersection(version_set)`] [versions.version_sets.VersionSetProtocol.intersection]. Returns: The set representing the *intersection* of `self` and `version_set`. \"\"\" return self . intersection ( version_set )","title":"__and__()"},{"location":"reference/version_sets/#versions.version_sets.VersionSetProtocol.__iand__","text":"Computes the intersection of self and version_set via the and-assign ( &= ) operation. This is equivalent to self.intersection(version_set) . Returns: Type Description VersionSet The set representing the intersection of self and version_set . Source code in versions/version_sets.py 175 176 177 178 179 180 181 182 183 184 185 def __iand__ ( self , version_set : VersionSet ) -> VersionSet : \"\"\"Computes the *intersection* of `self` and `version_set` via the *and-assign* (`&=`) operation. This is equivalent to [`self.intersection(version_set)`] [versions.version_sets.VersionSetProtocol.intersection]. Returns: The set representing the *intersection* of `self` and `version_set`. \"\"\" return self . intersection ( version_set )","title":"__iand__()"},{"location":"reference/version_sets/#versions.version_sets.VersionSetProtocol.__or__","text":"Computes the union of self and version_set via the or ( | ) operation. This is equivalent to self.union(version_set) . Returns: Type Description VersionSet The set representing the union of self and version_set . Source code in versions/version_sets.py 187 188 189 190 191 192 193 194 195 196 def __or__ ( self , version_set : VersionSet ) -> VersionSet : \"\"\"Computes the *union* of `self` and `version_set` via the *or* (`|`) operation. This is equivalent to [`self.union(version_set)`] [versions.version_sets.VersionSetProtocol.union]. Returns: The set representing the *union* of `self` and `version_set`. \"\"\" return self . union ( version_set )","title":"__or__()"},{"location":"reference/version_sets/#versions.version_sets.VersionSetProtocol.__ior__","text":"Computes the union of self and version_set via the or-assign ( |= ) operation. This is equivalent to self.union(version_set) . Returns: Type Description VersionSet The set representing the union of self and version_set . Source code in versions/version_sets.py 198 199 200 201 202 203 204 205 206 207 def __ior__ ( self , version_set : VersionSet ) -> VersionSet : \"\"\"Computes the *union* of `self` and `version_set` via the *or-assign* (`|=`) operation. This is equivalent to [`self.union(version_set)`] [versions.version_sets.VersionSetProtocol.union]. Returns: The set representing the *union* of `self` and `version_set`. \"\"\" return self . union ( version_set )","title":"__ior__()"},{"location":"reference/version_sets/#versions.version_sets.VersionSetProtocol.__sub__","text":"Computes the difference of self and version_set via the sub ( - ) operation. This is equivalent to self.difference(version_set) . Returns: Type Description VersionSet The set representing the difference of self and version_set . Source code in versions/version_sets.py 209 210 211 212 213 214 215 216 217 218 def __sub__ ( self , version_set : VersionSet ) -> VersionSet : \"\"\"Computes the *difference* of `self` and `version_set` via the *sub* (`-`) operation. This is equivalent to [`self.difference(version_set)`] [versions.version_sets.VersionSetProtocol.difference]. Returns: The set representing the *difference* of `self` and `version_set`. \"\"\" return self . difference ( version_set )","title":"__sub__()"},{"location":"reference/version_sets/#versions.version_sets.VersionSetProtocol.__isub__","text":"Computes the difference of self and version_set via the sub-assign ( -= ) operation. This is equivalent to self.difference(version_set) . Returns: Type Description VersionSet The set representing the difference of self and version_set . Source code in versions/version_sets.py 220 221 222 223 224 225 226 227 228 229 230 def __isub__ ( self , version_set : VersionSet ) -> VersionSet : \"\"\"Computes the *difference* of `self` and `version_set` via the *sub-assign* (`-=`) operation. This is equivalent to [`self.difference(version_set)`] [versions.version_sets.VersionSetProtocol.difference]. Returns: The set representing the *difference* of `self` and `version_set`. \"\"\" return self . difference ( version_set )","title":"__isub__()"},{"location":"reference/version_sets/#versions.version_sets.VersionSetProtocol.__xor__","text":"Computes the symmetric difference of self and version_set via the xor ( ^ ) operation. This is equivalent to self.symmetric_difference(version_set) . Returns: Type Description VersionSet The set representing the symmetric difference of self and version_set . Source code in versions/version_sets.py 232 233 234 235 236 237 238 239 240 241 242 def __xor__ ( self , version_set : VersionSet ) -> VersionSet : \"\"\"Computes the *symmetric difference* of `self` and `version_set` via the *xor* (`^`) operation. This is equivalent to [`self.symmetric_difference(version_set)`] [versions.version_sets.VersionSetProtocol.symmetric_difference]. Returns: The set representing the *symmetric difference* of `self` and `version_set`. \"\"\" return self . symmetric_difference ( version_set )","title":"__xor__()"},{"location":"reference/version_sets/#versions.version_sets.VersionSetProtocol.__ixor__","text":"Computes the symmetric difference of self and version_set via the xor-assign ( ^= ) operation. This is equivalent to self.symmetric_difference(version_set) . Returns: Type Description VersionSet The set representing the symmetric difference of self and version_set . Source code in versions/version_sets.py 244 245 246 247 248 249 250 251 252 253 254 def __ixor__ ( self , version_set : VersionSet ) -> VersionSet : \"\"\"Computes the *symmetric difference* of `self` and `version_set` via the *xor-assign* (`^=`) operation. This is equivalent to [`self.symmetric_difference(version_set)`] [versions.version_sets.VersionSetProtocol.symmetric_difference]. Returns: The set representing the *symmetric difference* of `self` and `version_set`. \"\"\" return self . symmetric_difference ( version_set )","title":"__ixor__()"},{"location":"reference/version_sets/#versions.version_sets.VersionSetProtocol.__negate__","text":"Computes the complement of self via the negate ( ~ ) operation. This is equivalent to self.complement() . Returns: Type Description VersionSet The set representing the complement of self . Source code in versions/version_sets.py 256 257 258 259 260 261 262 263 264 265 def __negate__ ( self ) -> VersionSet : \"\"\"Computes the *complement* of `self` via the *negate* (`~`) operation. This is equivalent to [`self.complement()`] [versions.version_sets.VersionSetProtocol.complement]. Returns: The set representing the *complement* of `self`. \"\"\" return self . complement ()","title":"__negate__()"},{"location":"reference/version_sets/#versions.version_sets.VersionEmpty","text":"Bases: Representation , ToString , VersionSetProtocol Represents empty version sets ( {} ). Source code in versions/version_sets.py 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 @frozen ( repr = False , order = False ) class VersionEmpty ( Representation , ToString , VersionSetProtocol ): \"\"\"Represents empty version sets (`{}`).\"\"\" def is_empty ( self ) -> Literal [ True ]: return True def is_universe ( self ) -> Literal [ False ]: return False def includes ( self , version_set : VersionSet ) -> bool : return version_set . is_empty () def intersects ( self , version_set : VersionSet ) -> Literal [ False ]: return False def contains ( self , version : Version ) -> Literal [ False ]: return False def intersection ( self : E , version_set : VersionSet ) -> E : return self def union ( self , version_set : S ) -> S : return version_set def difference ( self : E , version_set : VersionSet ) -> E : return self def symmetric_difference ( self , version_set : S ) -> S : return version_set def complement ( self ) -> VersionRange : return VersionRange () def to_string ( self ) -> str : return EMPTY_VERSION","title":"VersionEmpty"},{"location":"reference/version_sets/#versions.version_sets.VersionRange","text":"Bases: Representation , ToString , VersionRangeProtocol , VersionSetProtocol Represents version ranges ( (x, y) , (x, y] , [x, y) and [x, y] ). Source code in versions/version_sets.py 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 @frozen ( repr = False , eq = False , order = False ) class VersionRange ( Representation , ToString , VersionRangeProtocol , VersionSetProtocol ): \"\"\"Represents version ranges (`(x, y)`, `(x, y]`, `[x, y)` and `[x, y]`).\"\"\" min : Optional [ Version ] = None max : Optional [ Version ] = None include_min : bool = False include_max : bool = False def __attrs_post_init__ ( self ) -> None : if self . min is None : evolve_in_place ( self , include_min = False ) if self . max is None : evolve_in_place ( self , include_max = False ) if self . comparable_min > self . comparable_max : raise ValueError ( MIN_MAX_CONSTRAINT ) def is_empty ( self ) -> bool : return self . is_empty_or_point () and not self . is_closed () def is_point ( self ) -> bool : return self . is_empty_or_point () and self . is_closed () def is_universe ( self ) -> bool : return self . is_unbounded () @property def version ( self ) -> Version : version = self . min or self . max if version is None : raise ValueError ( RANGE_NOT_POINT ) if self . is_point (): return version raise ValueError ( RANGE_NOT_POINT ) def contains ( self , version : Version ) -> bool : comparable_min = self . comparable_min comparable_max = self . comparable_max if version < comparable_min : return False if self . exclude_min and version == comparable_min : return False if version > comparable_max : return False if self . exclude_max and version == comparable_max : return False return True accepts = contains def includes ( self , version_set : VersionSet ) -> bool : if is_version_empty ( version_set ): return True if is_version_point ( version_set ): return self . contains ( version_set . version ) if is_version_range ( version_set ): return not version_set . is_lower ( self ) and not version_set . is_higher ( self ) if is_version_union ( version_set ): return all ( self . includes ( item ) for item in version_set . items ) raise TypeError ( UNEXPECTED_VERSION_SET . format ( repr ( version_set ))) def intersects ( self , version_set : VersionSet ) -> bool : if is_version_empty ( version_set ): return False if is_version_point ( version_set ): return self . contains ( version_set . version ) if is_version_range ( version_set ): return self . intersects_range ( version_set ) if is_version_union ( version_set ): return any ( self . intersects ( item ) for item in version_set . items ) raise TypeError ( UNEXPECTED_VERSION_SET . format ( repr ( version_set ))) def intersects_range ( self , range : VersionRange ) -> bool : return not range . is_strictly_lower ( self ) and not range . is_strictly_higher ( self ) def intersection ( self , version_set : VersionSet ) -> VersionSet : if is_version_empty ( version_set ): return VersionEmpty () if is_version_point ( version_set ): return version_set . intersection ( self ) if is_version_range ( version_set ): if self . is_lower ( version_set ): if self . is_strictly_lower ( version_set ): return VersionEmpty () intersection_min = version_set . min intersection_include_min = version_set . include_min else : if self . is_strictly_higher ( version_set ): return VersionEmpty () intersection_min = self . min intersection_include_min = self . include_min if self . is_higher ( version_set ): intersection_max = version_set . max intersection_include_max = version_set . include_max else : intersection_max = self . max intersection_include_max = self . include_max # if we reached here, there is an actual range intersection = VersionRange ( intersection_min , intersection_max , intersection_include_min , intersection_include_max , ) if intersection . is_point (): return VersionPoint ( intersection . version ) return intersection if is_version_union ( version_set ): return version_set . intersection ( self ) raise TypeError ( UNEXPECTED_VERSION_SET . format ( repr ( version_set ))) def union ( self , version_set : VersionSet ) -> VersionSet : if is_version_empty ( version_set ): return self if is_version_point ( version_set ): version = version_set . version if self . contains ( version ): return self if version == self . min : return evolve ( self , include_min = True ) if version == self . max : return evolve ( self , include_max = True ) return VersionUnion . of ( self , version_set ) if is_version_range ( version_set ): if not self . is_adjacent ( version_set ) and not self . intersects ( version_set ): return VersionUnion . of ( self , version_set ) if self . is_lower ( version_set ): union_min = self . min union_include_min = self . include_min else : union_min = version_set . min union_include_min = version_set . include_min if self . is_higher ( version_set ): union_max = self . max union_include_max = self . include_max else : union_max = version_set . max union_include_max = version_set . include_max return VersionRange ( union_min , union_max , union_include_min , union_include_max , ) if is_version_union ( version_set ): return version_set . union ( self ) raise TypeError ( UNEXPECTED_VERSION_SET . format ( repr ( version_set ))) def difference ( self , version_set : VersionSet ) -> VersionSet : if is_version_empty ( version_set ): return self if is_version_point ( version_set ): version = version_set . version if not self . contains ( version ): return self if version == self . min : if self . exclude_min : return self return evolve ( self , include_min = False ) if version == self . max : if self . exclude_max : return self return evolve ( self , include_max = False ) return VersionUnion . of ( evolve ( self , max = version , include_max = False ), evolve ( self , min = version , include_min = False ), ) if is_version_range ( version_set ): if not self . intersects ( version_set ): return self before : Optional [ VersionItem ] if not self . is_lower ( version_set ): before = None elif self . min == version_set . min : before = VersionPoint ( self . min ) # type: ignore else : before = evolve ( self , max = version_set . min , include_max = version_set . exclude_min ) after : Optional [ VersionItem ] if not self . is_higher ( version_set ): after = None elif self . max == version_set . max : after = VersionPoint ( self . max ) # type: ignore else : after = evolve ( self , min = version_set . max , include_min = version_set . exclude_max ) if before is None and after is None : return VersionEmpty () if before is None : return after # type: ignore if after is None : return before # type: ignore return VersionUnion . of ( before , after ) if is_version_union ( version_set ): return VersionUnion . of_iterable ( self . difference_iterator ( version_set )) raise TypeError ( UNEXPECTED_VERSION_SET . format ( repr ( version_set ))) def difference_iterator ( self , version_union : VersionUnion ) -> Iterator [ VersionItem ]: current : VersionItem = self for item in version_union . items : if item . is_strictly_lower ( current ): continue if item . is_strictly_higher ( current ): break difference = current . difference ( item ) if is_version_union ( difference ): item , current = difference . items yield item if is_version_item ( difference ): current = difference yield current def complement ( self ) -> VersionSet : return VersionRange () . difference ( self ) def to_string_iterator ( self ) -> Iterator [ str ]: if self . is_empty (): yield EMPTY_VERSION return if self . is_point (): yield self . version . to_string () return if self . is_universe (): yield UNIVERSE_VERSION return min = self . min if min : min_type = OperatorType . GREATER_OR_EQUAL if self . include_min else OperatorType . GREATER min_operator = Operator ( min_type , min ) yield min_operator . to_string () max = self . max if max : max_type = OperatorType . LESS_OR_EQUAL if self . include_max else OperatorType . LESS max_operator = Operator ( max_type , max ) yield max_operator . to_string () def to_short_string_iterator ( self ) -> Iterator [ str ]: if self . is_empty (): yield EMPTY_VERSION return if self . is_point (): yield self . version . to_short_string () return if self . is_universe (): yield UNIVERSE_VERSION return min = self . min if min : min_type = OperatorType . GREATER_OR_EQUAL if self . include_min else OperatorType . GREATER min_operator = Operator ( min_type , min ) yield min_operator . to_short_string () max = self . max if max : max_type = OperatorType . LESS_OR_EQUAL if self . include_max else OperatorType . LESS max_operator = Operator ( max_type , max ) yield max_operator . to_short_string () def to_string ( self ) -> str : return concat_comma_space ( self . to_string_iterator ()) def to_short_string ( self ) -> str : return concat_comma ( self . to_short_string_iterator ())","title":"VersionRange"},{"location":"reference/version_sets/#versions.version_sets.VersionPoint","text":"Bases: Representation , ToString , VersionRangeProtocol , VersionSetProtocol Represents version points ( [v, v] aka {v} ). Source code in versions/version_sets.py 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 @frozen ( repr = False , eq = False , order = False ) class VersionPoint ( Representation , ToString , VersionRangeProtocol , VersionSetProtocol ): \"\"\"Represents version points (`[v, v]` aka `{v}`).\"\"\" version : Version @property def min ( self ) -> Optional [ Version ]: # type: ignore return self . version @property def max ( self ) -> Optional [ Version ]: # type: ignore return self . version @property def include_min ( self ) -> bool : # type: ignore return True @property def include_max ( self ) -> bool : # type: ignore return True def is_empty ( self ) -> bool : return False def is_point ( self ) -> bool : return True def is_universe ( self ) -> bool : return False def contains ( self , version : Version ) -> bool : # version = self.version.weaken(version) return self . version == version accepts = contains def includes ( self , version_set : VersionSet ) -> bool : return version_set . is_empty () or ( is_version_point ( version_set ) and self . contains ( version_set . version ) ) def intersects ( self , version_set : VersionSet ) -> bool : return version_set . contains ( self . version ) def intersection ( self , version_set : VersionSet ) -> VersionSet : return self if version_set . contains ( self . version ) else VersionEmpty () def union ( self , version_set : VersionSet ) -> VersionSet : if is_version_empty ( version_set ): return self if is_version_point ( version_set ): if self . contains ( version_set . version ): return self return VersionUnion . of ( self , version_set ) if version_set . contains ( self . version ): return version_set if is_version_range ( version_set ) or is_version_union ( version_set ): return VersionUnion . of ( self , version_set ) raise TypeError ( UNEXPECTED_VERSION_SET . format ( repr ( version_set ))) def difference ( self , version_set : VersionSet ) -> VersionSet : return VersionEmpty () if version_set . contains ( self . version ) else self def complement ( self ) -> VersionSet : return VersionRange () . difference ( self ) def to_string ( self ) -> str : return self . version . to_string () def to_short_string ( self ) -> str : return self . version . to_short_string ()","title":"VersionPoint"},{"location":"reference/version_sets/#versions.version_sets.VersionUnion","text":"Bases: Representation , ToString , Specification Represents version unions. Source code in versions/version_sets.py 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 @frozen ( repr = False , order = False ) class VersionUnion ( Representation , ToString , Specification ): \"\"\"Represents version unions.\"\"\" items : VersionItems = field () @items . validator def check_items ( self , attribute : Attribute [ VersionItems ], items : VersionItems ) -> None : check_items ( items ) @classmethod def extract ( cls , version_set : VersionSet ) -> Iterator [ VersionItem ]: if is_version_union ( version_set ): yield from version_set . items if is_version_item ( version_set ): yield version_set @classmethod def of ( cls , * version_sets : VersionSet ) -> VersionSet : return cls . of_iterable ( version_sets ) @classmethod def of_iterable ( cls , iterable : Iterable [ VersionSet ]) -> VersionSet : extracted = list ( flatten ( map ( cls . extract , iterable ))) if not extracted : return VersionEmpty () if any ( item . is_universe () for item in extracted ): return VersionRange () extracted . sort () merged : List [ VersionItem ] = [] for item in extracted : if not merged : merged . append ( item ) else : last_item = last ( merged ) if last_item . intersects ( item ) or last_item . is_adjacent ( item ): result = last_item . union ( item ) if is_version_item ( result ): set_last ( merged , result ) else : # pragma: no cover raise InternalError ( UNEXPECTED_UNION ) else : merged . append ( item ) if contains_only_item ( merged ): return first ( merged ) return cls ( tuple ( merged )) @property def exclude_version ( self ) -> Optional [ Version ]: complement = self . complement () return complement . version if is_version_point ( complement ) else None def is_empty ( self ) -> bool : return False def is_universe ( self ) -> bool : return False def contains ( self , version : Version ) -> bool : return any ( item . contains ( version ) for item in self . items ) accepts = contains def includes ( self , version_set : VersionSet ) -> bool : self_items = iter ( self . items ) items = self . extract ( version_set ) self_item = next_or_none ( self_items ) item = next_or_none ( items ) while self_item and item : if self_item . includes ( item ): item = next_or_none ( items ) else : self_item = next_or_none ( self_items ) return item is None # all items are covered def intersects ( self , version_set : VersionSet ) -> bool : self_items = iter ( self . items ) items = self . extract ( version_set ) self_item = next_or_none ( self_items ) item = next_or_none ( items ) while self_item and item : if self_item . intersects ( item ): return True if item . is_higher ( self_item ): self_item = next_or_none ( self_items ) else : item = next_or_none ( items ) return False # none of the items are allowed def intersection_iterator ( self , version_set : VersionSet ) -> Iterator [ VersionItem ]: self_items = iter ( self . items ) items = self . extract ( version_set ) self_item = next_or_none ( self_items ) item = next_or_none ( items ) while self_item and item : intersection = self_item . intersection ( item ) if is_version_item ( intersection ): yield intersection if item . is_higher ( self_item ): self_item = next_or_none ( self_items ) else : item = next_or_none ( items ) def intersection ( self , version_set : VersionSet ) -> VersionSet : return self . of_iterable ( self . intersection_iterator ( version_set )) def union ( self , version_set : VersionSet ) -> VersionSet : return self . of ( self , version_set ) def difference ( self , version_set : VersionSet ) -> VersionSet : items_difference = ItemsDifference ( iter ( self . items ), self . extract ( version_set )) return self . of_iterable ( items_difference . compute ()) def complement ( self ) -> VersionSet : return VersionRange () . difference ( self ) def to_string ( self ) -> str : exclude_version = self . exclude_version if exclude_version : operator = Operator ( OperatorType . NOT_EQUAL , exclude_version ) return operator . to_string () return concat_pipes_spaced ( item . to_string () for item in self . items ) def to_short_string ( self ) -> str : exclude_version = self . exclude_version if exclude_version : operator = Operator ( OperatorType . NOT_EQUAL , exclude_version ) return operator . to_short_string () return concat_pipes ( item . to_short_string () for item in self . items )","title":"VersionUnion"},{"location":"reference/version_sets/#versions.version_sets.is_version_empty","text":"Checks if an item is an instance of VersionEmpty . Returns: Type Description TypeGuard [ VersionEmpty ] Whether the item provided is an instance of VersionEmpty . Source code in versions/version_sets.py 268 269 270 271 272 273 274 275 def is_version_empty ( item : Any ) -> TypeGuard [ VersionEmpty ]: \"\"\"Checks if an `item` is an instance of [`VersionEmpty`][versions.version_sets.VersionEmpty]. Returns: Whether the `item` provided is an instance of [`VersionEmpty`][versions.version_sets.VersionEmpty]. \"\"\" return is_instance ( item , VersionEmpty )","title":"is_version_empty()"},{"location":"reference/version_sets/#versions.version_sets.is_version_point","text":"Checks if an item is an instance of VersionPoint . Returns: Type Description TypeGuard [ VersionPoint ] Whether the item provided is an instance of VersionPoint . Source code in versions/version_sets.py 278 279 280 281 282 283 284 285 def is_version_point ( item : Any ) -> TypeGuard [ VersionPoint ]: \"\"\"Checks if an `item` is an instance of [`VersionPoint`][versions.version_sets.VersionPoint]. Returns: Whether the `item` provided is an instance of [`VersionPoint`][versions.version_sets.VersionPoint]. \"\"\" return is_instance ( item , VersionPoint )","title":"is_version_point()"},{"location":"reference/version_sets/#versions.version_sets.is_version_range","text":"Checks if an item is an instance of VersionRange . Returns: Type Description TypeGuard [ VersionRange ] Whether the item provided is an instance of VersionRange . Source code in versions/version_sets.py 288 289 290 291 292 293 294 295 def is_version_range ( item : Any ) -> TypeGuard [ VersionRange ]: \"\"\"Checks if an `item` is an instance of [`VersionRange`][versions.version_sets.VersionRange]. Returns: Whether the `item` provided is an instance of [`VersionRange`][versions.version_sets.VersionRange]. \"\"\" return is_instance ( item , VersionRange )","title":"is_version_range()"},{"location":"reference/version_sets/#versions.version_sets.is_version_union","text":"Checks if an item is an instance of VersionUnion . Returns: Type Description TypeGuard [ VersionUnion ] Whether the item provided is an instance of VersionUnion . Source code in versions/version_sets.py 298 299 300 301 302 303 304 305 def is_version_union ( item : Any ) -> TypeGuard [ VersionUnion ]: \"\"\"Checks if an `item` is an instance of [`VersionUnion`][versions.version_sets.VersionUnion]. Returns: Whether the `item` provided is an instance of [`VersionUnion`][versions.version_sets.VersionUnion]. \"\"\" return is_instance ( item , VersionUnion )","title":"is_version_union()"},{"location":"reference/version_sets/#versions.version_sets.is_version_item","text":"Checks if an item is an instance of VersionItem . Returns: Type Description TypeGuard [ VersionItem ] Whether the item provided is an instance of VersionItem . Source code in versions/version_sets.py 308 309 310 311 312 313 314 315 def is_version_item ( item : Any ) -> TypeGuard [ VersionItem ]: \"\"\"Checks if an `item` is an instance of [`VersionItem`][versions.version_sets.VersionItem]. Returns: Whether the `item` provided is an instance of [`VersionItem`][versions.version_sets.VersionItem]. \"\"\" return is_instance ( item , VersionItemTypes )","title":"is_version_item()"},{"location":"reference/version_sets/#versions.version_sets.is_version_set","text":"Checks if an item is an instance of VersionSet . Returns: Type Description TypeGuard [ VersionSet ] Whether the item provided is an instance of VersionSet . Source code in versions/version_sets.py 318 319 320 321 322 323 324 325 def is_version_set ( item : Any ) -> TypeGuard [ VersionSet ]: \"\"\"Checks if an `item` is an instance of [`VersionSet`][versions.version_sets.VersionSet]. Returns: Whether the `item` provided is an instance of [`VersionSet`][versions.version_sets.VersionSet]. \"\"\" return is_instance ( item , VersionSetTypes )","title":"is_version_set()"}]}