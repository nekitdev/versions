{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"<code>versions</code>","text":"<p>Parsing, inspecting and specifying versions.</p>"},{"location":"#installing","title":"Installing","text":"<p>Python 3.7 or above is required.</p>"},{"location":"#pip","title":"pip","text":"<p>Installing the library with <code>pip</code> is quite simple:</p> <pre><code>$ pip install versions\n</code></pre> <p>Alternatively, the library can be installed from source:</p> <pre><code>$ git clone https://github.com/nekitdev/versions.git\n$ cd versions\n$ python -m pip install .\n</code></pre>"},{"location":"#poetry","title":"poetry","text":"<p>You can add <code>versions</code> as a dependency with the following command:</p> <pre><code>$ poetry add versions\n</code></pre> <p>Or by directly specifying it in the configuration like so:</p> <pre><code>[tool.poetry.dependencies]\nversions = \"^1.5.0\"\n</code></pre> <p>Alternatively, you can add it directly from the source:</p> <pre><code>[tool.poetry.dependencies.versions]\ngit = \"https://github.com/nekitdev/versions.git\"\n</code></pre>"},{"location":"#examples","title":"Examples","text":""},{"location":"#versions_1","title":"Versions","text":"<p><code>parse_version</code> is used to parse versions:</p> <pre><code>from versions import parse_version\n\nversion = parse_version(\"1.0.0-dev.1+build.1\")\n\nprint(version)  # 1.0.0-dev.1+build.1\n</code></pre>"},{"location":"#segments","title":"Segments","text":"<p>All version segments can be fetched with their respective names:</p> <pre><code>&gt;&gt;&gt; print(version.release)\n1.0.0\n&gt;&gt;&gt; version.release.parts\n(1, 0, 0)\n&gt;&gt;&gt; print(version.dev)\ndev.1\n&gt;&gt;&gt; (version.dev.phase, version.dev.value)\n(\"dev\", 1)\n&gt;&gt;&gt; print(version.local)\nbuild.1\n&gt;&gt;&gt; version.local.parts\n(\"build\", 1)\n</code></pre>"},{"location":"#comparison","title":"Comparison","text":"<p>Versions support total ordering:</p> <pre><code>&gt;&gt;&gt; v1 = parse_version(\"1.0.0\")\n&gt;&gt;&gt; v2 = parse_version(\"2.0.0\")\n&gt;&gt;&gt; v1 == v2\nFalse\n&gt;&gt;&gt; v1 != v2\nTrue\n&gt;&gt;&gt; v1 &gt;= v2\nFalse\n&gt;&gt;&gt; v1 &lt;= v2\nTrue\n&gt;&gt;&gt; v1 &gt; v2\nFalse\n&gt;&gt;&gt; v1 &lt; v2\nTrue\n</code></pre>"},{"location":"#specification","title":"Specification","text":"<p><code>versions</code> also supports specifying version requirements and matching version against them.</p> <p>Since versions support total ordering, they can be checked using version sets (via <code>parse_version_set</code>):</p> <pre><code>&gt;&gt;&gt; from versions import parse_version, parse_version_set\n&gt;&gt;&gt; version_set = parse_version_set(\"^1.0.0\")\n&gt;&gt;&gt; version_set\n&lt;VersionRange (&gt;= 1.0.0, &lt; 2.0.0)&gt;\n&gt;&gt;&gt; version = parse_version(\"1.3.0\")\n&gt;&gt;&gt; version.matches(version_set)\nTrue\n&gt;&gt;&gt; another = parse_version(\"2.2.0\")\n&gt;&gt;&gt; another.matches(version_set)\nFalse\n</code></pre> <p>Alternatively, one can use specifiers, which are similar to version sets, except they retain the structure of specifications given (via <code>parse_specifier</code>):</p> <pre><code>&gt;&gt;&gt; from versions import parse_specifier, parse_version\n&gt;&gt;&gt; specifier = parse_specifier(\"^1.0.0\")\n&gt;&gt;&gt; specifier\n&lt;SpecifierOne (^1.0.0)&gt;\n&gt;&gt;&gt; version = parse_version(\"1.3.0\")\n&gt;&gt;&gt; version.matches(specifier)\nTrue\n&gt;&gt;&gt; another = parse_version(\"2.2.0\")\n&gt;&gt;&gt; another.matches(specifier)\nFalse\n</code></pre>"},{"location":"#versioned","title":"Versioned","text":"<p><code>versions</code> allows users to access versions of items that have the <code>__version__</code> attribute:</p> <pre><code>&gt;&gt;&gt; from versions import get_version\n&gt;&gt;&gt; import versions\n&gt;&gt;&gt; get_version(versions)\n&lt;Version (1.5.0)&gt;\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>You can find the documentation here.</p>"},{"location":"#support","title":"Support","text":"<p>If you need support with the library, you can send an email or refer to the official Discord server.</p>"},{"location":"#changelog","title":"Changelog","text":"<p>You can find the changelog here.</p>"},{"location":"#security-policy","title":"Security Policy","text":"<p>You can find the Security Policy of <code>versions</code> here.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>If you are interested in contributing to <code>versions</code>, make sure to take a look at the Contributing Guide, as well as the Code of Conduct.</p>"},{"location":"#license","title":"License","text":"<p><code>versions</code> is licensed under the MIT License terms. See License for details.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#150-2023-05-21","title":"1.5.0 (2023-05-21)","text":""},{"location":"changelog/#internal","title":"Internal","text":"<ul> <li>Migrated to using <code>typing-aliases</code> library.</li> </ul>"},{"location":"changelog/#140-2023-05-18","title":"1.4.0 (2023-05-18)","text":"<p>Partial rewrite.</p>"},{"location":"changelog/#130-2022-10-23","title":"1.3.0 (2022-10-23)","text":""},{"location":"changelog/#changes","title":"Changes","text":"<ul> <li><code>OperatorType.DOUBLE_EQUAL</code> and <code>OperatorType.EQUAL</code> are now considered equal.</li> </ul>"},{"location":"changelog/#121-2022-09-17","title":"1.2.1 (2022-09-17)","text":"<p>No significant changes.</p>"},{"location":"changelog/#120-2022-09-17","title":"1.2.0 (2022-09-17)","text":""},{"location":"changelog/#features","title":"Features","text":"<ul> <li>Add <code>meta</code> module with python and library versions.   (#3)</li> </ul>"},{"location":"changelog/#110-2022-07-24","title":"1.1.0 (2022-07-24)","text":""},{"location":"changelog/#changes_1","title":"Changes","text":"<ul> <li>Export type guards, allowing their usage in public API.   (#1)</li> </ul>"},{"location":"changelog/#100-2022-07-24","title":"1.0.0 (2022-07-24)","text":"<p>Initial release.</p>"},{"location":"code_of_conduct/","title":"Code of Conduct","text":""},{"location":"code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall   community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances of   any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email address,   without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"code_of_conduct/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official email address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement to conduct@nekit.dev.</p> <p>All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"code_of_conduct/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"code_of_conduct/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"code_of_conduct/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"code_of_conduct/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"code_of_conduct/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://contributor-covenant.org/version/2/1/code_of_conduct.</p> <p>Community Impact Guidelines were inspired by Mozilla's Code of Conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://contributor-covenant.org/faq. Translations are available at https://contributor-covenant.org/translations.</p>"},{"location":"security/","title":"Security Policy","text":""},{"location":"security/#reporting","title":"Reporting","text":"<p>Thank you for taking the time to responsibly disclose any problems you find.</p> <p>Do not file public issues as they are open for everyone to see!</p> <p>All security vulnerabilities in <code>versions</code> should be reported by email to security@nekit.dev. Your report will be acknowledged within 24 hours, and you will receive a more detailed response within 48 hours indicating the next steps in handling your report.</p> <p>You can encrypt your report using our public key: <code>BB2D8194464001E0B9B60EB8741A1EAD20FFDE8A</code>. This key is also available on MIT's Key Server and reproduced below.</p> <p>After the initial reply to your report, the core team will try to keep you informed of the progress being made towards a fix and official announcement. These updates will be sent at least every five days. In reality, this is more likely to be every 24-48 hours.</p>"},{"location":"security/#disclosure-policy","title":"Disclosure Policy","text":"<p><code>versions</code> has a 5-step disclosure process:</p> <ol> <li> <p>The security report is received and is assigned a primary handler.    This person will coordinate the fix and release process.</p> </li> <li> <p>The problem is confirmed and a list of all affected versions is determined.</p> </li> <li> <p>Code is audited to find any potential similar problems.</p> </li> <li> <p>Fixes are prepared for all releases which are still under maintenance.    These fixes are not committed to the public repository but rather    held locally pending the announcement.</p> </li> <li> <p>On the embargo date, the changes are pushed to the public repository    and new builds are deployed.</p> </li> </ol> <p>This process can take some time, especially when coordination is required with maintainers of other projects. Every effort will be made to handle the issue in as timely a manner as possible, however it is important that we follow the release process above to ensure that the disclosure is handled in a consistent manner.</p>"},{"location":"security/#security-key","title":"Security Key","text":"<pre><code>-----BEGIN PGP PUBLIC KEY BLOCK-----\n\nmQINBGKJEuEBEAC37iPX5u8sN+DZQ8c4Of+85u/hboSqNLp7VtTGgr/d8RCFhGZk\n25ZwqGWeJbhnlPuzT6u96CZFRe3TMHYJR+A2NZBVjAQQjDRGbIGgaS6/9lvMLcRx\nD+hFQNPgwUTfPhSHIan+9EuYK/Bz+jyyIplwTrIBq1Mo0NG+cUNvAB+he22xhBQ7\ny/Xal+sapHfYedqywhYEQUgP94IGURIMiBlAB7nKW+qs7YiQBShBbfxxffMgK6W6\nsNNSybUQDqjj1AWkOBj5uizkA6FLF80xULypbhe1gbqsIt4d1Lj/mxI5zvj84wy5\noQ6QOpYlBUQwl8kqfszYaqKCviflA+riAFMAE8NVL+5BuVN0QSvQb6cRzIV1SL0p\nMCA6s2+plK/9K+JyR5yyjY7FxvatYNLW5LsubmS+YeBdO4l4A7YEElOGMexUb61H\n3ejlb/9UUrZ7hd09Hsi1J6nthrI26o0XBdB8UJ9QAdfoHWka3fgSgopBBcI+S3tU\niWGngFrUhiXcBS+0xHjrk4USKwFyFr8fmL4Y8Yu31ViHRFj6gVjC/PHP0apCnakB\nUEEMHnAQfztodH9o2ew2kew77+q9VblDGpb3BYaiptl4c6h6WBcEULpRfWERfB8H\nSt4L49Ob6CCNpVw9qgsDfNw2fFjUIsT6OGwJxhv9StIFW2JEhgxEvfHr1wARAQAB\ntC9OaWtpdGEgVGlraG9ub3YgKHNlY3VyaXR5KSA8c2VjdXJpdHlAbmVraXQuZGV2\nPokCUgQTAQgAPAIbAwIXgAIeBxYhBLstgZRGQAHgubYOuHQaHq0g/96KBQJiiR6G\nBQsJCAcCAyICAQYVCgkICwIEFgIDAQAKCRB0Gh6tIP/einfmD/9y69eqwjRfdmnW\ns0ph8Rh99JHtgA+zm1akRl+eymiqLuJwmZge7PPFb68Wj4lI6s1M1dIkyRuYMtIM\n3rEcMmGUlcVnPldx/wdcPyhYZDUXnYCK64dsloftrWFWoSr5a/AILyVh/L6Fkf+L\nRU9h3KPMXhLTyK127ZF5WuzpjSJms0hDMDV/idfiDeWn/VGaZz1Wiks4l8R9kisR\nLI3RKNR537f0KFS8jkqlI41Lj9XQTUdqMRp+eqi/zUMM7OZzKQg1ohDsLi4MR6wa\nbXIu7LeAp1M0XlB+MO09KOxR8i19ST89EapAp4gHprbG5hJyV3XHK4txcWHG0YjB\ng5/fOvytljf/ue5YGe5nQUcxucq6i4d6jsB66Gk/4nnKutlMG2ZtVyIZZZActPZ5\nqKI64HQJOpag+ERXwrv0optEhTC7RHOFRuZ4pCKuVjdJE9W7ZpAIAi8yHeVvpgJY\nglo+DqZH1/kLD1u2Jb/8yUuMeCYc3aBlfZswO6IeMFeXbPaMtIHzY5q7blIdKIAb\nYxS5KCYn8VHG6Nz8lFMu2z4jpH4QY9vTaxZnG3Xp23uxbP0pznih4DMiHIACyCBP\nWgRReZTCVU6Z9FvBq8t/hcrwli33lTa5hkuuzqcojn80+1g9st7DOzxVFtR2MoSS\nWkv8ss8apRyeLNZAM5M8v+AiiyVCrLkCDQRiiRLhARAApEJFgvQVDMYpuo754cRK\nWC/17DH1BQ9y78h/0MXmOOf/0MpzJBkPjn4++BdXQGoOCBleHrWmbtmfYLcQFmZ/\neiUzxFDS/pkC7aZUb+YA7JzcwZQP2yOhlMfFK0qCoQKw/45q+AkOUR+Z+VGExkM1\n5+PAcQ+7cQRiyina6/MG7FHAOcvuEwjiyt/0zBm3izeWmXL0Gngisl1jvd8bGn4T\nbK68q2d09NNHdXJ9UDFdGJ+FVIqJCyLyBl0ZfWazSkD/4ZNchdjFcSOzTTMvqWWn\n6i5awbVyMPZkKS88vRVwTtcjk4+hrzaIyNbTw7y55qQxFe0NEoj4SK+iMwCkax19\nnjGQeB8GqmieC+0WYUSt10xXZ6tDf6a9F2cg6zv1ZklOuYU9x8GYwU7zvhrGhvXU\nUn1ZtP/OaHoQsS/+AS7KJtm/NWHGsfjd8vwDirIoZ31D7X52QrN07NQ0H7+uqtDL\nc7BAhsLI1G/r9Kz0+P0nC/6bMWvQWiomB1BSwUTfXLkT0RoKZ3Yub8XMk46N9XKE\nRtTk5x0/rZ40uOg8wzT1GvwYFA4tpavAqLejOftE05lKXAb5tQhYRupZywzXM6HN\nDR7CbP1e26g0p8GAuz1aFny6cN8T3wTHHyYn7aQk7i1BboV8zFpVlF6EmoHNCZtG\nhkl28kYa0Yvu+9mw0SPNiIsAEQEAAYkCNgQYAQgAIBYhBLstgZRGQAHgubYOuHQa\nHq0g/96KBQJiiRLhAhsMAAoJEHQaHq0g/96KeCoP/3i3A629wvjPn7m3y7pTcV8p\nriTlH5OeXhg4jCORgJrgL4PSoeFCITA0u0djtcvctmCrHMsZe0hyH5+X+/B9Bsf6\neFQKWXLidqkxD/M6lnE6t34d17DvaWCP27MsS/f0u0FsLom11TTFgp4wGKZfRBNH\nvX5xuhjoYXYwZwWqCYyEXFTbsUTDce2oaqc7Yw/GmM3fCodLX0/0eYh5u2fiKA57\n7VuUWD74/TkgcEOMa/IZ/jPmJHuHOteaIJR0pYUvLQ1EJh3jI4LhmH8DqxoUrmKy\n8z2VM0iLIiev86EXM+yzqTpRIFnm6Ts+47L18rb9D5IUo68gr5B2bMKPOfvMVzdN\n/vw2RKdCVJ70nh3qqRis5RsJrn/3T8H1CQtuPvsAd/oB86YGWPpWBtpTyI+VBp+x\n+XR434K8D9QXFst73wTCnQwSX6j0sIotQC5GsPJEKky2Wijg3BlxqTxtYjLhwKWg\nx3e63TEw7IgU+lE/ybzWLJ7EndbKsC7stZh+Lyh5b3YHgI3cfJUxjZNFpniKr/Fy\n4EjjLZzFf3QRmNNJ/7VlYLYztGZsOWxRsLk7QfUPSZY4iHUr8aiwfL7IFwnAlzIo\n36HDjJi80UakMlf45UcxRaJwWiaj7G4x3h1D1BZLtMiypiaw/mesrithmfHg+KYu\n1oYi7ft0FnZ67Wnk5+E+\n=VRe2\n-----END PGP PUBLIC KEY BLOCK-----\n</code></pre>"},{"location":"security/#attribution","title":"Attribution","text":"<p>This Security Policy is adapted from Rust's Security Policy.</p>"},{"location":"reference/converters/","title":"Converters","text":""},{"location":"reference/converters/#versions.converters.version_set_from_specifier","title":"<code>version_set_from_specifier = specifier_to_version_set</code>  <code>module-attribute</code>","text":"<p>An alias of <code>specifier_to_version_set</code>.</p>"},{"location":"reference/converters/#versions.converters.specifier_from_version_set","title":"<code>specifier_from_version_set = version_set_to_specifier</code>  <code>module-attribute</code>","text":"<p>An alias of <code>version_set_to_specifier</code>.</p>"},{"location":"reference/converters/#versions.converters.simplify","title":"<code>simplify(specifier: Specifier) -&gt; Specifier</code>","text":"<p>Simplifies a <code>Specifier</code>.</p> <p>The simplification is accomplished through converting to the version set and back.</p> <p>Parameters:</p> Name Type Description Default <code>specifier</code> <code>Specifier</code> <p>The version specifier to simplify.</p> required <p>Returns:</p> Type Description <code>Specifier</code> <p>The simplified specifier.</p> Source code in <code>versions/converters_normal.py</code> <pre><code>def simplify(specifier: Specifier) -&gt; Specifier:\n\"\"\"Simplifies a [`Specifier`][versions.specifiers.Specifier].\n\n    The simplification is accomplished through converting to the version set and back.\n\n    Arguments:\n        specifier: The version specifier to simplify.\n\n    Returns:\n        The simplified specifier.\n    \"\"\"\n    return specifier_from_version_set(specifier_to_version_set(specifier))\n</code></pre>"},{"location":"reference/converters/#versions.converters.specifier_to_version_set","title":"<code>specifier_to_version_set(specifier: Specifier) -&gt; VersionSet</code>","text":"<p>Converts a <code>Specifier</code> to <code>VersionSet</code>.</p> <p>Parameters:</p> Name Type Description Default <code>specifier</code> <code>Specifier</code> <p>The version specifier to convert.</p> required <p>Returns:</p> Type Description <code>VersionSet</code> <p>The converted version set.</p> Source code in <code>versions/converters_normal.py</code> <pre><code>@cache\ndef specifier_to_version_set(specifier: Specifier) -&gt; VersionSet:\n\"\"\"Converts a [`Specifier`][versions.specifiers.Specifier]\n    to [`VersionSet`][versions.version_sets.VersionSet].\n\n    Arguments:\n        specifier: The version specifier to convert.\n\n    Returns:\n        The converted version set.\n    \"\"\"\n    if is_specifier_one(specifier):\n        return specifier.translate(specifier.version)\n\n    if is_specifier_never(specifier):\n        return EMPTY_SET\n\n    if is_specifier_always(specifier):\n        return UNIVERSAL_SET\n\n    if is_specifier_all(specifier):\n        return reduce(version_set_intersection, map(specifier_to_version_set, specifier.specifiers))\n\n    if is_specifier_any(specifier):\n        return reduce(version_set_union, map(specifier_to_version_set, specifier.specifiers))\n\n    raise TypeError(UNEXPECTED_SPECIFIER.format(repr(specifier)))\n</code></pre>"},{"location":"reference/converters/#versions.converters.version_set_to_specifier","title":"<code>version_set_to_specifier(version_set: VersionSet) -&gt; Specifier</code>","text":"<p>Converts a <code>VersionSet</code> to <code>Specifier</code>.</p> <p>Parameters:</p> Name Type Description Default <code>version_set</code> <code>VersionSet</code> <p>The version set to convert.</p> required <p>Returns:</p> Type Description <code>Specifier</code> <p>The converted version specifier.</p> Source code in <code>versions/converters_normal.py</code> <pre><code>@cache\ndef version_set_to_specifier(version_set: VersionSet) -&gt; Specifier:\n\"\"\"Converts a [`VersionSet`][versions.version_sets.VersionSet]\n    to [`Specifier`][versions.specifiers.Specifier].\n\n    Arguments:\n        version_set: The version set to convert.\n\n    Returns:\n        The converted version specifier.\n    \"\"\"\n    if is_version_empty(version_set):\n        return NEVER\n\n    if is_version_point(version_set):\n        return pin_version(version_set.version)\n\n    if is_version_range(version_set):\n        return try_range_simple(version_set) or try_range_unwrap(\n            version_set.min,\n            version_set.max,\n            version_set.include_min,\n            version_set.include_max,\n        )\n\n    if is_version_union(version_set):\n        return try_exclude_version(version_set) or SpecifierAny.of_iterable(\n            map(version_set_to_specifier, version_set.items)\n        )\n\n    raise TypeError(UNEXPECTED_VERSION_SET.format(repr(version_set)))\n</code></pre>"},{"location":"reference/errors/","title":"Errors","text":""},{"location":"reference/errors/#versions.errors.ParseError","title":"<code>ParseError</code>","text":"<p>         Bases: <code>ValueError</code></p> <p>Parsing has failed.</p> Source code in <code>versions/errors.py</code> <pre><code>class ParseError(ValueError):\n\"\"\"Parsing has failed.\"\"\"\n</code></pre>"},{"location":"reference/errors/#versions.errors.ParseSpecificationError","title":"<code>ParseSpecificationError</code>","text":"<p>         Bases: <code>ParseError</code></p> <p>Parsing a specification has failed.</p> Source code in <code>versions/errors.py</code> <pre><code>class ParseSpecificationError(ParseError):\n\"\"\"Parsing a specification has failed.\"\"\"\n</code></pre>"},{"location":"reference/errors/#versions.errors.ParseTagError","title":"<code>ParseTagError</code>","text":"<p>         Bases: <code>ParseError</code></p> <p>Parsing a version tag has failed.</p> Source code in <code>versions/errors.py</code> <pre><code>class ParseTagError(ParseError):\n\"\"\"Parsing a version tag has failed.\"\"\"\n</code></pre>"},{"location":"reference/errors/#versions.errors.ParseVersionError","title":"<code>ParseVersionError</code>","text":"<p>         Bases: <code>ParseError</code></p> <p>Parsing a version has failed.</p> Source code in <code>versions/errors.py</code> <pre><code>class ParseVersionError(ParseError):\n\"\"\"Parsing a version has failed.\"\"\"\n</code></pre>"},{"location":"reference/errors/#versions.errors.InternalError","title":"<code>InternalError</code>","text":"<p>         Bases: <code>RuntimeError</code></p> <p>An internal error has occurred.</p> Source code in <code>versions/errors.py</code> <pre><code>class InternalError(RuntimeError):\n\"\"\"An internal error has occurred.\"\"\"\n</code></pre>"},{"location":"reference/functions/","title":"Functions","text":""},{"location":"reference/functions/#versions.functions.parse_version","title":"<code>parse_version(string: str, version_type: Type[Version] = Version) -&gt; Version</code>","text":"<p>Parses a <code>string</code> into a version of <code>version_type</code>.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>The string to parse.</p> required <code>version_type</code> <code>Type[Version]</code> <p>The version type to use in conversion.</p> <code>Version</code> <p>Returns:</p> Type Description <code>Version</code> <p>The newly parsed <code>Version</code>.</p> Source code in <code>versions/functions.py</code> <pre><code>@cache\ndef parse_version(string: str, version_type: Type[Version] = Version) -&gt; Version:\n\"\"\"Parses a `string` into a version of `version_type`.\n\n    Arguments:\n        string: The string to parse.\n        version_type: The version type to use in conversion.\n\n    Returns:\n        The newly parsed [`Version`][versions.version.Version].\n    \"\"\"\n    return VersionParser(version_type).parse(string)\n</code></pre>"},{"location":"reference/functions/#versions.functions.parse_specifier","title":"<code>parse_specifier(string: str, version_type: Type[Version] = Version) -&gt; Specifier</code>","text":"<p>Parses a <code>string</code> into a version specifier with versions of <code>version_type</code>.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>The string to parse.</p> required <code>version_type</code> <code>Type[Version]</code> <p>The version type to use in conversion.</p> <code>Version</code> <p>Returns:</p> Type Description <code>Specifier</code> <p>The newly parsed <code>Specifier</code>.</p> Source code in <code>versions/functions.py</code> <pre><code>@cache\ndef parse_specifier(string: str, version_type: Type[Version] = Version) -&gt; Specifier:\n\"\"\"Parses a `string` into a version specifier with versions of `version_type`.\n\n    Arguments:\n        string: The string to parse.\n        version_type: The version type to use in conversion.\n\n    Returns:\n        The newly parsed [`Specifier`][versions.specifiers.Specifier].\n    \"\"\"\n    return SpecifierParser(VersionParser(version_type)).parse(string)\n</code></pre>"},{"location":"reference/functions/#versions.functions.parse_version_set","title":"<code>parse_version_set(string: str, version_type: Type[Version] = Version) -&gt; VersionSet</code>","text":"<p>Parses a <code>string</code> into a version set with versions of <code>version_type</code>.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>The string to parse.</p> required <code>version_type</code> <code>Type[Version]</code> <p>The version type to use in conversion.</p> <code>Version</code> <p>Returns:</p> Type Description <code>VersionSet</code> <p>The newly parsed <code>VersionSet</code>.</p> Source code in <code>versions/functions.py</code> <pre><code>@cache\ndef parse_version_set(string: str, version_type: Type[Version] = Version) -&gt; VersionSet:\n\"\"\"Parses a `string` into a version set with versions of `version_type`.\n\n    Arguments:\n        string: The string to parse.\n        version_type: The version type to use in conversion.\n\n    Returns:\n        The newly parsed [`VersionSet`][versions.version_sets.VersionSet].\n    \"\"\"\n    return VersionSetParser(SpecifierParser(VersionParser(version_type))).parse(string)\n</code></pre>"},{"location":"reference/meta/","title":"Meta","text":""},{"location":"reference/meta/#versions.meta.version_info","title":"<code>version_info = parse_version(version)</code>  <code>module-attribute</code>","text":"<p>The library version represented as a <code>Version</code>.</p>"},{"location":"reference/meta/#versions.meta.python_version_info","title":"<code>python_version_info = Version.from_parts(python_major, python_minor, python_micro)</code>  <code>module-attribute</code>","text":"<p>The python version represented as a <code>Version</code>.</p>"},{"location":"reference/operators/","title":"Operators","text":""},{"location":"reference/operators/#versions.operators.Matches","title":"<code>Matches = Binary[Version, Version, bool]</code>  <code>module-attribute</code>","text":"<p>The <code>(version, against) -&gt; bool</code> function.</p>"},{"location":"reference/operators/#versions.operators.PartialMatches","title":"<code>PartialMatches = Unary[Version, bool]</code>  <code>module-attribute</code>","text":"<p>The <code>(version) -&gt; bool</code> function.</p>"},{"location":"reference/operators/#versions.operators.Translate","title":"<code>Translate = Unary[Version, VersionSet]</code>  <code>module-attribute</code>","text":"<p>The <code>(version) -&gt; version_set</code> function.</p>"},{"location":"reference/operators/#versions.operators.OperatorType","title":"<code>OperatorType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Represents operator types.</p> Source code in <code>versions/operators.py</code> <pre><code>class OperatorType(Enum):\n\"\"\"Represents operator types.\"\"\"\n\n    # official constraints\n    TILDE_EQUAL = TILDE_EQUAL\n\"\"\"The binary `~=` operator.\"\"\"\n    DOUBLE_EQUAL = DOUBLE_EQUAL\n\"\"\"The binary `==` operator.\"\"\"\n    NOT_EQUAL = NOT_EQUAL\n\"\"\"The binary `!=` operator.\"\"\"\n    LESS = LESS\n\"\"\"The binary `&lt;` operator.\"\"\"\n    LESS_OR_EQUAL = LESS_OR_EQUAL\n\"\"\"The binary `&lt;=` operator.\"\"\"\n    GREATER = GREATER\n\"\"\"The binary `&gt;` operator.\"\"\"\n    GREATER_OR_EQUAL = GREATER_OR_EQUAL\n\"\"\"The binary `&gt;=` operator.\"\"\"\n    # additional constraints\n    CARET = CARET\n\"\"\"The unary `^` operator.\"\"\"\n    EQUAL = EQUAL\n\"\"\"The binary `=` operator.\"\"\"\n    TILDE = TILDE\n\"\"\"The unary `~` operator.\"\"\"\n    # wildcard constraints\n    WILDCARD_DOUBLE_EQUAL = WILDCARD_DOUBLE_EQUAL\n\"\"\"The wildcard binary `==*` operator.\"\"\"\n    WILDCARD_EQUAL = WILDCARD_EQUAL\n\"\"\"The wildcard binary `=*` operator.\"\"\"\n    WILDCARD_NOT_EQUAL = WILDCARD_NOT_EQUAL\n\"\"\"The wildcard binary `!=*` operator.\"\"\"\n\n    def is_tilde_equal(self) -&gt; bool:\n        return self is type(self).TILDE_EQUAL\n\n    def is_double_equal(self) -&gt; bool:\n        return self is type(self).DOUBLE_EQUAL\n\n    def is_not_equal(self) -&gt; bool:\n        return self is type(self).NOT_EQUAL\n\n    def is_less(self) -&gt; bool:\n        return self is type(self).LESS\n\n    def is_less_or_equal(self) -&gt; bool:\n        return self is type(self).LESS_OR_EQUAL\n\n    def is_greater(self) -&gt; bool:\n        return self is type(self).GREATER\n\n    def is_greater_or_equal(self) -&gt; bool:\n        return self is type(self).GREATER_OR_EQUAL\n\n    def is_caret(self) -&gt; bool:\n        return self is type(self).CARET\n\n    def is_equal(self) -&gt; bool:\n        return self is type(self).EQUAL\n\n    def is_tilde(self) -&gt; bool:\n        return self is type(self).TILDE\n\n    def is_wildcard_double_equal(self) -&gt; bool:\n        return self is type(self).WILDCARD_DOUBLE_EQUAL\n\n    def is_wildcard_equal(self) -&gt; bool:\n        return self is type(self).WILDCARD_EQUAL\n\n    def is_wildcard_not_equal(self) -&gt; bool:\n        return self is type(self).WILDCARD_NOT_EQUAL\n\n    def is_wildcard(self) -&gt; bool:\n\"\"\"Checks if an operator is *wildcard*.\n\n        Returns:\n            Whether the operator is *wildcard*.\n        \"\"\"\n        return self in WILDCARD\n\n    def in_equals(self) -&gt; bool:\n        return self in EQUALS\n\n    def in_wildcard_equals(self) -&gt; bool:\n        return self in WILDCARD_EQUALS\n\n    def is_unary(self) -&gt; bool:\n\"\"\"Checks if an operator is *unary*.\n\n        Returns:\n            Whether the operator is *unary*.\n        \"\"\"\n        return self in UNARY\n\n    def __eq__(self, other: Any) -&gt; bool:\n        if is_same_type(other, self):\n            return (\n                (self.in_equals() and other.in_equals())\n                or (self.in_wildcard_equals() and other.in_wildcard_equals())\n                or super().__eq__(other)\n            )\n\n        return NotImplemented  # pragma: no cover  # not tested\n\n    def __hash__(self) -&gt; int:\n        return super().__hash__()  # type: ignore\n\n    @property\n    def string(self) -&gt; str:\n        return wildcard_type(self.value)\n</code></pre>"},{"location":"reference/operators/#versions.operators.OperatorType.TILDE_EQUAL","title":"<code>TILDE_EQUAL = TILDE_EQUAL</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The binary <code>~=</code> operator.</p>"},{"location":"reference/operators/#versions.operators.OperatorType.DOUBLE_EQUAL","title":"<code>DOUBLE_EQUAL = DOUBLE_EQUAL</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The binary <code>==</code> operator.</p>"},{"location":"reference/operators/#versions.operators.OperatorType.NOT_EQUAL","title":"<code>NOT_EQUAL = NOT_EQUAL</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The binary <code>!=</code> operator.</p>"},{"location":"reference/operators/#versions.operators.OperatorType.LESS","title":"<code>LESS = LESS</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The binary <code>&lt;</code> operator.</p>"},{"location":"reference/operators/#versions.operators.OperatorType.LESS_OR_EQUAL","title":"<code>LESS_OR_EQUAL = LESS_OR_EQUAL</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The binary <code>&lt;=</code> operator.</p>"},{"location":"reference/operators/#versions.operators.OperatorType.GREATER","title":"<code>GREATER = GREATER</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The binary <code>&gt;</code> operator.</p>"},{"location":"reference/operators/#versions.operators.OperatorType.GREATER_OR_EQUAL","title":"<code>GREATER_OR_EQUAL = GREATER_OR_EQUAL</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The binary <code>&gt;=</code> operator.</p>"},{"location":"reference/operators/#versions.operators.OperatorType.CARET","title":"<code>CARET = CARET</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The unary <code>^</code> operator.</p>"},{"location":"reference/operators/#versions.operators.OperatorType.EQUAL","title":"<code>EQUAL = EQUAL</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The binary <code>=</code> operator.</p>"},{"location":"reference/operators/#versions.operators.OperatorType.TILDE","title":"<code>TILDE = TILDE</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The unary <code>~</code> operator.</p>"},{"location":"reference/operators/#versions.operators.OperatorType.WILDCARD_DOUBLE_EQUAL","title":"<code>WILDCARD_DOUBLE_EQUAL = WILDCARD_DOUBLE_EQUAL</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The wildcard binary <code>==*</code> operator.</p>"},{"location":"reference/operators/#versions.operators.OperatorType.WILDCARD_EQUAL","title":"<code>WILDCARD_EQUAL = WILDCARD_EQUAL</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The wildcard binary <code>=*</code> operator.</p>"},{"location":"reference/operators/#versions.operators.OperatorType.WILDCARD_NOT_EQUAL","title":"<code>WILDCARD_NOT_EQUAL = WILDCARD_NOT_EQUAL</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The wildcard binary <code>!=*</code> operator.</p>"},{"location":"reference/operators/#versions.operators.OperatorType.is_wildcard","title":"<code>is_wildcard() -&gt; bool</code>","text":"<p>Checks if an operator is wildcard.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the operator is wildcard.</p> Source code in <code>versions/operators.py</code> <pre><code>def is_wildcard(self) -&gt; bool:\n\"\"\"Checks if an operator is *wildcard*.\n\n    Returns:\n        Whether the operator is *wildcard*.\n    \"\"\"\n    return self in WILDCARD\n</code></pre>"},{"location":"reference/operators/#versions.operators.OperatorType.is_unary","title":"<code>is_unary() -&gt; bool</code>","text":"<p>Checks if an operator is unary.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the operator is unary.</p> Source code in <code>versions/operators.py</code> <pre><code>def is_unary(self) -&gt; bool:\n\"\"\"Checks if an operator is *unary*.\n\n    Returns:\n        Whether the operator is *unary*.\n    \"\"\"\n    return self in UNARY\n</code></pre>"},{"location":"reference/operators/#versions.operators.Operator","title":"<code>Operator</code>","text":"<p>         Bases: <code>Representation</code>, <code>ToString</code></p> <p>Represents operators.</p> Source code in <code>versions/operators.py</code> <pre><code>@frozen(repr=False)\nclass Operator(Representation, ToString):\n\"\"\"Represents operators.\"\"\"\n\n    type: OperatorType\n\"\"\"The operator type.\"\"\"\n\n    version: Version\n\"\"\"The operator version.\"\"\"\n\n    def validate(self) -&gt; None:\n        if self.type.is_tilde_equal():\n            if not self.version.last_index:\n                raise ValueError(CAN_NOT_USE_TILDE_EQUAL)\n\n    __attrs_post_init__ = validate\n\n    def is_tilde_equal(self) -&gt; bool:\n        return self.type.is_tilde_equal()\n\n    def is_double_equal(self) -&gt; bool:\n        return self.type.is_double_equal()\n\n    def is_not_equal(self) -&gt; bool:\n        return self.type.is_not_equal()\n\n    def is_less(self) -&gt; bool:\n        return self.type.is_less()\n\n    def is_less_or_equal(self) -&gt; bool:\n        return self.type.is_less_or_equal()\n\n    def is_greater(self) -&gt; bool:\n        return self.type.is_greater()\n\n    def is_greater_or_equal(self) -&gt; bool:\n        return self.type.is_greater_or_equal()\n\n    def is_caret(self) -&gt; bool:\n        return self.type.is_caret()\n\n    def is_equal(self) -&gt; bool:\n        return self.type.is_equal()\n\n    def is_tilde(self) -&gt; bool:\n        return self.type.is_tilde()\n\n    def is_wildcard_double_equal(self) -&gt; bool:\n        return self.type.is_wildcard_double_equal()\n\n    def is_wildcard_equal(self) -&gt; bool:\n        return self.type.is_wildcard_equal()\n\n    def is_wildcard_not_equal(self) -&gt; bool:\n        return self.type.is_wildcard_not_equal()\n\n    def is_unary(self) -&gt; bool:\n\"\"\"Checks if an operator is *unary*.\n\n        Returns:\n            Whether the operator is *unary*.\n        \"\"\"\n        return self.type.is_unary()\n\n    def is_wildcard(self) -&gt; bool:\n\"\"\"Checks if an operator is *wildcard*.\n\n        Returns:\n            Whether the operator is *wildcard*.\n        \"\"\"\n        return self.type.is_wildcard()\n\n    @classmethod\n    def tilde_equal(cls: Type[O], version: Version) -&gt; O:\n        return cls(OperatorType.TILDE_EQUAL, version)\n\n    @classmethod\n    def double_equal(cls: Type[O], version: Version) -&gt; O:\n        return cls(OperatorType.DOUBLE_EQUAL, version)\n\n    @classmethod\n    def not_equal(cls: Type[O], version: Version) -&gt; O:\n        return cls(OperatorType.NOT_EQUAL, version)\n\n    @classmethod\n    def less(cls: Type[O], version: Version) -&gt; O:\n        return cls(OperatorType.LESS, version)\n\n    @classmethod\n    def less_or_equal(cls: Type[O], version: Version) -&gt; O:\n        return cls(OperatorType.LESS_OR_EQUAL, version)\n\n    @classmethod\n    def greater(cls: Type[O], version: Version) -&gt; O:\n        return cls(OperatorType.GREATER, version)\n\n    @classmethod\n    def greater_or_equal(cls: Type[O], version: Version) -&gt; O:\n        return cls(OperatorType.GREATER_OR_EQUAL, version)\n\n    @classmethod\n    def caret(cls: Type[O], version: Version) -&gt; O:\n        return cls(OperatorType.CARET, version)\n\n    @classmethod\n    def equal(cls: Type[O], version: Version) -&gt; O:\n        return cls(OperatorType.EQUAL, version)\n\n    @classmethod\n    def tilde(cls: Type[O], version: Version) -&gt; O:\n        return cls(OperatorType.TILDE, version)\n\n    @classmethod\n    def wildcard_double_equal(cls: Type[O], version: Version) -&gt; O:\n        return cls(OperatorType.WILDCARD_DOUBLE_EQUAL, version)\n\n    @classmethod\n    def wildcard_equal(cls: Type[O], version: Version) -&gt; O:\n        return cls(OperatorType.WILDCARD_EQUAL, version)\n\n    @classmethod\n    def wildcard_not_equal(cls: Type[O], version: Version) -&gt; O:\n        return cls(OperatorType.WILDCARD_NOT_EQUAL, version)\n\n    @property\n    def matches_and_translate(self) -&gt; Tuple[Matches, Translate]:\n        return OPERATOR[self.type]\n\n    @property\n    def matches(self) -&gt; Matches:\n\"\"\"The `matches` function representing the operator.\"\"\"\n        matches, _translate = self.matches_and_translate\n\n        return matches\n\n    @property\n    def translate(self) -&gt; Translate:\n\"\"\"The `translate` function representing the operator.\"\"\"\n        _matches, translate = self.matches_and_translate\n\n        return translate\n\n    @property\n    def partial_matches(self) -&gt; PartialMatches:\n\"\"\"The partial `matches` function with\n        [`self.version`][versions.operators.Operator.version] as the `against` version.\n        \"\"\"\n        return partial_matches(self.matches, self.version)\n\n    def to_string(self) -&gt; str:\n\"\"\"Converts an [`Operator`][versions.operators.Operator] to its string representation.\n\n        Returns:\n            The operator string.\n        \"\"\"\n        string = self.version.to_string()\n\n        if self.is_wildcard():\n            string = wildcard_string(string)\n\n        if self.is_unary():\n            return concat_empty_args(self.type.string, string)\n\n        return concat_space_args(self.type.string, string)\n\n    def to_short_string(self) -&gt; str:\n\"\"\"Converts an [`Operator`][versions.operators.Operator]\n        to its *short* string representation.\n\n        Returns:\n            The *short* operator string.\n        \"\"\"\n        string = self.version.to_short_string()\n\n        if self.is_wildcard():\n            string = wildcard_string(string)\n\n        return concat_empty_args(self.type.string, string)\n</code></pre>"},{"location":"reference/operators/#versions.operators.Operator.type","title":"<code>type: OperatorType</code>  <code>instance-attribute</code>","text":"<p>The operator type.</p>"},{"location":"reference/operators/#versions.operators.Operator.version","title":"<code>version: Version</code>  <code>instance-attribute</code>","text":"<p>The operator version.</p>"},{"location":"reference/operators/#versions.operators.Operator.matches","title":"<code>matches: Matches</code>  <code>property</code>","text":"<p>The <code>matches</code> function representing the operator.</p>"},{"location":"reference/operators/#versions.operators.Operator.translate","title":"<code>translate: Translate</code>  <code>property</code>","text":"<p>The <code>translate</code> function representing the operator.</p>"},{"location":"reference/operators/#versions.operators.Operator.partial_matches","title":"<code>partial_matches: PartialMatches</code>  <code>property</code>","text":"<p>The partial <code>matches</code> function with <code>self.version</code> as the <code>against</code> version.</p>"},{"location":"reference/operators/#versions.operators.Operator.is_unary","title":"<code>is_unary() -&gt; bool</code>","text":"<p>Checks if an operator is unary.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the operator is unary.</p> Source code in <code>versions/operators.py</code> <pre><code>def is_unary(self) -&gt; bool:\n\"\"\"Checks if an operator is *unary*.\n\n    Returns:\n        Whether the operator is *unary*.\n    \"\"\"\n    return self.type.is_unary()\n</code></pre>"},{"location":"reference/operators/#versions.operators.Operator.is_wildcard","title":"<code>is_wildcard() -&gt; bool</code>","text":"<p>Checks if an operator is wildcard.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the operator is wildcard.</p> Source code in <code>versions/operators.py</code> <pre><code>def is_wildcard(self) -&gt; bool:\n\"\"\"Checks if an operator is *wildcard*.\n\n    Returns:\n        Whether the operator is *wildcard*.\n    \"\"\"\n    return self.type.is_wildcard()\n</code></pre>"},{"location":"reference/operators/#versions.operators.Operator.to_string","title":"<code>to_string() -&gt; str</code>","text":"<p>Converts an <code>Operator</code> to its string representation.</p> <p>Returns:</p> Type Description <code>str</code> <p>The operator string.</p> Source code in <code>versions/operators.py</code> <pre><code>def to_string(self) -&gt; str:\n\"\"\"Converts an [`Operator`][versions.operators.Operator] to its string representation.\n\n    Returns:\n        The operator string.\n    \"\"\"\n    string = self.version.to_string()\n\n    if self.is_wildcard():\n        string = wildcard_string(string)\n\n    if self.is_unary():\n        return concat_empty_args(self.type.string, string)\n\n    return concat_space_args(self.type.string, string)\n</code></pre>"},{"location":"reference/operators/#versions.operators.Operator.to_short_string","title":"<code>to_short_string() -&gt; str</code>","text":"<p>Converts an <code>Operator</code> to its short string representation.</p> <p>Returns:</p> Type Description <code>str</code> <p>The short operator string.</p> Source code in <code>versions/operators.py</code> <pre><code>def to_short_string(self) -&gt; str:\n\"\"\"Converts an [`Operator`][versions.operators.Operator]\n    to its *short* string representation.\n\n    Returns:\n        The *short* operator string.\n    \"\"\"\n    string = self.version.to_short_string()\n\n    if self.is_wildcard():\n        string = wildcard_string(string)\n\n    return concat_empty_args(self.type.string, string)\n</code></pre>"},{"location":"reference/operators/#versions.operators.next_caret_breaking","title":"<code>next_caret_breaking(version: V) -&gt; V</code>","text":"<p>Returns the next breaking version according to the caret (<code>^</code>) strategy.</p> <p>This function is slightly convoluted due to handling <code>0.x.y</code> and <code>0.0.z</code> versions.</p> <p>See <code>next_breaking</code> for more information.</p> Example <pre><code>&gt;&gt;&gt; from versions import next_caret_breaking, parse_version\n&gt;&gt;&gt; version = parse_version(\"1.0.0\")\n&gt;&gt;&gt; version\n&lt;Version (1.0.0)&gt;\n&gt;&gt;&gt; next_caret_breaking(version)\n&lt;Version (2.0.0)&gt;\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>V</code> <p>The version to find next breaking version of.</p> required <p>Returns:</p> Type Description <code>V</code> <p>The next breaking version according to the <code>version</code>.</p> Source code in <code>versions/operators.py</code> <pre><code>def next_caret_breaking(version: V) -&gt; V:\n\"\"\"Returns the next breaking version according to the *caret* (`^`) strategy.\n\n    This function is slightly convoluted due to handling `0.x.y` and `0.0.z` versions.\n\n    See [`next_breaking`][versions.version.Version.next_breaking] for more information.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; from versions import next_caret_breaking, parse_version\n        &gt;&gt;&gt; version = parse_version(\"1.0.0\")\n        &gt;&gt;&gt; version\n        &lt;Version (1.0.0)&gt;\n        &gt;&gt;&gt; next_caret_breaking(version)\n        &lt;Version (2.0.0)&gt;\n        ```\n\n    Arguments:\n        version: The version to find next breaking version of.\n\n    Returns:\n        The next breaking version according to the `version`.\n    \"\"\"\n    return version.next_breaking()\n</code></pre>"},{"location":"reference/operators/#versions.operators.next_tilde_equal_breaking","title":"<code>next_tilde_equal_breaking(version: V) -&gt; V</code>","text":"<p>Returns the next breaking version according to the tilde-equal (<code>~=</code>) strategy.</p> <p>This function simply bumps the second to last part of the release.</p> Example <pre><code>&gt;&gt;&gt; from versions import next_tilde_equal_breaking, parse_version\n&gt;&gt;&gt; version = parse_version(\"1.2.0\")\n&gt;&gt;&gt; version\n&lt;Version (1.2.0)&gt;\n&gt;&gt;&gt; next_tilde_equal_breaking(version)\n&lt;Version (1.3.0)&gt;\n</code></pre> <pre><code>&gt;&gt;&gt; invalid = parse_version(\"1\")\n&gt;&gt;&gt; next_tilde_equal_breaking(invalid)\nTraceback (most recent call last):\n  ...\nValueError: `~=` can not be used with with a single version segment\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>V</code> <p>The version to find the next breaking version of.</p> required <p>Returns:</p> Type Description <code>V</code> <p>The next breaking <code>Version</code> according to the <code>version</code>.</p> Source code in <code>versions/operators.py</code> <pre><code>def next_tilde_equal_breaking(version: V) -&gt; V:\n\"\"\"Returns the next breaking version according to the *tilde-equal* (`~=`) strategy.\n\n    This function simply bumps the second to last part of the release.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; from versions import next_tilde_equal_breaking, parse_version\n        &gt;&gt;&gt; version = parse_version(\"1.2.0\")\n        &gt;&gt;&gt; version\n        &lt;Version (1.2.0)&gt;\n        &gt;&gt;&gt; next_tilde_equal_breaking(version)\n        &lt;Version (1.3.0)&gt;\n        ```\n\n        ```python\n        &gt;&gt;&gt; invalid = parse_version(\"1\")\n        &gt;&gt;&gt; next_tilde_equal_breaking(invalid)\n        Traceback (most recent call last):\n          ...\n        ValueError: `~=` can not be used with with a single version segment\n        ```\n\n    Arguments:\n        version: The version to find the next breaking version of.\n\n    Returns:\n        The next breaking [`Version`][versions.version.Version] according to the `version`.\n    \"\"\"\n    index = version.last_index\n\n    if index:\n        return version.to_stable().next_at(index - 1)\n\n    raise ValueError(CAN_NOT_USE_TILDE_EQUAL)\n</code></pre>"},{"location":"reference/operators/#versions.operators.next_tilde_breaking","title":"<code>next_tilde_breaking(version: V) -&gt; V</code>","text":"<p>Returns the next breaking version according to the tilde (<code>~</code>) strategy.</p> <p>This function simply bumps the minor part of the release if it is present, otherwise the major part is bumped.</p> Example <pre><code>&gt;&gt;&gt; from versions import next_tilde_equal_breaking, parse_version\n&gt;&gt;&gt; version = parse_version(\"2.1.0\")\n&gt;&gt;&gt; version\n&lt;Version (2.1.0)&gt;\n&gt;&gt;&gt; next_tilde_breaking(version)\n&lt;Version (2.2.0)&gt;\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>V</code> <p>The version to find the next breaking version of.</p> required <p>Returns:</p> Type Description <code>V</code> <p>The next breaking <code>Version</code> according to the <code>version</code>.</p> Source code in <code>versions/operators.py</code> <pre><code>def next_tilde_breaking(version: V) -&gt; V:\n\"\"\"Returns the next breaking version according to the *tilde* (`~`) strategy.\n\n    This function simply bumps the minor part of the release\n    if it is present, otherwise the major part is bumped.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; from versions import next_tilde_equal_breaking, parse_version\n        &gt;&gt;&gt; version = parse_version(\"2.1.0\")\n        &gt;&gt;&gt; version\n        &lt;Version (2.1.0)&gt;\n        &gt;&gt;&gt; next_tilde_breaking(version)\n        &lt;Version (2.2.0)&gt;\n        ```\n\n    Arguments:\n        version: The version to find the next breaking version of.\n\n    Returns:\n        The next breaking [`Version`][versions.version.Version] according to the `version`.\n    \"\"\"\n    if version.has_minor():\n        return version.next_minor()\n\n    return version.next_major()\n</code></pre>"},{"location":"reference/operators/#versions.operators.next_wildcard_breaking","title":"<code>next_wildcard_breaking(version: V) -&gt; Optional[V]</code>","text":"<p>Returns the next breaking version according to the wildcard (<code>*</code>) strategy.</p> <p>There are three cases to handle:</p> <ul> <li> <p>If the wildcard is used within the pre-release tag of the version,   next breaking version has the same release with pre-release tag removed.   For example, <code>x.y.z-rc.*</code> is bumped to <code>x.y.z</code>.</p> </li> <li> <p>If the wildcard is used within the post-release tag of the version,   next breaking version has the last part of the release bumped.   For instance, <code>x.y.z-post.*</code> is bumped to <code>x.y.z'</code>, where <code>z' = z + 1</code>.</p> </li> <li> <p>Otherwise, the second to last part of the release is bumped.   For example, <code>x.y.*</code> is bumped to <code>x.y'.0</code>, where <code>y' = y + 1</code>.</p> </li> </ul> Note <p>This function returns <code>None</code> if the given version is <code>*</code>.</p> Example <pre><code>&gt;&gt;&gt; from versions import next_wildcard_breaking, parse_version\n&gt;&gt;&gt; version = parse_version(\"4.2.0\")\n&gt;&gt;&gt; version\n&lt;Version (4.2.0)&gt;\n&gt;&gt;&gt; next_wildcard_breaking(version)\n&lt;Version (4.3.0)&gt;\n&gt;&gt;&gt; other = parse_version(\"1.2.3-rc.0\")\n&gt;&gt;&gt; other\n&lt;Version (1.2.3-rc.0)&gt;\n&gt;&gt;&gt; next_wildcard_breaking(other)\n&lt;Version (1.2.3)&gt;\n&gt;&gt;&gt; another = parse_version(\"0.6.8-post.0\")\n&gt;&gt;&gt; another\n&lt;Version (0.6.8-post.0)&gt;\n&gt;&gt;&gt; next_wildcard_breaking(another)\n&lt;Version (0.6.9)&gt;  # nice\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>V</code> <p>The version to find the next breaking version of.</p> required <p>Returns:</p> Type Description <code>Optional[V]</code> <p>The next breaking <code>Version</code> according to the <code>version</code>, or <code>None</code>.</p> Source code in <code>versions/operators.py</code> <pre><code>def next_wildcard_breaking(version: V) -&gt; Optional[V]:\n\"\"\"Returns the next breaking version according to the *wildcard* (`*`) strategy.\n\n    There are three cases to handle:\n\n    - If the wildcard is used within the *pre-release* tag of the version,\n      next breaking version has the same release with *pre-release* tag removed.\n      For example, `x.y.z-rc.*` is bumped to `x.y.z`.\n\n    - If the wildcard is used within the *post-release* tag of the version,\n      next breaking version has the last part of the release bumped.\n      For instance, `x.y.z-post.*` is bumped to `x.y.z'`, where `z' = z + 1`.\n\n    - Otherwise, the second to last part of the release is bumped.\n      For example, `x.y.*` is bumped to `x.y'.0`, where `y' = y + 1`.\n\n    Note:\n        This function returns [`None`][None] if the given version is `*`.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; from versions import next_wildcard_breaking, parse_version\n        &gt;&gt;&gt; version = parse_version(\"4.2.0\")\n        &gt;&gt;&gt; version\n        &lt;Version (4.2.0)&gt;\n        &gt;&gt;&gt; next_wildcard_breaking(version)\n        &lt;Version (4.3.0)&gt;\n        &gt;&gt;&gt; other = parse_version(\"1.2.3-rc.0\")\n        &gt;&gt;&gt; other\n        &lt;Version (1.2.3-rc.0)&gt;\n        &gt;&gt;&gt; next_wildcard_breaking(other)\n        &lt;Version (1.2.3)&gt;\n        &gt;&gt;&gt; another = parse_version(\"0.6.8-post.0\")\n        &gt;&gt;&gt; another\n        &lt;Version (0.6.8-post.0)&gt;\n        &gt;&gt;&gt; next_wildcard_breaking(another)\n        &lt;Version (0.6.9)&gt;  # nice\n        ```\n\n    Arguments:\n        version: The version to find the next breaking version of.\n\n    Returns:\n        The next breaking [`Version`][versions.version.Version] according\n            to the `version`, or [`None`][None].\n    \"\"\"\n    index = version.last_index\n\n    if version.is_stable() and not version.is_post_release():\n        # the wildcard was used within the release segment\n\n        if not index:\n            return None\n\n        index -= 1\n\n    return version.next_at(index)  # this will take care of unstable releases\n</code></pre>"},{"location":"reference/operators/#versions.operators.matches_caret","title":"<code>matches_caret(version: Version, against: Version) -&gt; bool</code>","text":"<p>Checks if the <code>version</code> matches the caret (<code>^</code>) specification.</p> <p>This is equivalent to:</p> <pre><code>against &lt;= version &lt; next_caret_breaking(against)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>Version</code> <p>The version to check.</p> required <code>against</code> <code>Version</code> <p>The version to check the <code>version</code> against.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the <code>version</code> matches <code>against</code>.</p> Source code in <code>versions/operators.py</code> <pre><code>def matches_caret(version: Version, against: Version) -&gt; bool:\n\"\"\"Checks if the `version` matches the *caret* (`^`) specification.\n\n    This is equivalent to:\n\n    ```python\n    against &lt;= version &lt; next_caret_breaking(against)\n    ```\n\n    Arguments:\n        version: The version to check.\n        against: The version to check the `version` against.\n\n    Returns:\n        Whether the `version` matches `against`.\n    \"\"\"\n    return against &lt;= version &lt; next_caret_breaking(against)\n</code></pre>"},{"location":"reference/operators/#versions.operators.matches_tilde_equal","title":"<code>matches_tilde_equal(version: Version, against: Version) -&gt; bool</code>","text":"<p>Checks if the <code>version</code> matches the tilde-equal (<code>~=</code>) specification.</p> <p>This is equivalent to:</p> <pre><code>against &lt;= version &lt; next_tilde_equal_breaking(against)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>Version</code> <p>The version to check.</p> required <code>against</code> <code>Version</code> <p>The version to check the <code>version</code> against.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the <code>version</code> matches <code>against</code>.</p> Source code in <code>versions/operators.py</code> <pre><code>def matches_tilde_equal(version: Version, against: Version) -&gt; bool:\n\"\"\"Checks if the `version` matches the *tilde-equal* (`~=`) specification.\n\n    This is equivalent to:\n\n    ```python\n    against &lt;= version &lt; next_tilde_equal_breaking(against)\n    ```\n\n    Arguments:\n        version: The version to check.\n        against: The version to check the `version` against.\n\n    Returns:\n        Whether the `version` matches `against`.\n    \"\"\"\n    return against &lt;= version &lt; next_tilde_equal_breaking(against)\n</code></pre>"},{"location":"reference/operators/#versions.operators.matches_tilde","title":"<code>matches_tilde(version: Version, against: Version) -&gt; bool</code>","text":"<p>Checks if the <code>version</code> matches the tilde (<code>~</code>) specification.</p> <p>This is equivalent to:</p> <pre><code>against &lt;= version &lt; next_tilde_breaking(against)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>Version</code> <p>The version to check.</p> required <code>against</code> <code>Version</code> <p>The version to check the <code>version</code> against.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the <code>version</code> matches <code>against</code>.</p> Source code in <code>versions/operators.py</code> <pre><code>def matches_tilde(version: Version, against: Version) -&gt; bool:\n\"\"\"Checks if the `version` matches the *tilde* (`~`) specification.\n\n    This is equivalent to:\n\n    ```python\n    against &lt;= version &lt; next_tilde_breaking(against)\n    ```\n\n    Arguments:\n        version: The version to check.\n        against: The version to check the `version` against.\n\n    Returns:\n        Whether the `version` matches `against`.\n    \"\"\"\n    return against &lt;= version &lt; next_tilde_breaking(against)\n</code></pre>"},{"location":"reference/operators/#versions.operators.matches_equal","title":"<code>matches_equal(version: Version, against: Version) -&gt; bool</code>","text":"<p>Checks if the <code>version</code> matches the equal (<code>=</code>) specification.</p> <p>This is equivalent to:</p> <pre><code>version == against\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>Version</code> <p>The version to check.</p> required <code>against</code> <code>Version</code> <p>The version to check the <code>version</code> against.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the <code>version</code> matches <code>against</code>.</p> Source code in <code>versions/operators.py</code> <pre><code>def matches_equal(version: Version, against: Version) -&gt; bool:\n\"\"\"Checks if the `version` matches the *equal* (`=`) specification.\n\n    This is equivalent to:\n\n    ```python\n    version == against\n    ```\n\n    Arguments:\n        version: The version to check.\n        against: The version to check the `version` against.\n\n    Returns:\n        Whether the `version` matches `against`.\n    \"\"\"\n    return version == against\n</code></pre>"},{"location":"reference/operators/#versions.operators.matches_not_equal","title":"<code>matches_not_equal(version: Version, against: Version) -&gt; bool</code>","text":"<p>Checks if the <code>version</code> matches the not-equal (<code>!=</code>) specification.</p> <p>This is equivalent to:</p> <pre><code>version != against\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>Version</code> <p>The version to check.</p> required <code>against</code> <code>Version</code> <p>The version to check the <code>version</code> against.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the <code>version</code> matches <code>against</code>.</p> Source code in <code>versions/operators.py</code> <pre><code>def matches_not_equal(version: Version, against: Version) -&gt; bool:\n\"\"\"Checks if the `version` matches the *not-equal* (`!=`) specification.\n\n    This is equivalent to:\n\n    ```python\n    version != against\n    ```\n\n    Arguments:\n        version: The version to check.\n        against: The version to check the `version` against.\n\n    Returns:\n        Whether the `version` matches `against`.\n    \"\"\"\n    return version != against\n</code></pre>"},{"location":"reference/operators/#versions.operators.matches_less","title":"<code>matches_less(version: Version, against: Version) -&gt; bool</code>","text":"<p>Checks if the <code>version</code> matches the less (<code>&lt;</code>) specification.</p> <p>This is equivalent to:</p> <pre><code>version &lt; against\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>Version</code> <p>The version to check.</p> required <code>against</code> <code>Version</code> <p>The version to check the <code>version</code> against.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the <code>version</code> matches <code>against</code>.</p> Source code in <code>versions/operators.py</code> <pre><code>def matches_less(version: Version, against: Version) -&gt; bool:\n\"\"\"Checks if the `version` matches the *less* (`&lt;`) specification.\n\n    This is equivalent to:\n\n    ```python\n    version &lt; against\n    ```\n\n    Arguments:\n        version: The version to check.\n        against: The version to check the `version` against.\n\n    Returns:\n        Whether the `version` matches `against`.\n    \"\"\"\n\n    return version &lt; against\n</code></pre>"},{"location":"reference/operators/#versions.operators.matches_less_or_equal","title":"<code>matches_less_or_equal(version: Version, against: Version) -&gt; bool</code>","text":"<p>Checks if the <code>version</code> matches the less-or-equal (<code>&lt;=</code>) specification.</p> <p>This is equivalent to:</p> <pre><code>version &lt;= against\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>Version</code> <p>The version to check.</p> required <code>against</code> <code>Version</code> <p>The version to check the <code>version</code> against.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the <code>version</code> matches <code>against</code>.</p> Source code in <code>versions/operators.py</code> <pre><code>def matches_less_or_equal(version: Version, against: Version) -&gt; bool:\n\"\"\"Checks if the `version` matches the *less-or-equal* (`&lt;=`) specification.\n\n    This is equivalent to:\n\n    ```python\n    version &lt;= against\n    ```\n\n    Arguments:\n        version: The version to check.\n        against: The version to check the `version` against.\n\n    Returns:\n        Whether the `version` matches `against`.\n    \"\"\"\n    return version &lt;= against\n</code></pre>"},{"location":"reference/operators/#versions.operators.matches_greater","title":"<code>matches_greater(version: Version, against: Version) -&gt; bool</code>","text":"<p>Checks if the <code>version</code> matches the greater (<code>&gt;</code>) specification.</p> <p>This is equivalent to:</p> <pre><code>version &gt; against\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>Version</code> <p>The version to check.</p> required <code>against</code> <code>Version</code> <p>The version to check the <code>version</code> against.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the <code>version</code> matches <code>against</code>.</p> Source code in <code>versions/operators.py</code> <pre><code>def matches_greater(version: Version, against: Version) -&gt; bool:\n\"\"\"Checks if the `version` matches the *greater* (`&gt;`) specification.\n\n    This is equivalent to:\n\n    ```python\n    version &gt; against\n    ```\n\n    Arguments:\n        version: The version to check.\n        against: The version to check the `version` against.\n\n    Returns:\n        Whether the `version` matches `against`.\n    \"\"\"\n    return version &gt; against\n</code></pre>"},{"location":"reference/operators/#versions.operators.matches_greater_or_equal","title":"<code>matches_greater_or_equal(version: Version, against: Version) -&gt; bool</code>","text":"<p>Checks if the <code>version</code> matches the greater-or-equal (<code>&gt;=</code>) specification.</p> <p>This is equivalent to:</p> <pre><code>version &gt;= against\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>Version</code> <p>The version to check.</p> required <code>against</code> <code>Version</code> <p>The version to check the <code>version</code> against.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the <code>version</code> matches <code>against</code>.</p> Source code in <code>versions/operators.py</code> <pre><code>def matches_greater_or_equal(version: Version, against: Version) -&gt; bool:\n\"\"\"Checks if the `version` matches the *greater-or-equal* (`&gt;=`) specification.\n\n    This is equivalent to:\n\n    ```python\n    version &gt;= against\n    ```\n\n    Arguments:\n        version: The version to check.\n        against: The version to check the `version` against.\n\n    Returns:\n        Whether the `version` matches `against`.\n    \"\"\"\n    return version &gt;= against\n</code></pre>"},{"location":"reference/operators/#versions.operators.matches_wildcard_equal","title":"<code>matches_wildcard_equal(version: Version, against: Version) -&gt; bool</code>","text":"<p>Checks if the <code>version</code> matches the wildcard-equal (<code>=*</code>) specification.</p> <p>This is equivalent to:</p> <pre><code>wildcard = next_wildcard_breaking(against)\n\nwildcard is None or against &lt;= version &lt; wildcard\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>Version</code> <p>The version to check.</p> required <code>against</code> <code>Version</code> <p>The version to check the <code>version</code> against.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the <code>version</code> matches <code>against</code>.</p> Source code in <code>versions/operators.py</code> <pre><code>def matches_wildcard_equal(version: Version, against: Version) -&gt; bool:\n\"\"\"Checks if the `version` matches the *wildcard-equal* (`=*`) specification.\n\n    This is equivalent to:\n\n    ```python\n    wildcard = next_wildcard_breaking(against)\n\n    wildcard is None or against &lt;= version &lt; wildcard\n    ```\n\n    Arguments:\n        version: The version to check.\n        against: The version to check the `version` against.\n\n    Returns:\n        Whether the `version` matches `against`.\n    \"\"\"\n    wildcard = next_wildcard_breaking(against)\n\n    if wildcard is None:\n        return True\n\n    return against &lt;= version &lt; wildcard\n</code></pre>"},{"location":"reference/operators/#versions.operators.matches_wildcard_not_equal","title":"<code>matches_wildcard_not_equal(version: Version, against: Version) -&gt; bool</code>","text":"<p>Checks if the <code>version</code> matches the wildcard-not-equal (<code>!=*</code>) specification.</p> <p>This is equivalent to:</p> <pre><code>wildcard = next_wildcard_breaking(against)\n\nwildcard is not None and (version &lt; against or version &gt;= wildcard)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>Version</code> <p>The version to check.</p> required <code>against</code> <code>Version</code> <p>The version to check the <code>version</code> against.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the <code>version</code> matches <code>against</code>.</p> Source code in <code>versions/operators.py</code> <pre><code>def matches_wildcard_not_equal(version: Version, against: Version) -&gt; bool:\n\"\"\"Checks if the `version` matches the *wildcard-not-equal* (`!=*`) specification.\n\n    This is equivalent to:\n\n    ```python\n    wildcard = next_wildcard_breaking(against)\n\n    wildcard is not None and (version &lt; against or version &gt;= wildcard)\n    ```\n\n    Arguments:\n        version: The version to check.\n        against: The version to check the `version` against.\n\n    Returns:\n        Whether the `version` matches `against`.\n    \"\"\"\n    return not matches_wildcard_equal(version, against)\n</code></pre>"},{"location":"reference/operators/#versions.operators.translate_caret","title":"<code>translate_caret(version: Version) -&gt; VersionRange</code>","text":"<p>Translates the <code>version</code> into a version set according to the caret (<code>^</code>) strategy.</p> <p>This function returns the <code>[version, next_caret_breaking(version))</code> range.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>Version</code> <p>The version to translate.</p> required <p>Returns:</p> Type Description <code>VersionRange</code> <p>The version set representing the caret specification.</p> Source code in <code>versions/operators.py</code> <pre><code>def translate_caret(version: Version) -&gt; VersionRange:\n\"\"\"Translates the `version` into a version set according to the *caret* (`^`) strategy.\n\n    This function returns the `[version, next_caret_breaking(version))` range.\n\n    Arguments:\n        version: The version to translate.\n\n    Returns:\n        The version set representing the *caret* specification.\n    \"\"\"\n    return VersionRange(\n        min=version,\n        max=next_caret_breaking(version),\n        include_min=True,\n        include_max=False,\n    )\n</code></pre>"},{"location":"reference/operators/#versions.operators.translate_tilde_equal","title":"<code>translate_tilde_equal(version: Version) -&gt; VersionRange</code>","text":"<p>Translates the <code>version</code> into a version set according to the tilde-equal (<code>~=</code>) strategy.</p> <p>This function returns the <code>[version, next_tilde_equal_breaking(version))</code> range.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>Version</code> <p>The version to translate.</p> required <p>Returns:</p> Type Description <code>VersionRange</code> <p>The version set representing the tilde-equal specification.</p> Source code in <code>versions/operators.py</code> <pre><code>def translate_tilde_equal(version: Version) -&gt; VersionRange:\n\"\"\"Translates the `version` into a version set according to the *tilde-equal* (`~=`) strategy.\n\n    This function returns the `[version, next_tilde_equal_breaking(version))` range.\n\n    Arguments:\n        version: The version to translate.\n\n    Returns:\n        The version set representing the *tilde-equal* specification.\n    \"\"\"\n    return VersionRange(\n        min=version,\n        max=next_tilde_equal_breaking(version),\n        include_min=True,\n        include_max=False,\n    )\n</code></pre>"},{"location":"reference/operators/#versions.operators.translate_tilde","title":"<code>translate_tilde(version: Version) -&gt; VersionRange</code>","text":"<p>Translates the <code>version</code> into a version set according to the tilde (<code>~</code>) strategy.</p> <p>This function returns the <code>[version, next_tilde_breaking(version))</code> range.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>Version</code> <p>The version to translate.</p> required <p>Returns:</p> Type Description <code>VersionRange</code> <p>The version set representing the tilde-equal specification.</p> Source code in <code>versions/operators.py</code> <pre><code>def translate_tilde(version: Version) -&gt; VersionRange:\n\"\"\"Translates the `version` into a version set according to the *tilde* (`~`) strategy.\n\n    This function returns the `[version, next_tilde_breaking(version))` range.\n\n    Arguments:\n        version: The version to translate.\n\n    Returns:\n        The version set representing the *tilde-equal* specification.\n    \"\"\"\n    return VersionRange(\n        min=version,\n        max=next_tilde_breaking(version),\n        include_min=True,\n        include_max=False,\n    )\n</code></pre>"},{"location":"reference/operators/#versions.operators.translate_equal","title":"<code>translate_equal(version: Version) -&gt; VersionPoint</code>","text":"<p>Translates the <code>version</code> into a version set according to the equal (<code>=</code>) strategy.</p> <p>This function returns the <code>[version, version]</code> range (aka single <code>version</code>, <code>{version}</code>).</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>Version</code> <p>The version to translate.</p> required <p>Returns:</p> Type Description <code>VersionPoint</code> <p>The version set representing the equal specification.</p> Source code in <code>versions/operators.py</code> <pre><code>def translate_equal(version: Version) -&gt; VersionPoint:\n\"\"\"Translates the `version` into a version set according to the *equal* (`=`) strategy.\n\n    This function returns the `[version, version]` range (aka single `version`, `{version}`).\n\n    Arguments:\n        version: The version to translate.\n\n    Returns:\n        The version set representing the *equal* specification.\n    \"\"\"\n    return VersionPoint(version)\n</code></pre>"},{"location":"reference/operators/#versions.operators.translate_not_equal","title":"<code>translate_not_equal(version: Version) -&gt; VersionUnion</code>","text":"<p>Translates the <code>version</code> into a version set according to the not-equal (<code>!=</code>) strategy.</p> <p>This function returns the <code>(\u03b5, version) | (version, \u03c9)</code> union.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>Version</code> <p>The version to translate.</p> required <p>Returns:</p> Type Description <code>VersionUnion</code> <p>The version set representing the not-equal specification.</p> Source code in <code>versions/operators.py</code> <pre><code>def translate_not_equal(version: Version) -&gt; VersionUnion:\n\"\"\"Translates the `version` into a version set according to the *not-equal* (`!=`) strategy.\n\n    This function returns the `(\u03b5, version) | (version, \u03c9)` union.\n\n    Arguments:\n        version: The version to translate.\n\n    Returns:\n        The version set representing the *not-equal* specification.\n    \"\"\"\n    result = translate_equal(version).complement()\n\n    if is_version_union(result):\n        return result\n\n    raise InternalError(UNEXPECTED_EQUAL_COMPLEMENT)\n</code></pre>"},{"location":"reference/operators/#versions.operators.translate_less","title":"<code>translate_less(version: Version) -&gt; VersionRange</code>","text":"<p>Translates the <code>version</code> into a version set according to the less (<code>&lt;</code>) strategy.</p> <p>This function returns the <code>(\u03b5, version)</code> range.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>Version</code> <p>The version to translate.</p> required <p>Returns:</p> Type Description <code>VersionRange</code> <p>The version set representing the less specification.</p> Source code in <code>versions/operators.py</code> <pre><code>def translate_less(version: Version) -&gt; VersionRange:\n\"\"\"Translates the `version` into a version set according to the *less* (`&lt;`) strategy.\n\n    This function returns the `(\u03b5, version)` range.\n\n    Arguments:\n        version: The version to translate.\n\n    Returns:\n        The version set representing the *less* specification.\n    \"\"\"\n    return VersionRange(max=version, include_max=False)\n</code></pre>"},{"location":"reference/operators/#versions.operators.translate_less_or_equal","title":"<code>translate_less_or_equal(version: Version) -&gt; VersionRange</code>","text":"<p>Translates the <code>version</code> into a version set according to the less-or-equal (<code>&lt;=</code>) strategy.</p> <p>This function returns the <code>(\u03b5, version]</code> range.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>Version</code> <p>The version to translate.</p> required <p>Returns:</p> Type Description <code>VersionRange</code> <p>The version set representing the less-or-equal specification.</p> Source code in <code>versions/operators.py</code> <pre><code>def translate_less_or_equal(version: Version) -&gt; VersionRange:\n\"\"\"Translates the `version` into a version set according to the *less-or-equal* (`&lt;=`) strategy.\n\n    This function returns the `(\u03b5, version]` range.\n\n    Arguments:\n        version: The version to translate.\n\n    Returns:\n        The version set representing the *less-or-equal* specification.\n    \"\"\"\n    return VersionRange(max=version, include_max=True)\n</code></pre>"},{"location":"reference/operators/#versions.operators.translate_greater","title":"<code>translate_greater(version: Version) -&gt; VersionRange</code>","text":"<p>Translates the <code>version</code> into a version set according to the greater (<code>&gt;</code>) strategy.</p> <p>This function returns the <code>(version, \u03c9)</code> range.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>Version</code> <p>The version to translate.</p> required <p>Returns:</p> Type Description <code>VersionRange</code> <p>The version set representing the greater specification.</p> Source code in <code>versions/operators.py</code> <pre><code>def translate_greater(version: Version) -&gt; VersionRange:\n\"\"\"Translates the `version` into a version set according to the *greater* (`&gt;`) strategy.\n\n    This function returns the `(version, \u03c9)` range.\n\n    Arguments:\n        version: The version to translate.\n\n    Returns:\n        The version set representing the *greater* specification.\n    \"\"\"\n    return VersionRange(min=version, include_min=False)\n</code></pre>"},{"location":"reference/operators/#versions.operators.translate_greater_or_equal","title":"<code>translate_greater_or_equal(version: Version) -&gt; VersionRange</code>","text":"<p>Translates the <code>version</code> into a version set according to the greater-or-equal (<code>&gt;=</code>) strategy.</p> <p>This function returns the <code>[version, \u03c9)</code> range.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>Version</code> <p>The version to translate.</p> required <p>Returns:</p> Type Description <code>VersionRange</code> <p>The version set representing the greater-or-equal specification.</p> Source code in <code>versions/operators.py</code> <pre><code>def translate_greater_or_equal(version: Version) -&gt; VersionRange:\n\"\"\"Translates the `version` into a version set according to\n    the *greater-or-equal* (`&gt;=`) strategy.\n\n    This function returns the `[version, \u03c9)` range.\n\n    Arguments:\n        version: The version to translate.\n\n    Returns:\n        The version set representing the *greater-or-equal* specification.\n    \"\"\"\n    return VersionRange(min=version, include_min=True)\n</code></pre>"},{"location":"reference/operators/#versions.operators.translate_wildcard_equal","title":"<code>translate_wildcard_equal(version: Version) -&gt; VersionRange</code>","text":"<p>Translates the <code>version</code> into a version set according to the wildcard-equal (<code>==*</code>) strategy.</p> <p>This function returns the <code>[version, next_wildcard_version(version))</code> range in most cases, except for when the version is <code>*</code>; then the <code>(\u03b5, \u03c9)</code> range is returned.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>Version</code> <p>The version to translate.</p> required <p>Returns:</p> Type Description <code>VersionRange</code> <p>The version set representing the wildcard-equal specification.</p> Source code in <code>versions/operators.py</code> <pre><code>def translate_wildcard_equal(version: Version) -&gt; VersionRange:\n\"\"\"Translates the `version` into a version set according to\n    the *wildcard-equal* (`==*`) strategy.\n\n    This function returns the `[version, next_wildcard_version(version))` range in most cases,\n    except for when the version is `*`; then the `(\u03b5, \u03c9)` range is returned.\n\n    Arguments:\n        version: The version to translate.\n\n    Returns:\n        The version set representing the *wildcard-equal* specification.\n    \"\"\"\n    wildcard = next_wildcard_breaking(version)\n\n    if wildcard is None:\n        return VersionRange()\n\n    return VersionRange(min=version, max=wildcard, include_min=True, include_max=False)\n</code></pre>"},{"location":"reference/operators/#versions.operators.translate_wildcard_not_equal","title":"<code>translate_wildcard_not_equal(version: Version) -&gt; Union[VersionEmpty, VersionUnion]</code>","text":"<p>Translates the <code>version</code> into a version set according to the wildcard-not-equal (<code>!=*</code>) strategy.</p> <p>This function returns the <code>(\u03b5, version) | (next_wildcard_breaking(version), \u03c9)</code> union in most cases, except for when the version is <code>*</code>; then the <code>{}</code> empty set is returned.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>Version</code> <p>The version to translate.</p> required <p>Returns:</p> Type Description <code>Union[VersionEmpty, VersionUnion]</code> <p>The version set representing the wildcard-not-equal specification.</p> Source code in <code>versions/operators.py</code> <pre><code>def translate_wildcard_not_equal(version: Version) -&gt; Union[VersionEmpty, VersionUnion]:\n\"\"\"Translates the `version` into a version set according to\n    the *wildcard-not-equal* (`!=*`) strategy.\n\n    This function returns the `(\u03b5, version) | (next_wildcard_breaking(version), \u03c9)` union\n    in most cases, except for when the version is `*`; then the `{}` empty set is returned.\n\n    Arguments:\n        version: The version to translate.\n\n    Returns:\n        The version set representing the *wildcard-not-equal* specification.\n    \"\"\"\n    result = translate_wildcard_equal(version).complement()\n\n    if is_version_empty(result) or is_version_union(result):\n        return result\n\n    raise InternalError(UNEXPECTED_WILDCARD_EQUAL_COMPLEMENT)\n</code></pre>"},{"location":"reference/segments/","title":"Segments","text":""},{"location":"reference/segments/#versions.segments.DEFAULT_PARTS","title":"<code>DEFAULT_PARTS = (0, 0, 0)</code>  <code>module-attribute</code>","text":"<p>The default parts of the <code>Release</code>.</p>"},{"location":"reference/segments/#versions.segments.DEFAULT_VALUE","title":"<code>DEFAULT_VALUE = 0</code>  <code>module-attribute</code>","text":"<p>The default value to use.</p>"},{"location":"reference/segments/#versions.segments.DEFAULT_PADDING","title":"<code>DEFAULT_PADDING = 0</code>  <code>module-attribute</code>","text":"<p>The default padding to use.</p>"},{"location":"reference/segments/#versions.segments.Epoch","title":"<code>Epoch</code>","text":"<p>         Bases: <code>Representation</code>, <code>String</code></p> <p>Represents the epoch segment of the version (<code>e!</code>).</p> Source code in <code>versions/segments.py</code> <pre><code>@frozen(repr=False, eq=True, order=True)\nclass Epoch(Representation, String):\n\"\"\"Represents the *epoch* segment of the version (`e!`).\"\"\"\n\n    value: int = field(default=DEFAULT_VALUE)\n\"\"\"The value of the epoch.\"\"\"\n\n    def __bool__(self) -&gt; bool:\n        return bool(self.value)\n\n    @classmethod\n    def create(cls: Type[E], value: int = DEFAULT_VALUE) -&gt; E:\n\"\"\"Creates an [`Epoch`][versions.segments.Epoch] from `value`.\n\n        Arguments:\n            value: The value of the epoch.\n\n        Returns:\n            The newly created [`Epoch`][versions.segments.Epoch].\n        \"\"\"\n        return cls(value)\n\n    @classmethod\n    def from_string(cls: Type[E], string: str) -&gt; E:\n\"\"\"Parses an [`Epoch`][versions.segments.Epoch] from `string`.\n\n        Arguments:\n            string: The string to parse.\n\n        Returns:\n            The parsed epoch.\n        \"\"\"\n        return cls(int(string))\n\n    def to_string(self) -&gt; str:\n\"\"\"Converts an [`Epoch`][versions.segments.Epoch] to its string representation.\n\n        Returns:\n            The epoch string.\n        \"\"\"\n        return str(self.value)\n\n    def set_value(self: E, value: int) -&gt; E:\n        return evolve(self, value=value)\n\n    def next_value(self: E) -&gt; E:\n        return self.set_value(self.value + 1)\n</code></pre>"},{"location":"reference/segments/#versions.segments.Epoch.value","title":"<code>value: int = field(default=DEFAULT_VALUE)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The value of the epoch.</p>"},{"location":"reference/segments/#versions.segments.Epoch.create","title":"<code>create(value: int = DEFAULT_VALUE) -&gt; E</code>  <code>classmethod</code>","text":"<p>Creates an <code>Epoch</code> from <code>value</code>.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>The value of the epoch.</p> <code>DEFAULT_VALUE</code> <p>Returns:</p> Type Description <code>E</code> <p>The newly created <code>Epoch</code>.</p> Source code in <code>versions/segments.py</code> <pre><code>@classmethod\ndef create(cls: Type[E], value: int = DEFAULT_VALUE) -&gt; E:\n\"\"\"Creates an [`Epoch`][versions.segments.Epoch] from `value`.\n\n    Arguments:\n        value: The value of the epoch.\n\n    Returns:\n        The newly created [`Epoch`][versions.segments.Epoch].\n    \"\"\"\n    return cls(value)\n</code></pre>"},{"location":"reference/segments/#versions.segments.Epoch.from_string","title":"<code>from_string(string: str) -&gt; E</code>  <code>classmethod</code>","text":"<p>Parses an <code>Epoch</code> from <code>string</code>.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>The string to parse.</p> required <p>Returns:</p> Type Description <code>E</code> <p>The parsed epoch.</p> Source code in <code>versions/segments.py</code> <pre><code>@classmethod\ndef from_string(cls: Type[E], string: str) -&gt; E:\n\"\"\"Parses an [`Epoch`][versions.segments.Epoch] from `string`.\n\n    Arguments:\n        string: The string to parse.\n\n    Returns:\n        The parsed epoch.\n    \"\"\"\n    return cls(int(string))\n</code></pre>"},{"location":"reference/segments/#versions.segments.Epoch.to_string","title":"<code>to_string() -&gt; str</code>","text":"<p>Converts an <code>Epoch</code> to its string representation.</p> <p>Returns:</p> Type Description <code>str</code> <p>The epoch string.</p> Source code in <code>versions/segments.py</code> <pre><code>def to_string(self) -&gt; str:\n\"\"\"Converts an [`Epoch`][versions.segments.Epoch] to its string representation.\n\n    Returns:\n        The epoch string.\n    \"\"\"\n    return str(self.value)\n</code></pre>"},{"location":"reference/segments/#versions.segments.Release","title":"<code>Release</code>","text":"<p>         Bases: <code>Representation</code>, <code>String</code></p> <p>Represents the release segment of the version (<code>x.y.z</code>).</p> Source code in <code>versions/segments.py</code> <pre><code>@frozen(repr=False, eq=True, order=True)\nclass Release(Representation, String):\n\"\"\"Represents the *release* segment of the version (`x.y.z`).\"\"\"\n\n    parts: Parts = field(default=DEFAULT_PARTS, eq=False, order=False)\n\"\"\"The parts of the release.\"\"\"\n\n    compare_parts: Parts = field(repr=False, init=False, eq=True, order=True, hash=False)\n\n    @parts.validator\n    def check_parts(self, attribute: Attribute[Parts], value: Parts) -&gt; None:\n        if not value:\n            raise ValueError(EMPTY_RELEASE)\n\n    @compare_parts.default\n    def default_compare_parts(self) -&gt; Parts:\n        parts = self.parts\n\n        index = count_leading_zeros(reversed(parts))\n\n        if index == self.precision:\n            index -= 1  # preserve single zero if the version fully consists of zeros\n\n        return self.slice_parts(-index) if index else parts\n\n    @classmethod\n    def create(cls: Type[R], parts: Parts = DEFAULT_PARTS) -&gt; R:\n\"\"\"Creates a [`Release`][versions.segments.Release] from `parts`.\n\n        Arguments:\n            parts: The parts of the release.\n\n        Returns:\n            The newly created [`Release`][versions.segments.Release].\n        \"\"\"\n        return cls(parts)\n\n    @classmethod\n    def from_iterable(cls: Type[R], iterable: Iterable[int]) -&gt; R:\n\"\"\"Creates a [`Release`][versions.segments.Release] from `iterable`.\n\n        Arguments:\n            iterable: The parts of the release in an iterable.\n\n        Returns:\n            The newly created [`Release`][versions.segments.Release].\n        \"\"\"\n        return cls(tuple(iterable))\n\n    @classmethod\n    def from_parts(cls: Type[R], *parts: int) -&gt; R:\n\"\"\"Creates a [`Release`][versions.segments.Release] from `parts`.\n\n        Arguments:\n            *parts: The parts of the release.\n\n        Returns:\n            The newly created [`Release`][versions.segments.Release].\n        \"\"\"\n        return cls(parts)\n\n    def into_parts(self) -&gt; Parts:\n\"\"\"Converts a [`Release`][versions.segments.Release] to its parts.\n\n        Returns:\n            The parts of the release.\n        \"\"\"\n        return self.parts\n\n    def set_parts(self: R, *parts: int) -&gt; R:\n        return evolve(self, parts=parts)\n\n    @property\n    def precision(self) -&gt; int:\n\"\"\"The count of the release parts.\"\"\"\n        return len(self.parts)\n\n    @property\n    def last_index(self) -&gt; int:\n\"\"\"The index of the last release part.\"\"\"\n        return self.precision - 1\n\n    @property\n    def major(self) -&gt; int:\n\"\"\"The *major* part of the release.\"\"\"\n        return self.get_at(MAJOR)\n\n    @property\n    def minor(self) -&gt; int:\n\"\"\"The *minor* part of the release.\"\"\"\n        return self.get_at(MINOR)\n\n    @property\n    def micro(self) -&gt; int:\n\"\"\"The *micro* part of the release.\"\"\"\n        return self.get_at(MICRO)\n\n    @property\n    def patch(self) -&gt; int:\n\"\"\"The *patch* part of the release.\n\n        This is equivalent to [`micro`][versions.segments.Release.micro].\n        \"\"\"\n        return self.get_at(PATCH)\n\n    @property\n    def extra(self) -&gt; Extra:\n\"\"\"The *extra* parts of the release.\"\"\"\n        return self.parts[TOTAL:]\n\n    def get_at(self, index: int, default: int = DEFAULT_VALUE) -&gt; int:\n\"\"\"Gets the release part at the `index`, defaulting to `default`.\n\n        Arguments:\n            index: The index of the part to get.\n            default: The default value to use.\n\n        Returns:\n            The release part at `index` or the `default` value.\n        \"\"\"\n        return self.get_at_unchecked(index) if self.has_at(index) else default\n\n    def get_at_unchecked(self, index: int) -&gt; int:\n\"\"\"Gets the release part at the `index`.\n\n        Arguments:\n            index: The index of the part to get.\n\n        Raises:\n            IndexError: The index is *out-of-bounds*.\n\n        Returns:\n            The release part at `index`.\n        \"\"\"\n        return self.parts[index]\n\n    def is_semantic(self) -&gt; bool:\n\"\"\"Checks if the release matches the *semantic versioning* schema.\n\n        Returns:\n            Whether the release matches the [`semver`](https://semver.org/) schema.\n        \"\"\"\n        return self.precision == TOTAL\n\n    def to_semantic(self: R) -&gt; R:\n\"\"\"Converts the release to match the [`semver`](https://semver.org/) schema.\n\n        Returns:\n            The converted release.\n        \"\"\"\n        if self.has_extra():\n            return self.next_patch().slice(TOTAL)\n\n        return self if self.is_semantic() else self.pad_to(TOTAL)\n\n    def set_major(self: R, value: int) -&gt; R:\n\"\"\"Sets the *major* part of the release to the `value`.\n\n        Arguments:\n            value: The value to set the *major* part to.\n\n        Returns:\n            The updated release.\n        \"\"\"\n        return self.set_at(MAJOR, value)\n\n    def set_minor(self: R, value: int) -&gt; R:\n\"\"\"Sets the *minor* part of the release to the `value`.\n\n        Arguments:\n            value: The value to set the *minor* part to.\n\n        Returns:\n            The updated release.\n        \"\"\"\n        return self.set_at(MINOR, value)\n\n    def set_micro(self: R, value: int) -&gt; R:\n\"\"\"Sets the *micro* part of the release to the `value`.\n\n        Arguments:\n            value: The value to set the *micro* part to.\n\n        Returns:\n            The updated release.\n        \"\"\"\n        return self.set_at(MICRO, value)\n\n    def set_patch(self: R, value: int) -&gt; R:\n\"\"\"Sets the *patch* part of the release to the `value`.\n\n        This is equivalent to [`set_micro`][versions.segments.Release.set_micro].\n\n        Arguments:\n            value: The value to set the *patch* part to.\n\n        Returns:\n            The updated release.\n        \"\"\"\n        return self.set_at(PATCH, value)\n\n    def set_at(self: R, index: int, value: int) -&gt; R:\n\"\"\"Sets the release part at the `index` to the `value`.\n\n        Arguments:\n            index: The index to set the `value` at.\n            value: The value to set the part to.\n\n        Returns:\n            The updated release.\n        \"\"\"\n        return self.pad_to_index(index).set_at_unchecked(index, value)\n\n    def set_at_unchecked(self: R, index: int, value: int) -&gt; R:\n\"\"\"Sets the release part at the `index` to the `value`.\n\n        Arguments:\n            index: The index to set the `value` at.\n            value: The value to set the part to.\n\n        Raises:\n            IndexError: The index is *out-of-bounds*.\n\n        Returns:\n            The updated release.\n        \"\"\"\n        mutable = list(self.parts)\n        mutable[index] = value\n\n        return self.from_iterable(mutable)\n\n    def next_major(self: R) -&gt; R:\n\"\"\"Bumps the *major* part of the release.\n\n        Returns:\n            The bumped release.\n        \"\"\"\n        return self.next_at(MAJOR)\n\n    def next_minor(self: R) -&gt; R:\n\"\"\"Bumps the *minor* part of the release.\n\n        Returns:\n            The bumped release.\n        \"\"\"\n        return self.next_at(MINOR)\n\n    def next_micro(self: R) -&gt; R:\n\"\"\"Bumps the *micro* part of the release.\n\n        Returns:\n            The bumped release.\n        \"\"\"\n        return self.next_at(MICRO)\n\n    def next_patch(self: R) -&gt; R:\n\"\"\"Bumps the *patch* part of the release.\n\n        This is equivalent to [`next_micro`][versions.segments.Release.next_micro].\n\n        Returns:\n            The bumped release.\n        \"\"\"\n        return self.next_at(PATCH)\n\n    def next_at(self: R, index: int) -&gt; R:\n\"\"\"Bumps the part of the release at the `index`.\n\n        Arguments:\n            index: The index to bump the part at.\n\n        Returns:\n            The bumped release.\n        \"\"\"\n        updated = self.set_at(index, self.get_at(index) + 1)\n\n        return updated.slice(index + 1).pad_to(updated.precision)\n\n    def has_major(self) -&gt; bool:\n\"\"\"Checks if the release has the *major* part.\n\n        Returns:\n            Whether the *major* part is present.\n        \"\"\"\n        return self.has_at(MAJOR)\n\n    def has_minor(self) -&gt; bool:\n\"\"\"Checks if the release has the *minor* part.\n\n        Returns:\n            Whether the *minor* part is present.\n        \"\"\"\n        return self.has_at(MINOR)\n\n    def has_micro(self) -&gt; bool:\n\"\"\"Checks if the release has the *micro* part.\n\n        Returns:\n            Whether the *micro* part is present.\n        \"\"\"\n        return self.has_at(MICRO)\n\n    def has_patch(self) -&gt; bool:\n\"\"\"Checks if the release has the *patch* part.\n\n        This is equivalent to [`has_micro`][versions.segments.Release.has_micro].\n\n        Returns:\n            Whether the *patch* part is present.\n        \"\"\"\n        return self.has_at(PATCH)\n\n    def has_extra(self) -&gt; bool:\n\"\"\"Checks if the release has any *extra* parts.\n\n        Returns:\n            Whether the *extra* parts are present.\n        \"\"\"\n        return self.has_at(TOTAL)\n\n    def has_at(self, index: int) -&gt; bool:\n\"\"\"Checks if the release has a part at the `index`.\n\n        Returns:\n            Whether the part at the `index` is present.\n        \"\"\"\n        return self.precision &gt; index\n\n    def pad_to(self: R, length: int, padding: int = DEFAULT_PADDING) -&gt; R:\n\"\"\"Pads a [`Release`][versions.segments.Release] to the `length` with `padding`.\n\n        Arguments:\n            length: The length to pad the release to.\n            padding: The padding to use.\n\n        Returns:\n            The padded release.\n        \"\"\"\n        if self.precision &lt; length:\n            return self.from_iterable(fix_to_length(length, padding, self.parts))\n\n        return self\n\n    def pad_to_index(self: R, index: int, padding: int = DEFAULT_PADDING) -&gt; R:\n\"\"\"Pads a [`Release`][versions.segments.Release] to the `index` with `padding`.\n\n        Arguments:\n            index: The index to pad the release to.\n            padding: The padding to use.\n\n        Returns:\n            The padded release.\n        \"\"\"\n        return self.pad_to(index + 1, padding)\n\n    def pad_to_next(self: R, padding: int = DEFAULT_PADDING) -&gt; R:\n\"\"\"Pads a [`Release`][versions.segments.Release] to the next index.\n\n        Arguments:\n            padding: The padding to use.\n\n        Returns:\n            The padded release.\n        \"\"\"\n        return self.pad_to(self.precision + 1, padding)\n\n    def slice(self: R, index: int) -&gt; R:\n        return self.create(self.slice_parts(index))\n\n    def slice_parts(self, index: int) -&gt; Parts:\n        return self.parts[:index]\n\n    @classmethod\n    def from_string(cls: Type[R], string: str) -&gt; R:\n\"\"\"Parses a [`Release`][versions.segments.Release] from `string`.\n\n        Arguments:\n            string: The string to parse.\n\n        Returns:\n            The parsed release.\n        \"\"\"\n        return cls.from_iterable(map(int, split_dot(string)))\n\n    def to_string(self) -&gt; str:\n\"\"\"Converts a [`Release`][versions.segments.Release] to its string representation.\n\n        Returns:\n            The release string.\n        \"\"\"\n        return concat_dot(map(str, self.parts))\n</code></pre>"},{"location":"reference/segments/#versions.segments.Release.parts","title":"<code>parts: Parts = field(default=DEFAULT_PARTS, eq=False, order=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The parts of the release.</p>"},{"location":"reference/segments/#versions.segments.Release.precision","title":"<code>precision: int</code>  <code>property</code>","text":"<p>The count of the release parts.</p>"},{"location":"reference/segments/#versions.segments.Release.last_index","title":"<code>last_index: int</code>  <code>property</code>","text":"<p>The index of the last release part.</p>"},{"location":"reference/segments/#versions.segments.Release.major","title":"<code>major: int</code>  <code>property</code>","text":"<p>The major part of the release.</p>"},{"location":"reference/segments/#versions.segments.Release.minor","title":"<code>minor: int</code>  <code>property</code>","text":"<p>The minor part of the release.</p>"},{"location":"reference/segments/#versions.segments.Release.micro","title":"<code>micro: int</code>  <code>property</code>","text":"<p>The micro part of the release.</p>"},{"location":"reference/segments/#versions.segments.Release.patch","title":"<code>patch: int</code>  <code>property</code>","text":"<p>The patch part of the release.</p> <p>This is equivalent to <code>micro</code>.</p>"},{"location":"reference/segments/#versions.segments.Release.extra","title":"<code>extra: Extra</code>  <code>property</code>","text":"<p>The extra parts of the release.</p>"},{"location":"reference/segments/#versions.segments.Release.create","title":"<code>create(parts: Parts = DEFAULT_PARTS) -&gt; R</code>  <code>classmethod</code>","text":"<p>Creates a <code>Release</code> from <code>parts</code>.</p> <p>Parameters:</p> Name Type Description Default <code>parts</code> <code>Parts</code> <p>The parts of the release.</p> <code>DEFAULT_PARTS</code> <p>Returns:</p> Type Description <code>R</code> <p>The newly created <code>Release</code>.</p> Source code in <code>versions/segments.py</code> <pre><code>@classmethod\ndef create(cls: Type[R], parts: Parts = DEFAULT_PARTS) -&gt; R:\n\"\"\"Creates a [`Release`][versions.segments.Release] from `parts`.\n\n    Arguments:\n        parts: The parts of the release.\n\n    Returns:\n        The newly created [`Release`][versions.segments.Release].\n    \"\"\"\n    return cls(parts)\n</code></pre>"},{"location":"reference/segments/#versions.segments.Release.from_iterable","title":"<code>from_iterable(iterable: Iterable[int]) -&gt; R</code>  <code>classmethod</code>","text":"<p>Creates a <code>Release</code> from <code>iterable</code>.</p> <p>Parameters:</p> Name Type Description Default <code>iterable</code> <code>Iterable[int]</code> <p>The parts of the release in an iterable.</p> required <p>Returns:</p> Type Description <code>R</code> <p>The newly created <code>Release</code>.</p> Source code in <code>versions/segments.py</code> <pre><code>@classmethod\ndef from_iterable(cls: Type[R], iterable: Iterable[int]) -&gt; R:\n\"\"\"Creates a [`Release`][versions.segments.Release] from `iterable`.\n\n    Arguments:\n        iterable: The parts of the release in an iterable.\n\n    Returns:\n        The newly created [`Release`][versions.segments.Release].\n    \"\"\"\n    return cls(tuple(iterable))\n</code></pre>"},{"location":"reference/segments/#versions.segments.Release.from_parts","title":"<code>from_parts(*parts: int) -&gt; R</code>  <code>classmethod</code>","text":"<p>Creates a <code>Release</code> from <code>parts</code>.</p> <p>Parameters:</p> Name Type Description Default <code>*parts</code> <code>int</code> <p>The parts of the release.</p> <code>()</code> <p>Returns:</p> Type Description <code>R</code> <p>The newly created <code>Release</code>.</p> Source code in <code>versions/segments.py</code> <pre><code>@classmethod\ndef from_parts(cls: Type[R], *parts: int) -&gt; R:\n\"\"\"Creates a [`Release`][versions.segments.Release] from `parts`.\n\n    Arguments:\n        *parts: The parts of the release.\n\n    Returns:\n        The newly created [`Release`][versions.segments.Release].\n    \"\"\"\n    return cls(parts)\n</code></pre>"},{"location":"reference/segments/#versions.segments.Release.into_parts","title":"<code>into_parts() -&gt; Parts</code>","text":"<p>Converts a <code>Release</code> to its parts.</p> <p>Returns:</p> Type Description <code>Parts</code> <p>The parts of the release.</p> Source code in <code>versions/segments.py</code> <pre><code>def into_parts(self) -&gt; Parts:\n\"\"\"Converts a [`Release`][versions.segments.Release] to its parts.\n\n    Returns:\n        The parts of the release.\n    \"\"\"\n    return self.parts\n</code></pre>"},{"location":"reference/segments/#versions.segments.Release.get_at","title":"<code>get_at(index: int, default: int = DEFAULT_VALUE) -&gt; int</code>","text":"<p>Gets the release part at the <code>index</code>, defaulting to <code>default</code>.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index of the part to get.</p> required <code>default</code> <code>int</code> <p>The default value to use.</p> <code>DEFAULT_VALUE</code> <p>Returns:</p> Type Description <code>int</code> <p>The release part at <code>index</code> or the <code>default</code> value.</p> Source code in <code>versions/segments.py</code> <pre><code>def get_at(self, index: int, default: int = DEFAULT_VALUE) -&gt; int:\n\"\"\"Gets the release part at the `index`, defaulting to `default`.\n\n    Arguments:\n        index: The index of the part to get.\n        default: The default value to use.\n\n    Returns:\n        The release part at `index` or the `default` value.\n    \"\"\"\n    return self.get_at_unchecked(index) if self.has_at(index) else default\n</code></pre>"},{"location":"reference/segments/#versions.segments.Release.get_at_unchecked","title":"<code>get_at_unchecked(index: int) -&gt; int</code>","text":"<p>Gets the release part at the <code>index</code>.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index of the part to get.</p> required <p>Raises:</p> Type Description <code>IndexError</code> <p>The index is out-of-bounds.</p> <p>Returns:</p> Type Description <code>int</code> <p>The release part at <code>index</code>.</p> Source code in <code>versions/segments.py</code> <pre><code>def get_at_unchecked(self, index: int) -&gt; int:\n\"\"\"Gets the release part at the `index`.\n\n    Arguments:\n        index: The index of the part to get.\n\n    Raises:\n        IndexError: The index is *out-of-bounds*.\n\n    Returns:\n        The release part at `index`.\n    \"\"\"\n    return self.parts[index]\n</code></pre>"},{"location":"reference/segments/#versions.segments.Release.is_semantic","title":"<code>is_semantic() -&gt; bool</code>","text":"<p>Checks if the release matches the semantic versioning schema.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the release matches the <code>semver</code> schema.</p> Source code in <code>versions/segments.py</code> <pre><code>def is_semantic(self) -&gt; bool:\n\"\"\"Checks if the release matches the *semantic versioning* schema.\n\n    Returns:\n        Whether the release matches the [`semver`](https://semver.org/) schema.\n    \"\"\"\n    return self.precision == TOTAL\n</code></pre>"},{"location":"reference/segments/#versions.segments.Release.to_semantic","title":"<code>to_semantic() -&gt; R</code>","text":"<p>Converts the release to match the <code>semver</code> schema.</p> <p>Returns:</p> Type Description <code>R</code> <p>The converted release.</p> Source code in <code>versions/segments.py</code> <pre><code>def to_semantic(self: R) -&gt; R:\n\"\"\"Converts the release to match the [`semver`](https://semver.org/) schema.\n\n    Returns:\n        The converted release.\n    \"\"\"\n    if self.has_extra():\n        return self.next_patch().slice(TOTAL)\n\n    return self if self.is_semantic() else self.pad_to(TOTAL)\n</code></pre>"},{"location":"reference/segments/#versions.segments.Release.set_major","title":"<code>set_major(value: int) -&gt; R</code>","text":"<p>Sets the major part of the release to the <code>value</code>.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>The value to set the major part to.</p> required <p>Returns:</p> Type Description <code>R</code> <p>The updated release.</p> Source code in <code>versions/segments.py</code> <pre><code>def set_major(self: R, value: int) -&gt; R:\n\"\"\"Sets the *major* part of the release to the `value`.\n\n    Arguments:\n        value: The value to set the *major* part to.\n\n    Returns:\n        The updated release.\n    \"\"\"\n    return self.set_at(MAJOR, value)\n</code></pre>"},{"location":"reference/segments/#versions.segments.Release.set_minor","title":"<code>set_minor(value: int) -&gt; R</code>","text":"<p>Sets the minor part of the release to the <code>value</code>.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>The value to set the minor part to.</p> required <p>Returns:</p> Type Description <code>R</code> <p>The updated release.</p> Source code in <code>versions/segments.py</code> <pre><code>def set_minor(self: R, value: int) -&gt; R:\n\"\"\"Sets the *minor* part of the release to the `value`.\n\n    Arguments:\n        value: The value to set the *minor* part to.\n\n    Returns:\n        The updated release.\n    \"\"\"\n    return self.set_at(MINOR, value)\n</code></pre>"},{"location":"reference/segments/#versions.segments.Release.set_micro","title":"<code>set_micro(value: int) -&gt; R</code>","text":"<p>Sets the micro part of the release to the <code>value</code>.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>The value to set the micro part to.</p> required <p>Returns:</p> Type Description <code>R</code> <p>The updated release.</p> Source code in <code>versions/segments.py</code> <pre><code>def set_micro(self: R, value: int) -&gt; R:\n\"\"\"Sets the *micro* part of the release to the `value`.\n\n    Arguments:\n        value: The value to set the *micro* part to.\n\n    Returns:\n        The updated release.\n    \"\"\"\n    return self.set_at(MICRO, value)\n</code></pre>"},{"location":"reference/segments/#versions.segments.Release.set_patch","title":"<code>set_patch(value: int) -&gt; R</code>","text":"<p>Sets the patch part of the release to the <code>value</code>.</p> <p>This is equivalent to <code>set_micro</code>.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>The value to set the patch part to.</p> required <p>Returns:</p> Type Description <code>R</code> <p>The updated release.</p> Source code in <code>versions/segments.py</code> <pre><code>def set_patch(self: R, value: int) -&gt; R:\n\"\"\"Sets the *patch* part of the release to the `value`.\n\n    This is equivalent to [`set_micro`][versions.segments.Release.set_micro].\n\n    Arguments:\n        value: The value to set the *patch* part to.\n\n    Returns:\n        The updated release.\n    \"\"\"\n    return self.set_at(PATCH, value)\n</code></pre>"},{"location":"reference/segments/#versions.segments.Release.set_at","title":"<code>set_at(index: int, value: int) -&gt; R</code>","text":"<p>Sets the release part at the <code>index</code> to the <code>value</code>.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index to set the <code>value</code> at.</p> required <code>value</code> <code>int</code> <p>The value to set the part to.</p> required <p>Returns:</p> Type Description <code>R</code> <p>The updated release.</p> Source code in <code>versions/segments.py</code> <pre><code>def set_at(self: R, index: int, value: int) -&gt; R:\n\"\"\"Sets the release part at the `index` to the `value`.\n\n    Arguments:\n        index: The index to set the `value` at.\n        value: The value to set the part to.\n\n    Returns:\n        The updated release.\n    \"\"\"\n    return self.pad_to_index(index).set_at_unchecked(index, value)\n</code></pre>"},{"location":"reference/segments/#versions.segments.Release.set_at_unchecked","title":"<code>set_at_unchecked(index: int, value: int) -&gt; R</code>","text":"<p>Sets the release part at the <code>index</code> to the <code>value</code>.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index to set the <code>value</code> at.</p> required <code>value</code> <code>int</code> <p>The value to set the part to.</p> required <p>Raises:</p> Type Description <code>IndexError</code> <p>The index is out-of-bounds.</p> <p>Returns:</p> Type Description <code>R</code> <p>The updated release.</p> Source code in <code>versions/segments.py</code> <pre><code>def set_at_unchecked(self: R, index: int, value: int) -&gt; R:\n\"\"\"Sets the release part at the `index` to the `value`.\n\n    Arguments:\n        index: The index to set the `value` at.\n        value: The value to set the part to.\n\n    Raises:\n        IndexError: The index is *out-of-bounds*.\n\n    Returns:\n        The updated release.\n    \"\"\"\n    mutable = list(self.parts)\n    mutable[index] = value\n\n    return self.from_iterable(mutable)\n</code></pre>"},{"location":"reference/segments/#versions.segments.Release.next_major","title":"<code>next_major() -&gt; R</code>","text":"<p>Bumps the major part of the release.</p> <p>Returns:</p> Type Description <code>R</code> <p>The bumped release.</p> Source code in <code>versions/segments.py</code> <pre><code>def next_major(self: R) -&gt; R:\n\"\"\"Bumps the *major* part of the release.\n\n    Returns:\n        The bumped release.\n    \"\"\"\n    return self.next_at(MAJOR)\n</code></pre>"},{"location":"reference/segments/#versions.segments.Release.next_minor","title":"<code>next_minor() -&gt; R</code>","text":"<p>Bumps the minor part of the release.</p> <p>Returns:</p> Type Description <code>R</code> <p>The bumped release.</p> Source code in <code>versions/segments.py</code> <pre><code>def next_minor(self: R) -&gt; R:\n\"\"\"Bumps the *minor* part of the release.\n\n    Returns:\n        The bumped release.\n    \"\"\"\n    return self.next_at(MINOR)\n</code></pre>"},{"location":"reference/segments/#versions.segments.Release.next_micro","title":"<code>next_micro() -&gt; R</code>","text":"<p>Bumps the micro part of the release.</p> <p>Returns:</p> Type Description <code>R</code> <p>The bumped release.</p> Source code in <code>versions/segments.py</code> <pre><code>def next_micro(self: R) -&gt; R:\n\"\"\"Bumps the *micro* part of the release.\n\n    Returns:\n        The bumped release.\n    \"\"\"\n    return self.next_at(MICRO)\n</code></pre>"},{"location":"reference/segments/#versions.segments.Release.next_patch","title":"<code>next_patch() -&gt; R</code>","text":"<p>Bumps the patch part of the release.</p> <p>This is equivalent to <code>next_micro</code>.</p> <p>Returns:</p> Type Description <code>R</code> <p>The bumped release.</p> Source code in <code>versions/segments.py</code> <pre><code>def next_patch(self: R) -&gt; R:\n\"\"\"Bumps the *patch* part of the release.\n\n    This is equivalent to [`next_micro`][versions.segments.Release.next_micro].\n\n    Returns:\n        The bumped release.\n    \"\"\"\n    return self.next_at(PATCH)\n</code></pre>"},{"location":"reference/segments/#versions.segments.Release.next_at","title":"<code>next_at(index: int) -&gt; R</code>","text":"<p>Bumps the part of the release at the <code>index</code>.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index to bump the part at.</p> required <p>Returns:</p> Type Description <code>R</code> <p>The bumped release.</p> Source code in <code>versions/segments.py</code> <pre><code>def next_at(self: R, index: int) -&gt; R:\n\"\"\"Bumps the part of the release at the `index`.\n\n    Arguments:\n        index: The index to bump the part at.\n\n    Returns:\n        The bumped release.\n    \"\"\"\n    updated = self.set_at(index, self.get_at(index) + 1)\n\n    return updated.slice(index + 1).pad_to(updated.precision)\n</code></pre>"},{"location":"reference/segments/#versions.segments.Release.has_major","title":"<code>has_major() -&gt; bool</code>","text":"<p>Checks if the release has the major part.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the major part is present.</p> Source code in <code>versions/segments.py</code> <pre><code>def has_major(self) -&gt; bool:\n\"\"\"Checks if the release has the *major* part.\n\n    Returns:\n        Whether the *major* part is present.\n    \"\"\"\n    return self.has_at(MAJOR)\n</code></pre>"},{"location":"reference/segments/#versions.segments.Release.has_minor","title":"<code>has_minor() -&gt; bool</code>","text":"<p>Checks if the release has the minor part.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the minor part is present.</p> Source code in <code>versions/segments.py</code> <pre><code>def has_minor(self) -&gt; bool:\n\"\"\"Checks if the release has the *minor* part.\n\n    Returns:\n        Whether the *minor* part is present.\n    \"\"\"\n    return self.has_at(MINOR)\n</code></pre>"},{"location":"reference/segments/#versions.segments.Release.has_micro","title":"<code>has_micro() -&gt; bool</code>","text":"<p>Checks if the release has the micro part.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the micro part is present.</p> Source code in <code>versions/segments.py</code> <pre><code>def has_micro(self) -&gt; bool:\n\"\"\"Checks if the release has the *micro* part.\n\n    Returns:\n        Whether the *micro* part is present.\n    \"\"\"\n    return self.has_at(MICRO)\n</code></pre>"},{"location":"reference/segments/#versions.segments.Release.has_patch","title":"<code>has_patch() -&gt; bool</code>","text":"<p>Checks if the release has the patch part.</p> <p>This is equivalent to <code>has_micro</code>.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the patch part is present.</p> Source code in <code>versions/segments.py</code> <pre><code>def has_patch(self) -&gt; bool:\n\"\"\"Checks if the release has the *patch* part.\n\n    This is equivalent to [`has_micro`][versions.segments.Release.has_micro].\n\n    Returns:\n        Whether the *patch* part is present.\n    \"\"\"\n    return self.has_at(PATCH)\n</code></pre>"},{"location":"reference/segments/#versions.segments.Release.has_extra","title":"<code>has_extra() -&gt; bool</code>","text":"<p>Checks if the release has any extra parts.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the extra parts are present.</p> Source code in <code>versions/segments.py</code> <pre><code>def has_extra(self) -&gt; bool:\n\"\"\"Checks if the release has any *extra* parts.\n\n    Returns:\n        Whether the *extra* parts are present.\n    \"\"\"\n    return self.has_at(TOTAL)\n</code></pre>"},{"location":"reference/segments/#versions.segments.Release.has_at","title":"<code>has_at(index: int) -&gt; bool</code>","text":"<p>Checks if the release has a part at the <code>index</code>.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the part at the <code>index</code> is present.</p> Source code in <code>versions/segments.py</code> <pre><code>def has_at(self, index: int) -&gt; bool:\n\"\"\"Checks if the release has a part at the `index`.\n\n    Returns:\n        Whether the part at the `index` is present.\n    \"\"\"\n    return self.precision &gt; index\n</code></pre>"},{"location":"reference/segments/#versions.segments.Release.pad_to","title":"<code>pad_to(length: int, padding: int = DEFAULT_PADDING) -&gt; R</code>","text":"<p>Pads a <code>Release</code> to the <code>length</code> with <code>padding</code>.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>The length to pad the release to.</p> required <code>padding</code> <code>int</code> <p>The padding to use.</p> <code>DEFAULT_PADDING</code> <p>Returns:</p> Type Description <code>R</code> <p>The padded release.</p> Source code in <code>versions/segments.py</code> <pre><code>def pad_to(self: R, length: int, padding: int = DEFAULT_PADDING) -&gt; R:\n\"\"\"Pads a [`Release`][versions.segments.Release] to the `length` with `padding`.\n\n    Arguments:\n        length: The length to pad the release to.\n        padding: The padding to use.\n\n    Returns:\n        The padded release.\n    \"\"\"\n    if self.precision &lt; length:\n        return self.from_iterable(fix_to_length(length, padding, self.parts))\n\n    return self\n</code></pre>"},{"location":"reference/segments/#versions.segments.Release.pad_to_index","title":"<code>pad_to_index(index: int, padding: int = DEFAULT_PADDING) -&gt; R</code>","text":"<p>Pads a <code>Release</code> to the <code>index</code> with <code>padding</code>.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index to pad the release to.</p> required <code>padding</code> <code>int</code> <p>The padding to use.</p> <code>DEFAULT_PADDING</code> <p>Returns:</p> Type Description <code>R</code> <p>The padded release.</p> Source code in <code>versions/segments.py</code> <pre><code>def pad_to_index(self: R, index: int, padding: int = DEFAULT_PADDING) -&gt; R:\n\"\"\"Pads a [`Release`][versions.segments.Release] to the `index` with `padding`.\n\n    Arguments:\n        index: The index to pad the release to.\n        padding: The padding to use.\n\n    Returns:\n        The padded release.\n    \"\"\"\n    return self.pad_to(index + 1, padding)\n</code></pre>"},{"location":"reference/segments/#versions.segments.Release.pad_to_next","title":"<code>pad_to_next(padding: int = DEFAULT_PADDING) -&gt; R</code>","text":"<p>Pads a <code>Release</code> to the next index.</p> <p>Parameters:</p> Name Type Description Default <code>padding</code> <code>int</code> <p>The padding to use.</p> <code>DEFAULT_PADDING</code> <p>Returns:</p> Type Description <code>R</code> <p>The padded release.</p> Source code in <code>versions/segments.py</code> <pre><code>def pad_to_next(self: R, padding: int = DEFAULT_PADDING) -&gt; R:\n\"\"\"Pads a [`Release`][versions.segments.Release] to the next index.\n\n    Arguments:\n        padding: The padding to use.\n\n    Returns:\n        The padded release.\n    \"\"\"\n    return self.pad_to(self.precision + 1, padding)\n</code></pre>"},{"location":"reference/segments/#versions.segments.Release.from_string","title":"<code>from_string(string: str) -&gt; R</code>  <code>classmethod</code>","text":"<p>Parses a <code>Release</code> from <code>string</code>.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>The string to parse.</p> required <p>Returns:</p> Type Description <code>R</code> <p>The parsed release.</p> Source code in <code>versions/segments.py</code> <pre><code>@classmethod\ndef from_string(cls: Type[R], string: str) -&gt; R:\n\"\"\"Parses a [`Release`][versions.segments.Release] from `string`.\n\n    Arguments:\n        string: The string to parse.\n\n    Returns:\n        The parsed release.\n    \"\"\"\n    return cls.from_iterable(map(int, split_dot(string)))\n</code></pre>"},{"location":"reference/segments/#versions.segments.Release.to_string","title":"<code>to_string() -&gt; str</code>","text":"<p>Converts a <code>Release</code> to its string representation.</p> <p>Returns:</p> Type Description <code>str</code> <p>The release string.</p> Source code in <code>versions/segments.py</code> <pre><code>def to_string(self) -&gt; str:\n\"\"\"Converts a [`Release`][versions.segments.Release] to its string representation.\n\n    Returns:\n        The release string.\n    \"\"\"\n    return concat_dot(map(str, self.parts))\n</code></pre>"},{"location":"reference/segments/#versions.segments.Tag","title":"<code>Tag</code>","text":"<p>         Bases: <code>Representation</code>, <code>String</code></p> <p>Represents various version tags (<code>tag.n</code>).</p> Source code in <code>versions/segments.py</code> <pre><code>@frozen(repr=False, eq=True, order=True)\nclass Tag(Representation, String):\n\"\"\"Represents various version *tags* (`tag.n`).\"\"\"\n\n    DEFAULT_PHASE: ClassVar[str] = PHASE_ALL_DEFAULT\n    PHASE_SET: ClassVar[Set[str]] = PHASE_ALL_SET\n\n    phase: str = field(converter=convert_phase)\n\"\"\"The phase of the release tag.\"\"\"\n\n    value: int = field(default=DEFAULT_VALUE)\n\"\"\"The value of the release tag.\"\"\"\n\n    @phase.default\n    def default_phase(self) -&gt; str:\n        return self.DEFAULT_PHASE\n\n    @phase.validator\n    def check_phase(self, attribute: Attribute[str], value: str) -&gt; None:\n        if value not in self.PHASE_SET:\n            raise ValueError(PHASE_NOT_ALLOWED.format(value, get_type_name(self)))\n\n    @classmethod\n    def create(cls: Type[T], phase: Optional[str] = None, value: int = DEFAULT_VALUE) -&gt; T:\n\"\"\"Creates a [`Tag`][versions.segments.Tag] from `phase` and `value`.\n\n        Arguments:\n            phase: The phase of the tag.\n            value: The value of the tag.\n\n        Returns:\n            The newly created [`Tag`][versions.segments.Tag].\n        \"\"\"\n        if phase is None:\n            phase = cls.DEFAULT_PHASE\n\n        return cls(phase, value)\n\n    @classmethod\n    def default_phase_with_value(cls: Type[T], value: int) -&gt; T:\n\"\"\"Creates a [`Tag`][versions.segments.Tag] from `value` with the default phase.\n\n        Arguments:\n            value: The value of the tag.\n\n        Returns:\n            The newly created [`Tag`][versions.segments.Tag].\n        \"\"\"\n        return cls(cls.DEFAULT_PHASE, value)\n\n    @property\n    def short(self) -&gt; str:\n\"\"\"The *short* phase of the tag.\"\"\"\n        phase = self.phase\n\n        return PHASE_TO_SHORT.get(phase, phase)\n\n    @property\n    def normal(self) -&gt; str:\n\"\"\"The *normalized* phase of the tag.\"\"\"\n        phase = self.phase\n\n        return PHASE_TO_NORMAL.get(phase, phase)\n\n    def normalize(self: T) -&gt; T:\n\"\"\"Normalizes the version tag.\n\n        Returns:\n            The normalized tag.\n        \"\"\"\n        return self.set_phase(self.normal)\n\n    def set_phase(self: T, phase: str) -&gt; T:\n        return evolve(self, phase=phase)\n\n    def set_value(self: T, value: int) -&gt; T:\n        return evolve(self, value=value)\n\n    def next(self: T) -&gt; T:\n\"\"\"Bumps the version tag value.\n\n        Returns:\n            The next version tag.\n        \"\"\"\n        return self.set_value(self.value + 1)\n\n    def next_phase(self: T) -&gt; Optional[T]:\n\"\"\"Bumps the version tag phase, if possible.\n\n        Returns:\n            The next version tag, if present.\n        \"\"\"\n        phase = PHASE_TO_NEXT.get(self.phase)\n\n        return None if phase is None else self.create(phase)\n\n    @classmethod\n    def from_string(cls: Type[T], string: str) -&gt; T:\n\"\"\"Parses a [`Tag`][versions.segments.Tag] from `string`.\n\n        Arguments:\n            string: The string to parse.\n\n        Returns:\n            The parsed tag.\n        \"\"\"\n        return TagParser(cls).parse(string)\n\n    def to_string(self) -&gt; str:\n\"\"\"Converts a [`Tag`][versions.segments.Tag] to its string representation.\n\n        Returns:\n            The tag string.\n        \"\"\"\n        return concat_dot_args(self.phase, str(self.value))\n\n    def to_short_string(self) -&gt; str:\n\"\"\"Converts a [`Tag`][versions.segments.Tag] to its *short* string representation.\n\n        Returns:\n            The *short* tag string.\n        \"\"\"\n        return concat_empty_args(self.short, str(self.value))\n</code></pre>"},{"location":"reference/segments/#versions.segments.Tag.phase","title":"<code>phase: str = field(converter=convert_phase)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The phase of the release tag.</p>"},{"location":"reference/segments/#versions.segments.Tag.value","title":"<code>value: int = field(default=DEFAULT_VALUE)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The value of the release tag.</p>"},{"location":"reference/segments/#versions.segments.Tag.short","title":"<code>short: str</code>  <code>property</code>","text":"<p>The short phase of the tag.</p>"},{"location":"reference/segments/#versions.segments.Tag.normal","title":"<code>normal: str</code>  <code>property</code>","text":"<p>The normalized phase of the tag.</p>"},{"location":"reference/segments/#versions.segments.Tag.create","title":"<code>create(phase: Optional[str] = None, value: int = DEFAULT_VALUE) -&gt; T</code>  <code>classmethod</code>","text":"<p>Creates a <code>Tag</code> from <code>phase</code> and <code>value</code>.</p> <p>Parameters:</p> Name Type Description Default <code>phase</code> <code>Optional[str]</code> <p>The phase of the tag.</p> <code>None</code> <code>value</code> <code>int</code> <p>The value of the tag.</p> <code>DEFAULT_VALUE</code> <p>Returns:</p> Type Description <code>T</code> <p>The newly created <code>Tag</code>.</p> Source code in <code>versions/segments.py</code> <pre><code>@classmethod\ndef create(cls: Type[T], phase: Optional[str] = None, value: int = DEFAULT_VALUE) -&gt; T:\n\"\"\"Creates a [`Tag`][versions.segments.Tag] from `phase` and `value`.\n\n    Arguments:\n        phase: The phase of the tag.\n        value: The value of the tag.\n\n    Returns:\n        The newly created [`Tag`][versions.segments.Tag].\n    \"\"\"\n    if phase is None:\n        phase = cls.DEFAULT_PHASE\n\n    return cls(phase, value)\n</code></pre>"},{"location":"reference/segments/#versions.segments.Tag.default_phase_with_value","title":"<code>default_phase_with_value(value: int) -&gt; T</code>  <code>classmethod</code>","text":"<p>Creates a <code>Tag</code> from <code>value</code> with the default phase.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>The value of the tag.</p> required <p>Returns:</p> Type Description <code>T</code> <p>The newly created <code>Tag</code>.</p> Source code in <code>versions/segments.py</code> <pre><code>@classmethod\ndef default_phase_with_value(cls: Type[T], value: int) -&gt; T:\n\"\"\"Creates a [`Tag`][versions.segments.Tag] from `value` with the default phase.\n\n    Arguments:\n        value: The value of the tag.\n\n    Returns:\n        The newly created [`Tag`][versions.segments.Tag].\n    \"\"\"\n    return cls(cls.DEFAULT_PHASE, value)\n</code></pre>"},{"location":"reference/segments/#versions.segments.Tag.normalize","title":"<code>normalize() -&gt; T</code>","text":"<p>Normalizes the version tag.</p> <p>Returns:</p> Type Description <code>T</code> <p>The normalized tag.</p> Source code in <code>versions/segments.py</code> <pre><code>def normalize(self: T) -&gt; T:\n\"\"\"Normalizes the version tag.\n\n    Returns:\n        The normalized tag.\n    \"\"\"\n    return self.set_phase(self.normal)\n</code></pre>"},{"location":"reference/segments/#versions.segments.Tag.next","title":"<code>next() -&gt; T</code>","text":"<p>Bumps the version tag value.</p> <p>Returns:</p> Type Description <code>T</code> <p>The next version tag.</p> Source code in <code>versions/segments.py</code> <pre><code>def next(self: T) -&gt; T:\n\"\"\"Bumps the version tag value.\n\n    Returns:\n        The next version tag.\n    \"\"\"\n    return self.set_value(self.value + 1)\n</code></pre>"},{"location":"reference/segments/#versions.segments.Tag.next_phase","title":"<code>next_phase() -&gt; Optional[T]</code>","text":"<p>Bumps the version tag phase, if possible.</p> <p>Returns:</p> Type Description <code>Optional[T]</code> <p>The next version tag, if present.</p> Source code in <code>versions/segments.py</code> <pre><code>def next_phase(self: T) -&gt; Optional[T]:\n\"\"\"Bumps the version tag phase, if possible.\n\n    Returns:\n        The next version tag, if present.\n    \"\"\"\n    phase = PHASE_TO_NEXT.get(self.phase)\n\n    return None if phase is None else self.create(phase)\n</code></pre>"},{"location":"reference/segments/#versions.segments.Tag.from_string","title":"<code>from_string(string: str) -&gt; T</code>  <code>classmethod</code>","text":"<p>Parses a <code>Tag</code> from <code>string</code>.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>The string to parse.</p> required <p>Returns:</p> Type Description <code>T</code> <p>The parsed tag.</p> Source code in <code>versions/segments.py</code> <pre><code>@classmethod\ndef from_string(cls: Type[T], string: str) -&gt; T:\n\"\"\"Parses a [`Tag`][versions.segments.Tag] from `string`.\n\n    Arguments:\n        string: The string to parse.\n\n    Returns:\n        The parsed tag.\n    \"\"\"\n    return TagParser(cls).parse(string)\n</code></pre>"},{"location":"reference/segments/#versions.segments.Tag.to_string","title":"<code>to_string() -&gt; str</code>","text":"<p>Converts a <code>Tag</code> to its string representation.</p> <p>Returns:</p> Type Description <code>str</code> <p>The tag string.</p> Source code in <code>versions/segments.py</code> <pre><code>def to_string(self) -&gt; str:\n\"\"\"Converts a [`Tag`][versions.segments.Tag] to its string representation.\n\n    Returns:\n        The tag string.\n    \"\"\"\n    return concat_dot_args(self.phase, str(self.value))\n</code></pre>"},{"location":"reference/segments/#versions.segments.Tag.to_short_string","title":"<code>to_short_string() -&gt; str</code>","text":"<p>Converts a <code>Tag</code> to its short string representation.</p> <p>Returns:</p> Type Description <code>str</code> <p>The short tag string.</p> Source code in <code>versions/segments.py</code> <pre><code>def to_short_string(self) -&gt; str:\n\"\"\"Converts a [`Tag`][versions.segments.Tag] to its *short* string representation.\n\n    Returns:\n        The *short* tag string.\n    \"\"\"\n    return concat_empty_args(self.short, str(self.value))\n</code></pre>"},{"location":"reference/segments/#versions.segments.PreTag","title":"<code>PreTag</code>","text":"<p>         Bases: <code>Tag</code></p> <p>Represents the pre-release tag of the version (<code>pre.n</code>).</p> Source code in <code>versions/segments.py</code> <pre><code>@frozen(repr=False, eq=True, order=True)\nclass PreTag(Tag):\n\"\"\"Represents the *pre-release* tag of the version (`pre.n`).\"\"\"\n\n    DEFAULT_PHASE = PHASE_PRE_DEFAULT\n    PHASE_SET = PHASE_PRE_SET\n</code></pre>"},{"location":"reference/segments/#versions.segments.PostTag","title":"<code>PostTag</code>","text":"<p>         Bases: <code>Tag</code></p> <p>Represents the post-release tag of the version (<code>post.n</code>).</p> Source code in <code>versions/segments.py</code> <pre><code>@frozen(repr=False, eq=True, order=True)\nclass PostTag(Tag):\n\"\"\"Represents the *post-release* tag of the version (`post.n`).\"\"\"\n\n    DEFAULT_PHASE = PHASE_POST_DEFAULT\n    PHASE_SET = PHASE_POST_SET\n</code></pre>"},{"location":"reference/segments/#versions.segments.DevTag","title":"<code>DevTag</code>","text":"<p>         Bases: <code>Tag</code></p> <p>Represents the dev-release tag of the version (<code>dev.n</code>).</p> Source code in <code>versions/segments.py</code> <pre><code>@frozen(repr=False, eq=True, order=True)\nclass DevTag(Tag):\n\"\"\"Represents the *dev-release* tag of the version (`dev.n`).\"\"\"\n\n    DEFAULT_PHASE = PHASE_DEV_DEFAULT\n    PHASE_SET = PHASE_DEV_SET\n</code></pre>"},{"location":"reference/segments/#versions.segments.Local","title":"<code>Local</code>","text":"<p>         Bases: <code>Representation</code>, <code>String</code></p> <p>Represents the local segment of the version (<code>+abcdef.n</code>)</p> Source code in <code>versions/segments.py</code> <pre><code>@frozen(repr=False, eq=True, order=True)\nclass Local(Representation, String):\n\"\"\"Represents the *local* segment of the version (`+abcdef.n`)\"\"\"\n\n    parts: LocalParts = field(eq=False, order=False)\n\"\"\"The local segment parts.\"\"\"\n\n    compare_parts: CompareLocalParts = field(\n        repr=False, init=False, eq=True, order=True, hash=False\n    )\n\n    @parts.validator\n    def check_parts(self, attribute: Attribute[LocalParts], value: LocalParts) -&gt; None:\n        if not value:\n            raise ValueError(EMPTY_LOCAL)\n\n    @compare_parts.default\n    def default_compare_parts(self) -&gt; CompareLocalParts:\n        empty = EMPTY\n\n        return tuple(\n            (part, empty) if is_int(part) else (negative_infinity, part)  # type: ignore\n            for part in self.parts\n        )\n\n    @classmethod\n    def create(cls: Type[L], parts: LocalParts) -&gt; L:\n\"\"\"Creates a [`Local`][versions.segments.Local] segment from local `parts`.\n\n        Arguments:\n            parts: The local parts.\n\n        Returns:\n            The newly created [`Local`][versions.segments.Local] segment.\n        \"\"\"\n        return cls(parts)\n\n    @classmethod\n    def from_iterable(cls: Type[L], iterable: Iterable[LocalPart]) -&gt; L:\n\"\"\"Creates a [`Local`][versions.segments.Local] segment from `iterable`.\n\n        Arguments:\n            iterable: The local parts in an iterable.\n\n        Returns:\n            The newly created [`Local`][versions.segments.Local] segment.\n        \"\"\"\n        return cls(tuple(iterable))\n\n    @classmethod\n    def from_parts(cls: Type[L], *parts: LocalPart) -&gt; L:\n\"\"\"Creates a [`Local`][versions.segments.Local] segment from local `parts`.\n\n        Arguments:\n            *parts: The local parts.\n\n        Returns:\n            The newly created [`Local`][versions.segments.Local] segment.\n        \"\"\"\n        return cls(parts)\n\n    def into_parts(self) -&gt; LocalParts:\n\"\"\"Converts a [`Local`][versions.segments.Local] segment to its parts.\n\n        Returns:\n            The parts of the local segment.\n        \"\"\"\n        return self.parts\n\n    def set_parts(self: L, *parts: LocalPart) -&gt; L:\n        return evolve(self, parts=parts)\n\n    @classmethod\n    def from_string(cls: Type[L], string: str) -&gt; L:\n\"\"\"Parses a [`Local`][versions.segments.Local] segment from `string`.\n\n        Arguments:\n            string: The string to parse.\n\n        Returns:\n            The parsed local segment.\n        \"\"\"\n        return cls.from_iterable(map(local_part, split_separators(string)))\n\n    def to_string(self) -&gt; str:\n\"\"\"Converts a [`Local`][versions.segments.Local] segment to its string representation.\n\n        Returns:\n            The local segment string.\n        \"\"\"\n        return concat_dot(map(str, self.parts))\n</code></pre>"},{"location":"reference/segments/#versions.segments.Local.parts","title":"<code>parts: LocalParts = field(eq=False, order=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The local segment parts.</p>"},{"location":"reference/segments/#versions.segments.Local.create","title":"<code>create(parts: LocalParts) -&gt; L</code>  <code>classmethod</code>","text":"<p>Creates a <code>Local</code> segment from local <code>parts</code>.</p> <p>Parameters:</p> Name Type Description Default <code>parts</code> <code>LocalParts</code> <p>The local parts.</p> required <p>Returns:</p> Type Description <code>L</code> <p>The newly created <code>Local</code> segment.</p> Source code in <code>versions/segments.py</code> <pre><code>@classmethod\ndef create(cls: Type[L], parts: LocalParts) -&gt; L:\n\"\"\"Creates a [`Local`][versions.segments.Local] segment from local `parts`.\n\n    Arguments:\n        parts: The local parts.\n\n    Returns:\n        The newly created [`Local`][versions.segments.Local] segment.\n    \"\"\"\n    return cls(parts)\n</code></pre>"},{"location":"reference/segments/#versions.segments.Local.from_iterable","title":"<code>from_iterable(iterable: Iterable[LocalPart]) -&gt; L</code>  <code>classmethod</code>","text":"<p>Creates a <code>Local</code> segment from <code>iterable</code>.</p> <p>Parameters:</p> Name Type Description Default <code>iterable</code> <code>Iterable[LocalPart]</code> <p>The local parts in an iterable.</p> required <p>Returns:</p> Type Description <code>L</code> <p>The newly created <code>Local</code> segment.</p> Source code in <code>versions/segments.py</code> <pre><code>@classmethod\ndef from_iterable(cls: Type[L], iterable: Iterable[LocalPart]) -&gt; L:\n\"\"\"Creates a [`Local`][versions.segments.Local] segment from `iterable`.\n\n    Arguments:\n        iterable: The local parts in an iterable.\n\n    Returns:\n        The newly created [`Local`][versions.segments.Local] segment.\n    \"\"\"\n    return cls(tuple(iterable))\n</code></pre>"},{"location":"reference/segments/#versions.segments.Local.from_parts","title":"<code>from_parts(*parts: LocalPart) -&gt; L</code>  <code>classmethod</code>","text":"<p>Creates a <code>Local</code> segment from local <code>parts</code>.</p> <p>Parameters:</p> Name Type Description Default <code>*parts</code> <code>LocalPart</code> <p>The local parts.</p> <code>()</code> <p>Returns:</p> Type Description <code>L</code> <p>The newly created <code>Local</code> segment.</p> Source code in <code>versions/segments.py</code> <pre><code>@classmethod\ndef from_parts(cls: Type[L], *parts: LocalPart) -&gt; L:\n\"\"\"Creates a [`Local`][versions.segments.Local] segment from local `parts`.\n\n    Arguments:\n        *parts: The local parts.\n\n    Returns:\n        The newly created [`Local`][versions.segments.Local] segment.\n    \"\"\"\n    return cls(parts)\n</code></pre>"},{"location":"reference/segments/#versions.segments.Local.into_parts","title":"<code>into_parts() -&gt; LocalParts</code>","text":"<p>Converts a <code>Local</code> segment to its parts.</p> <p>Returns:</p> Type Description <code>LocalParts</code> <p>The parts of the local segment.</p> Source code in <code>versions/segments.py</code> <pre><code>def into_parts(self) -&gt; LocalParts:\n\"\"\"Converts a [`Local`][versions.segments.Local] segment to its parts.\n\n    Returns:\n        The parts of the local segment.\n    \"\"\"\n    return self.parts\n</code></pre>"},{"location":"reference/segments/#versions.segments.Local.from_string","title":"<code>from_string(string: str) -&gt; L</code>  <code>classmethod</code>","text":"<p>Parses a <code>Local</code> segment from <code>string</code>.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>The string to parse.</p> required <p>Returns:</p> Type Description <code>L</code> <p>The parsed local segment.</p> Source code in <code>versions/segments.py</code> <pre><code>@classmethod\ndef from_string(cls: Type[L], string: str) -&gt; L:\n\"\"\"Parses a [`Local`][versions.segments.Local] segment from `string`.\n\n    Arguments:\n        string: The string to parse.\n\n    Returns:\n        The parsed local segment.\n    \"\"\"\n    return cls.from_iterable(map(local_part, split_separators(string)))\n</code></pre>"},{"location":"reference/segments/#versions.segments.Local.to_string","title":"<code>to_string() -&gt; str</code>","text":"<p>Converts a <code>Local</code> segment to its string representation.</p> <p>Returns:</p> Type Description <code>str</code> <p>The local segment string.</p> Source code in <code>versions/segments.py</code> <pre><code>def to_string(self) -&gt; str:\n\"\"\"Converts a [`Local`][versions.segments.Local] segment to its string representation.\n\n    Returns:\n        The local segment string.\n    \"\"\"\n    return concat_dot(map(str, self.parts))\n</code></pre>"},{"location":"reference/specification/","title":"Specification","text":""},{"location":"reference/specification/#versions.specification.Specification","title":"<code>Specification</code>","text":"<p>         Bases: <code>Protocol</code></p> <p>The specification protocol for defining version requirements.</p> Source code in <code>versions/specification.py</code> <pre><code>@runtime_checkable\nclass Specification(Protocol):\n\"\"\"The specification protocol for defining version requirements.\"\"\"\n\n    @required\n    def accepts(self, version: Version) -&gt; bool:\n\"\"\"Checks if the `version` matches the specification.\n\n        Arguments:\n            version: The version to check.\n\n        Returns:\n            Whether the `version` matches the specification.\n        \"\"\"\n        raise NotImplementedError(expected_method(ACCEPTS))\n</code></pre>"},{"location":"reference/specification/#versions.specification.Specification.accepts","title":"<code>accepts(version: Version) -&gt; bool</code>  <code>abstractmethod</code>","text":"<p>Checks if the <code>version</code> matches the specification.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>Version</code> <p>The version to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the <code>version</code> matches the specification.</p> Source code in <code>versions/specification.py</code> <pre><code>@required\ndef accepts(self, version: Version) -&gt; bool:\n\"\"\"Checks if the `version` matches the specification.\n\n    Arguments:\n        version: The version to check.\n\n    Returns:\n        Whether the `version` matches the specification.\n    \"\"\"\n    raise NotImplementedError(expected_method(ACCEPTS))\n</code></pre>"},{"location":"reference/specifiers/","title":"Specifiers","text":""},{"location":"reference/specifiers/#versions.specifiers.Specifier","title":"<code>Specifier</code>","text":"<p>         Bases: <code>Representation</code>, <code>ToString</code>, <code>Specification</code></p> <p>Represents all possible specifiers.</p> Source code in <code>versions/specifiers.py</code> <pre><code>class Specifier(Representation, ToString, Specification):\n\"\"\"Represents all possible specifiers.\"\"\"\n</code></pre>"},{"location":"reference/specifiers/#versions.specifiers.SpecifierNever","title":"<code>SpecifierNever</code>","text":"<p>         Bases: <code>Specifier</code></p> <p>Represents specifiers that do not accept any versions.</p> Source code in <code>versions/specifiers.py</code> <pre><code>@frozen(repr=False)\nclass SpecifierNever(Specifier):\n\"\"\"Represents specifiers that do not accept any versions.\"\"\"\n\n    def accepts(self, version: Version) -&gt; Literal[False]:\n        return False\n\n    def to_string(self) -&gt; str:\n        return EMPTY_VERSION\n</code></pre>"},{"location":"reference/specifiers/#versions.specifiers.SpecifierAlways","title":"<code>SpecifierAlways</code>","text":"<p>         Bases: <code>Specifier</code></p> <p>Represents specifiers that accept all versions.</p> Source code in <code>versions/specifiers.py</code> <pre><code>@frozen(repr=False)\nclass SpecifierAlways(Specifier):\n\"\"\"Represents specifiers that accept all versions.\"\"\"\n\n    def accepts(self, version: Version) -&gt; Literal[True]:\n        return True\n\n    def to_string(self) -&gt; str:\n        return UNIVERSE_VERSION\n</code></pre>"},{"location":"reference/specifiers/#versions.specifiers.SpecifierOne","title":"<code>SpecifierOne</code>","text":"<p>         Bases: <code>Operator</code>, <code>Specifier</code></p> <p>Represents specifiers that accept versions according to the <code>Operator</code> type.</p> Source code in <code>versions/specifiers.py</code> <pre><code>@frozen(repr=False)\nclass SpecifierOne(Operator, Specifier):\n\"\"\"Represents specifiers that accept versions according to the\n    [`Operator`][versions.operators.Operator] type.\n    \"\"\"\n\n    def accepts(self, version: Version) -&gt; bool:\n        return self.partial_matches(version)\n</code></pre>"},{"location":"reference/specifiers/#versions.specifiers.SpecifierAny","title":"<code>SpecifierAny</code>","text":"<p>         Bases: <code>Specifier</code></p> <p>Represents collections of two or more specifiers that accept versions if any of the contained specifiers accept it.</p> Source code in <code>versions/specifiers.py</code> <pre><code>@frozen(repr=False)\nclass SpecifierAny(Specifier):\n\"\"\"Represents collections of two or more specifiers that accept versions\n    if *any* of the contained specifiers accept it.\n    \"\"\"\n\n    WRAP: ClassVar[bool] = False\n\n    specifiers: Specifiers = field()\n\n    @specifiers.validator\n    def check_specifiers(self, attribute: Attribute[Specifiers], specifiers: Specifiers) -&gt; None:\n        check_specifiers(specifiers)\n\n    @classmethod\n    def of_specifiers(cls, specifiers: Specifiers) -&gt; Specifier:\n        if not specifiers:\n            return SpecifierNever()\n\n        if contains_only_item(specifiers):\n            return first(specifiers)\n\n        return cls(specifiers)\n\n    @classmethod\n    def of(cls, *specifiers: Specifier) -&gt; Specifier:\n        return cls.of_specifiers(specifiers)\n\n    @classmethod\n    def of_iterable(cls, iterable: Iterable[Specifier]) -&gt; Specifier:\n        return cls.of_specifiers(tuple(iterable))\n\n    def accepts(self, version: Version) -&gt; bool:\n        return any(specifier.accepts(version) for specifier in self.specifiers)\n\n    def to_string(self) -&gt; str:\n        return create_wrap_around(\n            concat_pipes_spaced(specifier.to_string() for specifier in self.specifiers)\n        )\n\n    def to_short_string(self) -&gt; str:\n        return create_wrap_around(\n            concat_pipes(specifier.to_short_string() for specifier in self.specifiers)\n        )\n</code></pre>"},{"location":"reference/specifiers/#versions.specifiers.SpecifierAll","title":"<code>SpecifierAll</code>","text":"<p>         Bases: <code>Specifier</code></p> <p>Represents collections of two or more specifiers that accept versions if and only if all of the contained specifiers accept it.</p> Source code in <code>versions/specifiers.py</code> <pre><code>@frozen(repr=False)\nclass SpecifierAll(Specifier):\n\"\"\"Represents collections of two or more specifiers that accept versions\n    if and only if *all* of the contained specifiers accept it.\n    \"\"\"\n\n    WRAP: ClassVar[bool] = False\n\n    specifiers: Specifiers = field()\n\n    @specifiers.validator\n    def check_specifiers(self, attribute: Attribute[Specifiers], specifiers: Specifiers) -&gt; None:\n        check_specifiers(specifiers)\n\n    @classmethod\n    def of_specifiers(cls, specifiers: Specifiers) -&gt; Specifier:\n        if not specifiers:\n            return SpecifierAlways()\n\n        if contains_only_item(specifiers):\n            return first(specifiers)\n\n        return cls(specifiers)\n\n    @classmethod\n    def of(cls, *specifiers: Specifier) -&gt; Specifier:\n        return cls.of_specifiers(specifiers)\n\n    @classmethod\n    def of_iterable(cls, iterable: Iterable[Specifier]) -&gt; Specifier:\n        return cls.of_specifiers(tuple(iterable))\n\n    def accepts(self, version: Version) -&gt; bool:\n        return all(specifier.accepts(version) for specifier in self.specifiers)\n\n    def to_string(self) -&gt; str:\n        return create_wrap_around(\n            concat_comma_space(specifier.to_string() for specifier in self.specifiers)\n        )\n\n    def to_short_string(self) -&gt; str:\n        return create_wrap_around(\n            concat_comma(specifier.to_short_string() for specifier in self.specifiers)\n        )\n</code></pre>"},{"location":"reference/specifiers/#versions.specifiers.is_specifier","title":"<code>is_specifier(item: Any) -&gt; TypeGuard[Specifier]</code>","text":"<p>Checks if an <code>item</code> is an instance of <code>Specifier</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>The item to check.</p> required <p>Returns:</p> Type Description <code>TypeGuard[Specifier]</code> <p>Whether the <code>item</code> provided is an instance of <code>Specifier</code>.</p> Source code in <code>versions/specifiers.py</code> <pre><code>def is_specifier(item: Any) -&gt; TypeGuard[Specifier]:\n\"\"\"Checks if an `item` is an instance of [`Specifier`][versions.specifiers.Specifier].\n\n    Arguments:\n        item: The item to check.\n\n    Returns:\n        Whether the `item` provided is an instance of [`Specifier`][versions.specifiers.Specifier].\n    \"\"\"\n    return is_instance(item, Specifier)\n</code></pre>"},{"location":"reference/specifiers/#versions.specifiers.is_specifier_never","title":"<code>is_specifier_never(item: Any) -&gt; TypeGuard[SpecifierNever]</code>","text":"<p>Checks if an <code>item</code> is an instance of <code>SpecifierNever</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>The item to check.</p> required <p>Returns:</p> Type Description <code>TypeGuard[SpecifierNever]</code> <p>Whether the <code>item</code> provided is an instance of <code>SpecifierNever</code>.</p> Source code in <code>versions/specifiers.py</code> <pre><code>def is_specifier_never(item: Any) -&gt; TypeGuard[SpecifierNever]:\n\"\"\"Checks if an `item` is an instance of\n    [`SpecifierNever`][versions.specifiers.SpecifierNever].\n\n    Arguments:\n        item: The item to check.\n\n    Returns:\n        Whether the `item` provided is an instance of\n            [`SpecifierNever`][versions.specifiers.SpecifierNever].\n    \"\"\"\n    return is_instance(item, SpecifierNever)\n</code></pre>"},{"location":"reference/specifiers/#versions.specifiers.is_specifier_always","title":"<code>is_specifier_always(item: Any) -&gt; TypeGuard[SpecifierAlways]</code>","text":"<p>Checks if an <code>item</code> is an instance of <code>SpecifierAlways</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>The item to check.</p> required <p>Returns:</p> Type Description <code>TypeGuard[SpecifierAlways]</code> <p>Whether the <code>item</code> provided is an instance of <code>SpecifierAlways</code>.</p> Source code in <code>versions/specifiers.py</code> <pre><code>def is_specifier_always(item: Any) -&gt; TypeGuard[SpecifierAlways]:\n\"\"\"Checks if an `item` is an instance of\n    [`SpecifierAlways`][versions.specifiers.SpecifierAlways].\n\n    Arguments:\n        item: The item to check.\n\n    Returns:\n        Whether the `item` provided is an instance of\n            [`SpecifierAlways`][versions.specifiers.SpecifierAlways].\n    \"\"\"\n    return is_instance(item, SpecifierAlways)\n</code></pre>"},{"location":"reference/specifiers/#versions.specifiers.is_specifier_one","title":"<code>is_specifier_one(item: Any) -&gt; TypeGuard[SpecifierOne]</code>","text":"<p>Checks if an <code>item</code> is an instance of <code>SpecifierOne</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>The item to check.</p> required <p>Returns:</p> Type Description <code>TypeGuard[SpecifierOne]</code> <p>Whether the <code>item</code> provided is an instance of <code>SpecifierOne</code>.</p> Source code in <code>versions/specifiers.py</code> <pre><code>def is_specifier_one(item: Any) -&gt; TypeGuard[SpecifierOne]:\n\"\"\"Checks if an `item` is an instance of\n    [`SpecifierOne`][versions.specifiers.SpecifierOne].\n\n    Arguments:\n        item: The item to check.\n\n    Returns:\n        Whether the `item` provided is an instance of\n            [`SpecifierOne`][versions.specifiers.SpecifierOne].\n    \"\"\"\n    return is_instance(item, SpecifierOne)\n</code></pre>"},{"location":"reference/specifiers/#versions.specifiers.is_specifier_any","title":"<code>is_specifier_any(item: Any) -&gt; TypeGuard[SpecifierAny]</code>","text":"<p>Checks if an <code>item</code> is an instance of <code>SpecifierAny</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>The item to check.</p> required <p>Returns:</p> Type Description <code>TypeGuard[SpecifierAny]</code> <p>Whether the <code>item</code> provided is an instance of <code>SpecifierAny</code>.</p> Source code in <code>versions/specifiers.py</code> <pre><code>def is_specifier_any(item: Any) -&gt; TypeGuard[SpecifierAny]:\n\"\"\"Checks if an `item` is an instance of\n    [`SpecifierAny`][versions.specifiers.SpecifierAny].\n\n    Arguments:\n        item: The item to check.\n\n    Returns:\n        Whether the `item` provided is an instance of\n            [`SpecifierAny`][versions.specifiers.SpecifierAny].\n    \"\"\"\n    return is_instance(item, SpecifierAny)\n</code></pre>"},{"location":"reference/specifiers/#versions.specifiers.is_specifier_all","title":"<code>is_specifier_all(item: Any) -&gt; TypeGuard[SpecifierAll]</code>","text":"<p>Checks if an <code>item</code> is an instance of <code>SpecifierAll</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>The item to check.</p> required <p>Returns:</p> Type Description <code>TypeGuard[SpecifierAll]</code> <p>Whether the <code>item</code> provided is an instance of <code>SpecifierAll</code>.</p> Source code in <code>versions/specifiers.py</code> <pre><code>def is_specifier_all(item: Any) -&gt; TypeGuard[SpecifierAll]:\n\"\"\"Checks if an `item` is an instance of\n    [`SpecifierAll`][versions.specifiers.SpecifierAll].\n\n    Arguments:\n        item: The item to check.\n\n    Returns:\n        Whether the `item` provided is an instance of\n            [`SpecifierAll`][versions.specifiers.SpecifierAll].\n    \"\"\"\n    return is_instance(item, SpecifierAll)\n</code></pre>"},{"location":"reference/types/","title":"Types","text":""},{"location":"reference/types/#versions.types.infinity","title":"<code>infinity = Infinity()</code>  <code>module-attribute</code>","text":"<p>The singleton instance of <code>Infinity</code>.</p>"},{"location":"reference/types/#versions.types.negative_infinity","title":"<code>negative_infinity = NegativeInfinity()</code>  <code>module-attribute</code>","text":"<p>The singleton instance of <code>NegativeInfinity</code>.</p>"},{"location":"reference/types/#versions.types.AnyInfinity","title":"<code>AnyInfinity = Union[Infinity, NegativeInfinity]</code>  <code>module-attribute</code>","text":"<p>The union of <code>Infinity</code> and <code>NegativeInfinity</code>.</p>"},{"location":"reference/types/#versions.types.Infinity","title":"<code>Infinity</code>","text":"<p>         Bases: <code>Singleton</code></p> <p>Represents the positive infinity.</p> Source code in <code>versions/types.py</code> <pre><code>class Infinity(Singleton):\n\"\"\"Represents the positive infinity.\"\"\"\n\n    def __repr__(self) -&gt; str:\n        return INFINITY\n\n    def __eq__(self, other: Any) -&gt; bool:\n        return self is other\n\n    def __ne__(self, other: Any) -&gt; bool:\n        return self is not other\n\n    def __lt__(self, other: Any) -&gt; bool:\n        return False\n\n    def __le__(self, other: Any) -&gt; bool:\n        return self is other\n\n    def __gt__(self, other: Any) -&gt; bool:\n        return self is not other\n\n    def __ge__(self, other: Any) -&gt; bool:\n        return True\n\n    def __neg__(self: Infinity) -&gt; NegativeInfinity:\n        return negative_infinity\n</code></pre>"},{"location":"reference/types/#versions.types.NegativeInfinity","title":"<code>NegativeInfinity</code>","text":"<p>         Bases: <code>Singleton</code></p> <p>Represents the negative infinity.</p> Source code in <code>versions/types.py</code> <pre><code>class NegativeInfinity(Singleton):\n\"\"\"Represents the negative infinity.\"\"\"\n\n    def __repr__(self) -&gt; str:\n        return NEGATIVE_INFINITY\n\n    def __eq__(self, other: Any) -&gt; bool:\n        return self is other\n\n    def __ne__(self, other: Any) -&gt; bool:\n        return self is not other\n\n    def __lt__(self, other: Any) -&gt; bool:\n        return self is not other\n\n    def __le__(self, other: Any) -&gt; bool:\n        return True\n\n    def __gt__(self, other: Any) -&gt; bool:\n        return False\n\n    def __ge__(self, other: Any) -&gt; bool:\n        return self is other\n\n    def __neg__(self: NegativeInfinity) -&gt; Infinity:\n        return infinity\n</code></pre>"},{"location":"reference/types/#versions.types.is_infinity","title":"<code>is_infinity(item: Any) -&gt; TypeGuard[Infinity]</code>","text":"<p>Checks if an <code>item</code> is an instance of <code>Infinity</code>.</p> <p>Returns:</p> Type Description <code>TypeGuard[Infinity]</code> <p>Whether the <code>item</code> is an instance of <code>Infinity</code>.</p> Source code in <code>versions/types.py</code> <pre><code>def is_infinity(item: Any) -&gt; TypeGuard[Infinity]:\n\"\"\"Checks if an `item` is an instance of [`Infinity`][versions.types.Infinity].\n\n    Returns:\n        Whether the `item` is an instance of [`Infinity`][versions.types.Infinity].\n    \"\"\"\n    return item is infinity\n</code></pre>"},{"location":"reference/types/#versions.types.is_negative_infinity","title":"<code>is_negative_infinity(item: Any) -&gt; TypeGuard[NegativeInfinity]</code>","text":"<p>Checks if an <code>item</code> is an instance of <code>NegativeInfinity</code>.</p> <p>Returns:</p> Type Description <code>TypeGuard[NegativeInfinity]</code> <p>Whether the <code>item</code> is an instance of <code>NegativeInfinity</code>.</p> Source code in <code>versions/types.py</code> <pre><code>def is_negative_infinity(item: Any) -&gt; TypeGuard[NegativeInfinity]:\n\"\"\"Checks if an `item` is an instance of [`NegativeInfinity`][versions.types.NegativeInfinity].\n\n    Returns:\n        Whether the `item` is an instance of [`NegativeInfinity`][versions.types.NegativeInfinity].\n    \"\"\"\n    return item is negative_infinity\n</code></pre>"},{"location":"reference/types/#versions.types.is_any_infinity","title":"<code>is_any_infinity(item: Any) -&gt; TypeGuard[AnyInfinity]</code>","text":"<p>Checks if an <code>item</code> is an instance of <code>AnyInfinity</code>.</p> <p>Returns:</p> Type Description <code>TypeGuard[AnyInfinity]</code> <p>Whether the <code>item</code> is an instance of <code>AnyInfinity</code>.</p> Source code in <code>versions/types.py</code> <pre><code>def is_any_infinity(item: Any) -&gt; TypeGuard[AnyInfinity]:\n\"\"\"Checks if an `item` is an instance of [`AnyInfinity`][versions.types.AnyInfinity].\n\n    Returns:\n        Whether the `item` is an instance of [`AnyInfinity`][versions.types.AnyInfinity].\n    \"\"\"\n    return item is infinity or item is negative_infinity\n</code></pre>"},{"location":"reference/version/","title":"Version","text":""},{"location":"reference/version/#versions.version.Version","title":"<code>Version</code>","text":"<p>         Bases: <code>Representation</code>, <code>String</code></p> <p>Represents versions.</p> Source code in <code>versions/version.py</code> <pre><code>@frozen(repr=False, eq=True, order=True)\nclass Version(Representation, String):\n\"\"\"Represents versions.\"\"\"\n\n    epoch: Epoch = field(factory=Epoch, eq=False, order=False)\n\"\"\"The *epoch* segment of the version.\"\"\"\n\n    release: Release = field(factory=Release, eq=False, order=False)\n\"\"\"The *release* segment of the version.\"\"\"\n\n    pre: Optional[PreTag] = field(default=None, eq=False, order=False)\n\"\"\"The *pre-release* tag of the version.\"\"\"\n\n    post: Optional[PostTag] = field(default=None, eq=False, order=False)\n\"\"\"The *post-release* tag of the version.\"\"\"\n\n    dev: Optional[DevTag] = field(default=None, eq=False, order=False)\n\"\"\"The *dev-release* tag of the version.\"\"\"\n\n    local: Optional[Local] = field(default=None, eq=False, order=False)\n\"\"\"The *local* segment of the version.\"\"\"\n\n    compare_key: CompareKey = field(repr=False, init=False, eq=True, order=True, hash=False)\n\n    @compare_key.default\n    def default_compare_key(self) -&gt; CompareKey:\n        compare_epoch = self.epoch\n        compare_release = self.release\n\n        compare_pre, compare_post, compare_dev = self.compute_compare_tags(\n            self.pre, self.post, self.dev\n        )\n\n        compare_local = self.compute_compare_local(self.local)\n\n        return (\n            compare_epoch,\n            compare_release,\n            compare_pre,\n            compare_post,\n            compare_dev,\n            compare_local,\n        )\n\n    @staticmethod\n    def compute_compare_tags(\n        pre: Optional[PreTag], post: Optional[PostTag], dev: Optional[DevTag]\n    ) -&gt; Tuple[ComparePreTag, ComparePostTag, CompareDevTag]:\n        compare_pre: ComparePreTag\n        compare_post: ComparePostTag\n        compare_dev: CompareDevTag\n\n        if pre is None:\n            if post is None and dev is not None:\n                compare_pre = negative_infinity\n\n            else:\n                compare_pre = infinity\n\n        else:\n            compare_pre = pre\n\n        compare_post = negative_infinity if post is None else post\n        compare_dev = infinity if dev is None else dev\n\n        return (compare_pre, compare_post, compare_dev)\n\n    @staticmethod\n    def compute_compare_local(local: Optional[Local]) -&gt; CompareLocal:\n        return negative_infinity if local is None else local\n\n    @classmethod\n    def from_string(cls: Type[V], string: str) -&gt; V:\n\"\"\"Parses a [`Version`][versions.version.Version] from `string`.\n\n        Arguments:\n            string: The string to parse.\n\n        Returns:\n            The parsed version.\n        \"\"\"\n        return VersionParser(cls).parse(string)\n\n    def to_string_iterator(self) -&gt; Iterator[str]:\n        epoch = self.epoch\n\n        if epoch:\n            yield epoch.to_string()\n            yield EXCLAMATION\n\n        yield self.release.to_string()\n\n        pre = self.pre\n\n        if pre:\n            yield DASH\n            yield pre.to_string()\n\n        post = self.post\n\n        if post:\n            yield DASH\n            yield post.to_string()\n\n        dev = self.dev\n\n        if dev:\n            yield DASH\n            yield dev.to_string()\n\n        local = self.local\n\n        if local:\n            yield PLUS\n            yield local.to_string()\n\n    def to_short_string_iterator(self) -&gt; Iterator[str]:\n        epoch = self.epoch\n\n        if epoch:\n            yield epoch.to_short_string()\n            yield EXCLAMATION\n\n        yield self.release.to_short_string()\n\n        pre = self.pre\n\n        if pre:\n            yield pre.to_short_string()\n\n        post = self.post\n\n        if post:\n            yield DOT\n            yield post.to_short_string()\n\n        dev = self.dev\n\n        if dev:\n            yield DOT\n            yield dev.to_short_string()\n\n        local = self.local\n\n        if local:\n            yield PLUS\n            yield local.to_short_string()\n\n    def to_string(self) -&gt; str:\n\"\"\"Converts a [`Version`][versions.version.Version] to its string representation.\n\n        Returns:\n            The version string.\n        \"\"\"\n        return concat_empty(self.to_string_iterator())\n\n    def to_short_string(self) -&gt; str:\n\"\"\"Converts a [`Version`][versions.version.Version] to its *short* string representation.\n\n        Returns:\n            The *short* version string.\n        \"\"\"\n        return concat_empty(self.to_short_string_iterator())\n\n    def to_pep440_string(self) -&gt; str:\n\"\"\"Converts a [`Version`][versions.version.Version] to its\n        [*PEP 440*](https://peps.python.org/pep-0440) representation.\n\n        ```python\n        version.to_pep440_string()\n        ```\n\n        Is equivalent to the following:\n\n        ```python\n        version.normalize().to_short_string()\n        ```\n\n        Returns:\n            The [*PEP 440*](https://peps.python.org/pep-0440) version string.\n        \"\"\"\n        return self.normalize().to_short_string()\n\n    @property\n    def precision(self) -&gt; int:\n\"\"\"The precision of the [`Release`][versions.segments.Release].\"\"\"\n        return self.release.precision\n\n    @property\n    def last_index(self) -&gt; int:\n\"\"\"The last index of the [`Release`][versions.segments.Release].\"\"\"\n        return self.release.last_index\n\n    @property\n    def major(self) -&gt; int:\n\"\"\"The *major* part of the [`Release`][versions.segments.Release].\"\"\"\n        return self.release.major\n\n    @property\n    def minor(self) -&gt; int:\n\"\"\"The *minor* part of the [`Release`][versions.segments.Release].\"\"\"\n        return self.release.minor\n\n    @property\n    def micro(self) -&gt; int:\n\"\"\"The *micro* part of the [`Release`][versions.segments.Release].\"\"\"\n        return self.release.micro\n\n    @property\n    def patch(self) -&gt; int:\n\"\"\"The *patch* part of the [`Release`][versions.segments.Release].\n\n        This is equivalent to [`micro`][versions.version.Version.micro].\n        \"\"\"\n        return self.release.patch\n\n    @property\n    def extra(self) -&gt; Extra:\n\"\"\"The *extra* parts of the [`Release`][versions.segments.Release].\"\"\"\n        return self.release.extra\n\n    def get_at(self, index: int, default: int = DEFAULT_VALUE) -&gt; int:\n\"\"\"Gets the [`Release`][versions.segments.Release] part at the `index`,\n        defaulting to `default`.\n\n        Arguments:\n            index: The index of the part to get.\n            default: The default value to use.\n\n        Returns:\n            The release part at `index` or the `default` value.\n        \"\"\"\n        return self.release.get_at(index, default)\n\n    def get_at_unchecked(self, index: int) -&gt; int:\n\"\"\"Gets the [`Release`][versions.segments.Release] part at the `index`.\n\n        Arguments:\n            index: The index of the part to get.\n\n        Raises:\n            IndexError: The index is *out-of-bounds*.\n\n        Returns:\n            The release part at the `index`.\n        \"\"\"\n        return self.release.get_at_unchecked(index)\n\n    def is_semantic(self) -&gt; bool:\n\"\"\"Checks if the [`Release`][versions.segments.Release]\n        matches the *semantic versioning* schema.\n\n        Returns:\n            Whether the release matches the [`semver`](https://semver.org/) schema.\n        \"\"\"\n        return self.release.is_semantic()\n\n    def to_semantic(self: V) -&gt; V:\n\"\"\"Converts the [`Release`][versions.segments.Release]\n        to match the [`semver`](https://semver.org/) schema.\n\n        Returns:\n            The converted version.\n        \"\"\"\n        return evolve(self, release=self.release.to_semantic())\n\n    def set_epoch(self: V, epoch: Epoch) -&gt; V:\n        return evolve(self, epoch=epoch)\n\n    def set_epoch_value(self: V, value: int) -&gt; V:\n        return self.set_epoch(self.epoch.set_value(value))\n\n    def set_release(self: V, release: Release) -&gt; V:\n        return evolve(self, release=release)\n\n    def set_release_parts(self: V, *parts: int) -&gt; V:\n        return self.set_release(self.release.set_parts(*parts))\n\n    def slice(self: V, index: int) -&gt; V:\n        return self.set_release(self.release.slice(index))\n\n    def set_major(self: V, value: int) -&gt; V:\n\"\"\"Sets the *major* part of the [`Release`][versions.segments.Release] to the `value`.\n\n        Arguments:\n            value: The value to set the *major* part to.\n\n        Returns:\n            The updated version.\n        \"\"\"\n        return self.set_release(self.release.set_major(value))\n\n    def set_minor(self: V, value: int) -&gt; V:\n\"\"\"Sets the *minor* part of the [`Release`][versions.segments.Release] to the `value`.\n\n        Arguments:\n            value: The value to set the *minor* part to.\n\n        Returns:\n            The updated version.\n        \"\"\"\n        return self.set_release(self.release.set_minor(value))\n\n    def set_micro(self: V, value: int) -&gt; V:\n\"\"\"Sets the *micro* part of the [`Release`][versions.segments.Release] to the `value`.\n\n        Arguments:\n            value: The value to set the *micro* part to.\n\n        Returns:\n            The updated version.\n        \"\"\"\n        return self.set_release(self.release.set_micro(value))\n\n    def set_patch(self: V, value: int) -&gt; V:\n\"\"\"Sets the *patch* part of the [`Release`][versions.segments.Release] to the `value`.\n\n        This is equivalent to [`set_micro`][versions.version.Version.set_micro].\n\n        Arguments:\n            value: The value to set the *patch* part to.\n\n        Returns:\n            The updated version.\n        \"\"\"\n        return self.set_release(self.release.set_patch(value))\n\n    def set_at(self: V, index: int, value: int) -&gt; V:\n\"\"\"Sets the [`Release`][versions.segments.Release] part at the `index` to the `value`.\n\n        Arguments:\n            index: The index to set the `value` at.\n            value: The value to set the part to.\n\n        Returns:\n            The updated version.\n        \"\"\"\n        return self.set_release(self.release.set_at(index, value))\n\n    def set_at_unchecked(self: V, index: int, value: int) -&gt; V:\n\"\"\"Sets the [`Release`][versions.segments.Release] part at the `index` to the `value`.\n\n        Arguments:\n            index: The index to set the `value` at.\n            value: The value to set the part to.\n\n        Raises:\n            IndexError: The index is *out-of-bounds*.\n\n        Returns:\n            The updated version.\n        \"\"\"\n        return self.set_release(self.release.set_at_unchecked(index, value))\n\n    def next_epoch(self: V) -&gt; V:\n        return self.set_epoch(self.epoch.next_value())\n\n    def next_major(self: V) -&gt; V:\n\"\"\"Bumps the *major* part of the [`Release`][versions.segments.Release]\n        if the version is stable, otherwise converts the version to be stable.\n\n        Returns:\n            The bumped version.\n        \"\"\"\n        release = self.release\n\n        if self.is_stable():\n            release = release.next_major()\n\n        return self.create(self.epoch, release)\n\n    def next_minor(self: V) -&gt; V:\n\"\"\"Bumps the *minor* part of the [`Release`][versions.segments.Release]\n        if the version is stable, otherwise converts the version to be stable.\n\n        Returns:\n            The bumped version.\n        \"\"\"\n        release = self.release\n\n        if self.is_stable():\n            release = release.next_minor()\n\n        return self.create(self.epoch, release)\n\n    def next_micro(self: V) -&gt; V:\n\"\"\"Bumps the *micro* part of the [`Release`][versions.segments.Release]\n        if the version is stable, otherwise converts the version to be stable.\n\n        Returns:\n            The bumped version.\n        \"\"\"\n        release = self.release\n\n        if self.is_stable():\n            release = release.next_micro()\n\n        return self.create(self.epoch, release)\n\n    def next_patch(self: V) -&gt; V:\n\"\"\"Bumps the *patch* part of the [`Release`][versions.segments.Release]\n        if the version is stable, otherwise converts the version to be stable.\n\n        This is equivalent to [`next_micro`][versions.version.Version.next_micro].\n\n        Returns:\n            The bumped version.\n        \"\"\"\n        release = self.release\n\n        if self.is_stable():\n            release = release.next_patch()\n\n        return self.create(self.epoch, release)\n\n    def next_at(self: V, index: int) -&gt; V:\n\"\"\"Bumps the part of the [`Release`][versions.segments.Release] at the `index`\n        if the version is stable, otherwise converts the version to be stable.\n\n        Arguments:\n            index: The index to bump the part at.\n\n        Returns:\n            The bumped version.\n        \"\"\"\n        release = self.release\n\n        if self.is_stable():\n            release = release.next_at(index)\n\n        return self.create(self.epoch, release)\n\n    def has_major(self) -&gt; bool:\n\"\"\"Checks if the [`Release`][versions.segments.Release] has the *major* part.\n\n        Returns:\n            Whether the *major* part is present.\n        \"\"\"\n        return self.release.has_major()\n\n    def has_minor(self) -&gt; bool:\n\"\"\"Checks if the [`Release`][versions.segments.Release] has the *minor* part.\n\n        Returns:\n            Whether the *minor* part is present.\n        \"\"\"\n        return self.release.has_minor()\n\n    def has_micro(self) -&gt; bool:\n\"\"\"Checks if the [`Release`][versions.segments.Release] has the *micro* part.\n\n        Returns:\n            Whether the *micro* part is present.\n        \"\"\"\n        return self.release.has_micro()\n\n    def has_patch(self) -&gt; bool:\n\"\"\"Checks if the [`Release`][versions.segments.Release] has the *patch* part.\n\n        This is equivalent to [`has_micro`][versions.version.Version.has_micro].\n\n        Returns:\n            Whether the *patch* part is present.\n        \"\"\"\n        return self.release.has_patch()\n\n    def has_extra(self) -&gt; bool:\n\"\"\"Checks if the [`Release`][versions.segments.Release] has any *extra* parts.\n\n        Returns:\n            Whether the *extra* parts are present.\n        \"\"\"\n        return self.release.has_extra()\n\n    def has_at(self, index: int) -&gt; bool:\n\"\"\"Checks if the [`Release`][versions.segments.Release] has a part at the `index`.\n\n        Returns:\n            Whether the part at the `index` is present.\n        \"\"\"\n        return self.release.has_at(index)\n\n    def pad_to(self: V, length: int, padding: int = DEFAULT_PADDING) -&gt; V:\n\"\"\"Pads the [`Release`][versions.segments.Release] to the `length` with `padding`.\n\n        Arguments:\n            length: The length to pad the release to.\n            padding: The padding to use.\n\n        Returns:\n            The padded version.\n        \"\"\"\n        return self.set_release(self.release.pad_to(length, padding))\n\n    def pad_to_index(self: V, index: int, padding: int = DEFAULT_PADDING) -&gt; V:\n\"\"\"Pads the [`Release`][versions.segments.Release] to the `index` with `padding`.\n\n        Arguments:\n            index: The index to pad the release to.\n            padding: The padding to use.\n\n        Returns:\n            The padded version.\n        \"\"\"\n        return self.set_release(self.release.pad_to_index(index, padding))\n\n    def pad_to_next(self: V, padding: int = DEFAULT_PADDING) -&gt; V:\n\"\"\"Pads the [`Release`][versions.segments.Release] to the next index.\n\n        Arguments:\n            padding: The padding to use.\n\n        Returns:\n            The padded version.\n        \"\"\"\n        return self.set_release(self.release.pad_to_next(padding))\n\n    def is_pre_release(self) -&gt; bool:\n\"\"\"Checks if the version is *pre-release*.\n\n        Returns:\n            Whether the version is *pre-release*.\n        \"\"\"\n        return self.pre is not None\n\n    def is_post_release(self) -&gt; bool:\n\"\"\"Checks if the version is *post-release*.\n\n        Returns:\n            Whether the version is *post-release*.\n        \"\"\"\n        return self.post is not None\n\n    def is_dev_release(self) -&gt; bool:\n\"\"\"Checks if the version is *dev-release*.\n\n        Returns:\n            Whether the version is *dev-release*.\n        \"\"\"\n        return self.dev is not None\n\n    def is_local(self) -&gt; bool:\n\"\"\"Checks if the version is *local*.\n\n        Returns:\n            Whether the version is *local*.\n        \"\"\"\n        return self.local is not None\n\n    def is_unstable(self) -&gt; bool:\n\"\"\"Checks if the version is *unstable*.\n\n        Returns:\n            Whether the version is *unstable*.\n        \"\"\"\n        return self.is_pre_release() or self.is_dev_release()\n\n    def is_stable(self) -&gt; bool:\n\"\"\"Checks if the version is *stable*.\n\n        Returns:\n            Whether the version is *stable*.\n        \"\"\"\n        return not self.is_unstable()\n\n    def next_pre(self: V) -&gt; V:\n\"\"\"Bumps the [`PreTag`][versions.segments.PreTag] if it is present,\n        otherwise adds one to the version.\n\n        Returns:\n            The bumped version.\n        \"\"\"\n        pre = self.pre\n\n        if pre is None:\n            pre = PreTag()\n\n        else:\n            pre = pre.next()\n\n        return self.create(self.epoch, self.release, pre)\n\n    def next_pre_phase(self: V) -&gt; Optional[V]:\n\"\"\"Bumps the [`PreTag`][versions.segments.PreTag] phase if it is present (and if possible),\n        otherwise adds one to the version.\n\n        Returns:\n            The bumped version (if the next [`PreTag`][versions.segments.PreTag] is present).\n        \"\"\"\n        pre = self.pre\n\n        if pre is None:\n            pre = PreTag()\n\n        else:\n            pre = pre.next_phase()\n\n            if pre is None:\n                return None\n\n        return self.without_tags_and_local().with_pre(pre)\n\n    def next_post(self: V) -&gt; V:\n\"\"\"Bumps the [`PostTag`][versions.segments.PostTag] if it is present,\n        otherwise adds one to the version.\n\n        Returns:\n            The bumped version.\n        \"\"\"\n        post = self.post\n\n        if post is None:\n            post = PostTag()\n\n        else:\n            post = post.next()\n\n        return self.with_post(post).without_dev_and_local()\n\n    def next_dev(self: V) -&gt; V:\n\"\"\"Bumps the [`DevTag`][versions.segments.DevTag] if it is present,\n        otherwise adds one to the version.\n\n        Returns:\n            The bumped version.\n        \"\"\"\n        dev = self.dev\n\n        if dev is None:\n            dev = DevTag()\n\n        else:\n            dev = dev.next()\n\n        return self.with_dev(dev).without_local()\n\n    def set_pre(self: V, pre: Optional[PreTag]) -&gt; V:\n        return evolve(self, pre=pre)\n\n    def set_post(self: V, post: Optional[PostTag]) -&gt; V:\n        return evolve(self, post=post)\n\n    def set_dev(self: V, dev: Optional[DevTag]) -&gt; V:\n        return evolve(self, dev=dev)\n\n    def set_tags(\n        self: V, pre: Optional[PreTag], post: Optional[PostTag], dev: Optional[DevTag]\n    ) -&gt; V:\n        return evolve(self, pre=pre, post=post, dev=dev)\n\n    def set_local(self: V, local: Optional[Local]) -&gt; V:\n        return evolve(self, local=local)\n\n    def set_local_parts(self: V, *parts: LocalPart) -&gt; V:\n        local = self.local\n\n        local = Local.from_parts(*parts) if local is None else local.set_parts(*parts)\n\n        return self.set_local(local)\n\n    def set_dev_and_local(self: V, dev: Optional[DevTag], local: Optional[Local]) -&gt; V:\n        return evolve(self, dev=dev, local=local)\n\n    def set_tags_and_local(\n        self: V,\n        pre: Optional[PreTag],\n        post: Optional[PostTag],\n        dev: Optional[DevTag],\n        local: Optional[Local],\n    ) -&gt; V:\n        return evolve(self, pre=pre, post=post, dev=dev, local=local)\n\n    def with_pre(self: V, pre: PreTag) -&gt; V:\n\"\"\"Updates a version to include [`PreTag`][versions.segments.PreTag].\n\n        Arguments:\n            pre: The *pre-release* tag to include.\n\n        Returns:\n            The updated version.\n        \"\"\"\n        return self.set_pre(pre)\n\n    def with_post(self: V, post: PostTag) -&gt; V:\n\"\"\"Updates a version to include [`PostTag`][versions.segments.PostTag].\n\n        Arguments:\n            post: The *post-release* tag to include.\n\n        Returns:\n            The updated version.\n        \"\"\"\n        return self.set_post(post)\n\n    def with_dev(self: V, dev: DevTag) -&gt; V:\n\"\"\"Updates a version to include [`DevTag`][versions.segments.DevTag].\n\n        Arguments:\n            dev: The *dev-release* tag to include.\n\n        Returns:\n            The updated version.\n        \"\"\"\n        return self.set_dev(dev)\n\n    def with_tags(self: V, pre: PreTag, post: PostTag, dev: DevTag) -&gt; V:\n        return self.set_tags(pre, post, dev)\n\n    def with_local(self: V, local: Local) -&gt; V:\n\"\"\"Updates a version to include [`Local`][versions.segments.Local].\n\n        Arguments:\n            local: The *local* segment to include.\n\n        Returns:\n            The updated version.\n        \"\"\"\n        return self.set_local(local)\n\n    def with_dev_and_local(self: V, dev: DevTag, local: Local) -&gt; V:\n        return self.set_dev_and_local(dev, local)\n\n    def with_tags_and_local(self: V, pre: PreTag, post: PostTag, dev: DevTag, local: Local) -&gt; V:\n        return self.set_tags_and_local(pre, post, dev, local)\n\n    def without_pre(self: V) -&gt; V:\n\"\"\"Updates a version, removing any [`PreTag`][versions.segments.PreTag] from it.\n\n        Returns:\n            The updated version.\n        \"\"\"\n        return self.set_pre(None)\n\n    def without_post(self: V) -&gt; V:\n\"\"\"Updates a version, removing any [`PostTag`][versions.segments.PostTag] from it.\n\n        Returns:\n            The updated version.\n        \"\"\"\n        return self.set_post(None)\n\n    def without_dev(self: V) -&gt; V:\n\"\"\"Updates a version, removing any [`DevTag`][versions.segments.DevTag] from it.\n\n        Returns:\n            The updated version.\n        \"\"\"\n        return self.set_dev(None)\n\n    def without_tags(self: V) -&gt; V:\n        return self.set_tags(None, None, None)\n\n    def without_local(self: V) -&gt; V:\n\"\"\"Updates a version, removing any [`Local`][versions.segments.Local] segment from it.\n\n        Returns:\n            The updated version.\n        \"\"\"\n        return self.set_local(None)\n\n    def without_dev_and_local(self: V) -&gt; V:\n        return self.set_dev_and_local(None, None)\n\n    def without_tags_and_local(self: V) -&gt; V:\n        return self.set_tags_and_local(None, None, None, None)\n\n    def weaken(self, other: W) -&gt; W:\n\"\"\"Weakens the `other` version for further comparison.\n\n        Arguments:\n            other: The version to weaken.\n\n        Returns:\n            The weakened version.\n        \"\"\"\n        if not self.is_local() and other.is_local():\n            other = other.without_local()\n\n        if not self.is_post_release() and other.is_post_release():\n            other = other.without_post()\n\n        return other\n\n    def to_stable(self: V) -&gt; V:\n\"\"\"Forces a version to be stable.\n\n        Returns:\n            The stable version.\n        \"\"\"\n        return self if self.is_stable() else self.to_stable_unchecked()\n\n    def to_stable_unchecked(self: V) -&gt; V:\n\"\"\"Forces a version to be stable, without checking whether it is already stable.\n\n        Returns:\n            The stable version.\n        \"\"\"\n        return self.without_tags_and_local()\n\n    def next_breaking(self: V) -&gt; V:\n\"\"\"Returns the next breaking version.\n\n        This function is slightly convoluted due to how `0.x.y` and `0.0.z` versions are handled:\n\n        | version | next breaking |\n        |---------|---------------|\n        | `1.2.3` | `2.0.0`       |\n        | `1.2.0` | `2.0.0`       |\n        | `1.0.0` | `2.0.0`       |\n        | `0.2.3` | `0.3.0`       |\n        | `0.0.3` | `0.0.4`       |\n        | `0.0.0` | `0.0.1`       |\n        | `0.0`   | `0.1.0`       |\n        | `0`     | `1.0.0`       |\n\n        Returns:\n            The next breaking [`Version`][versions.version.Version].\n        \"\"\"\n        if not self.major:\n            if self.minor:\n                return self.next_minor()\n\n            if self.has_micro():\n                return self.next_micro()\n\n            if self.has_minor():\n                return self.next_minor()\n\n            return self.next_major()\n\n        return self.to_stable().next_major()\n\n    def normalize(self: V) -&gt; V:\n\"\"\"Normalizes all version tags.\n\n        Returns:\n            The normalized version.\n        \"\"\"\n        pre = self.pre\n\n        if pre is not None:\n            pre = pre.normalize()\n\n        post = self.post\n\n        if post is not None:\n            post = post.normalize()\n\n        dev = self.dev\n\n        if dev is not None:\n            dev = dev.normalize()\n\n        return self.set_tags(pre, post, dev)\n\n    @classmethod\n    def create(\n        cls: Type[V],\n        epoch: Optional[Epoch] = None,\n        release: Optional[Release] = None,\n        pre: Optional[PreTag] = None,\n        post: Optional[PostTag] = None,\n        dev: Optional[DevTag] = None,\n        local: Optional[Local] = None,\n    ) -&gt; V:\n\"\"\"Creates a [`Version`][versions.version.Version] from `epoch`, `release`,\n        `pre`, `post`, `dev` and `local`.\n\n        Arguments:\n            epoch: The *epoch* to use.\n            release: The *release* to use.\n            pre: The *pre-release* tag to use.\n            post: The *post-release* tag to use.\n            dev: The *dev-release* tag to use.\n            local: The *local* segment to use.\n\n        Returns:\n            The newly created [`Version`][versions.version.Version].\n        \"\"\"\n        if epoch is None:\n            epoch = Epoch()\n\n        if release is None:\n            release = Release()\n\n        return cls(epoch, release, pre, post, dev, local)\n\n    @classmethod\n    def from_parts(\n        cls: Type[V],\n        *parts: int,\n        epoch: Optional[Epoch] = None,\n        pre: Optional[PreTag] = None,\n        post: Optional[PostTag] = None,\n        dev: Optional[DevTag] = None,\n        local: Optional[Local] = None,\n    ) -&gt; V:\n\"\"\"Creates a [`Version`][versions.version.Version] from `parts`,\n        `epoch`, `pre`, `post`, `dev` and `local`.\n\n        Arguments:\n            *parts: The parts of the *release* to use.\n            epoch: The *epoch* to use.\n            pre: The *pre-release* tag to use.\n            post: The *post-release* tag to use.\n            dev: The *dev-release* tag to use.\n            local: The *local* segment to use.\n\n        Returns:\n            The newly created [`Version`][versions.version.Version].\n        \"\"\"\n        release = Release(parts)\n\n        return cls.create(epoch, release, pre, post, dev, local)\n\n    def matches(self, specification: Specification) -&gt; bool:\n\"\"\"Checks if a version matches the `specification`.\n\n        Arguments:\n            specification: The specification to check the version against.\n\n        Returns:\n            Whether the version matches the specification.\n        \"\"\"\n        return specification.accepts(self)\n</code></pre>"},{"location":"reference/version/#versions.version.Version.epoch","title":"<code>epoch: Epoch = field(factory=Epoch, eq=False, order=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The epoch segment of the version.</p>"},{"location":"reference/version/#versions.version.Version.release","title":"<code>release: Release = field(factory=Release, eq=False, order=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The release segment of the version.</p>"},{"location":"reference/version/#versions.version.Version.pre","title":"<code>pre: Optional[PreTag] = field(default=None, eq=False, order=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The pre-release tag of the version.</p>"},{"location":"reference/version/#versions.version.Version.post","title":"<code>post: Optional[PostTag] = field(default=None, eq=False, order=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The post-release tag of the version.</p>"},{"location":"reference/version/#versions.version.Version.dev","title":"<code>dev: Optional[DevTag] = field(default=None, eq=False, order=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The dev-release tag of the version.</p>"},{"location":"reference/version/#versions.version.Version.local","title":"<code>local: Optional[Local] = field(default=None, eq=False, order=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The local segment of the version.</p>"},{"location":"reference/version/#versions.version.Version.precision","title":"<code>precision: int</code>  <code>property</code>","text":"<p>The precision of the <code>Release</code>.</p>"},{"location":"reference/version/#versions.version.Version.last_index","title":"<code>last_index: int</code>  <code>property</code>","text":"<p>The last index of the <code>Release</code>.</p>"},{"location":"reference/version/#versions.version.Version.major","title":"<code>major: int</code>  <code>property</code>","text":"<p>The major part of the <code>Release</code>.</p>"},{"location":"reference/version/#versions.version.Version.minor","title":"<code>minor: int</code>  <code>property</code>","text":"<p>The minor part of the <code>Release</code>.</p>"},{"location":"reference/version/#versions.version.Version.micro","title":"<code>micro: int</code>  <code>property</code>","text":"<p>The micro part of the <code>Release</code>.</p>"},{"location":"reference/version/#versions.version.Version.patch","title":"<code>patch: int</code>  <code>property</code>","text":"<p>The patch part of the <code>Release</code>.</p> <p>This is equivalent to <code>micro</code>.</p>"},{"location":"reference/version/#versions.version.Version.extra","title":"<code>extra: Extra</code>  <code>property</code>","text":"<p>The extra parts of the <code>Release</code>.</p>"},{"location":"reference/version/#versions.version.Version.from_string","title":"<code>from_string(string: str) -&gt; V</code>  <code>classmethod</code>","text":"<p>Parses a <code>Version</code> from <code>string</code>.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>The string to parse.</p> required <p>Returns:</p> Type Description <code>V</code> <p>The parsed version.</p> Source code in <code>versions/version.py</code> <pre><code>@classmethod\ndef from_string(cls: Type[V], string: str) -&gt; V:\n\"\"\"Parses a [`Version`][versions.version.Version] from `string`.\n\n    Arguments:\n        string: The string to parse.\n\n    Returns:\n        The parsed version.\n    \"\"\"\n    return VersionParser(cls).parse(string)\n</code></pre>"},{"location":"reference/version/#versions.version.Version.to_string","title":"<code>to_string() -&gt; str</code>","text":"<p>Converts a <code>Version</code> to its string representation.</p> <p>Returns:</p> Type Description <code>str</code> <p>The version string.</p> Source code in <code>versions/version.py</code> <pre><code>def to_string(self) -&gt; str:\n\"\"\"Converts a [`Version`][versions.version.Version] to its string representation.\n\n    Returns:\n        The version string.\n    \"\"\"\n    return concat_empty(self.to_string_iterator())\n</code></pre>"},{"location":"reference/version/#versions.version.Version.to_short_string","title":"<code>to_short_string() -&gt; str</code>","text":"<p>Converts a <code>Version</code> to its short string representation.</p> <p>Returns:</p> Type Description <code>str</code> <p>The short version string.</p> Source code in <code>versions/version.py</code> <pre><code>def to_short_string(self) -&gt; str:\n\"\"\"Converts a [`Version`][versions.version.Version] to its *short* string representation.\n\n    Returns:\n        The *short* version string.\n    \"\"\"\n    return concat_empty(self.to_short_string_iterator())\n</code></pre>"},{"location":"reference/version/#versions.version.Version.to_pep440_string","title":"<code>to_pep440_string() -&gt; str</code>","text":"<p>Converts a <code>Version</code> to its PEP 440 representation.</p> <pre><code>version.to_pep440_string()\n</code></pre> <p>Is equivalent to the following:</p> <pre><code>version.normalize().to_short_string()\n</code></pre> <p>Returns:</p> Type Description <code>str</code> <p>The PEP 440 version string.</p> Source code in <code>versions/version.py</code> <pre><code>def to_pep440_string(self) -&gt; str:\n\"\"\"Converts a [`Version`][versions.version.Version] to its\n    [*PEP 440*](https://peps.python.org/pep-0440) representation.\n\n    ```python\n    version.to_pep440_string()\n    ```\n\n    Is equivalent to the following:\n\n    ```python\n    version.normalize().to_short_string()\n    ```\n\n    Returns:\n        The [*PEP 440*](https://peps.python.org/pep-0440) version string.\n    \"\"\"\n    return self.normalize().to_short_string()\n</code></pre>"},{"location":"reference/version/#versions.version.Version.get_at","title":"<code>get_at(index: int, default: int = DEFAULT_VALUE) -&gt; int</code>","text":"<p>Gets the <code>Release</code> part at the <code>index</code>, defaulting to <code>default</code>.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index of the part to get.</p> required <code>default</code> <code>int</code> <p>The default value to use.</p> <code>DEFAULT_VALUE</code> <p>Returns:</p> Type Description <code>int</code> <p>The release part at <code>index</code> or the <code>default</code> value.</p> Source code in <code>versions/version.py</code> <pre><code>def get_at(self, index: int, default: int = DEFAULT_VALUE) -&gt; int:\n\"\"\"Gets the [`Release`][versions.segments.Release] part at the `index`,\n    defaulting to `default`.\n\n    Arguments:\n        index: The index of the part to get.\n        default: The default value to use.\n\n    Returns:\n        The release part at `index` or the `default` value.\n    \"\"\"\n    return self.release.get_at(index, default)\n</code></pre>"},{"location":"reference/version/#versions.version.Version.get_at_unchecked","title":"<code>get_at_unchecked(index: int) -&gt; int</code>","text":"<p>Gets the <code>Release</code> part at the <code>index</code>.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index of the part to get.</p> required <p>Raises:</p> Type Description <code>IndexError</code> <p>The index is out-of-bounds.</p> <p>Returns:</p> Type Description <code>int</code> <p>The release part at the <code>index</code>.</p> Source code in <code>versions/version.py</code> <pre><code>def get_at_unchecked(self, index: int) -&gt; int:\n\"\"\"Gets the [`Release`][versions.segments.Release] part at the `index`.\n\n    Arguments:\n        index: The index of the part to get.\n\n    Raises:\n        IndexError: The index is *out-of-bounds*.\n\n    Returns:\n        The release part at the `index`.\n    \"\"\"\n    return self.release.get_at_unchecked(index)\n</code></pre>"},{"location":"reference/version/#versions.version.Version.is_semantic","title":"<code>is_semantic() -&gt; bool</code>","text":"<p>Checks if the <code>Release</code> matches the semantic versioning schema.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the release matches the <code>semver</code> schema.</p> Source code in <code>versions/version.py</code> <pre><code>def is_semantic(self) -&gt; bool:\n\"\"\"Checks if the [`Release`][versions.segments.Release]\n    matches the *semantic versioning* schema.\n\n    Returns:\n        Whether the release matches the [`semver`](https://semver.org/) schema.\n    \"\"\"\n    return self.release.is_semantic()\n</code></pre>"},{"location":"reference/version/#versions.version.Version.to_semantic","title":"<code>to_semantic() -&gt; V</code>","text":"<p>Converts the <code>Release</code> to match the <code>semver</code> schema.</p> <p>Returns:</p> Type Description <code>V</code> <p>The converted version.</p> Source code in <code>versions/version.py</code> <pre><code>def to_semantic(self: V) -&gt; V:\n\"\"\"Converts the [`Release`][versions.segments.Release]\n    to match the [`semver`](https://semver.org/) schema.\n\n    Returns:\n        The converted version.\n    \"\"\"\n    return evolve(self, release=self.release.to_semantic())\n</code></pre>"},{"location":"reference/version/#versions.version.Version.set_major","title":"<code>set_major(value: int) -&gt; V</code>","text":"<p>Sets the major part of the <code>Release</code> to the <code>value</code>.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>The value to set the major part to.</p> required <p>Returns:</p> Type Description <code>V</code> <p>The updated version.</p> Source code in <code>versions/version.py</code> <pre><code>def set_major(self: V, value: int) -&gt; V:\n\"\"\"Sets the *major* part of the [`Release`][versions.segments.Release] to the `value`.\n\n    Arguments:\n        value: The value to set the *major* part to.\n\n    Returns:\n        The updated version.\n    \"\"\"\n    return self.set_release(self.release.set_major(value))\n</code></pre>"},{"location":"reference/version/#versions.version.Version.set_minor","title":"<code>set_minor(value: int) -&gt; V</code>","text":"<p>Sets the minor part of the <code>Release</code> to the <code>value</code>.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>The value to set the minor part to.</p> required <p>Returns:</p> Type Description <code>V</code> <p>The updated version.</p> Source code in <code>versions/version.py</code> <pre><code>def set_minor(self: V, value: int) -&gt; V:\n\"\"\"Sets the *minor* part of the [`Release`][versions.segments.Release] to the `value`.\n\n    Arguments:\n        value: The value to set the *minor* part to.\n\n    Returns:\n        The updated version.\n    \"\"\"\n    return self.set_release(self.release.set_minor(value))\n</code></pre>"},{"location":"reference/version/#versions.version.Version.set_micro","title":"<code>set_micro(value: int) -&gt; V</code>","text":"<p>Sets the micro part of the <code>Release</code> to the <code>value</code>.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>The value to set the micro part to.</p> required <p>Returns:</p> Type Description <code>V</code> <p>The updated version.</p> Source code in <code>versions/version.py</code> <pre><code>def set_micro(self: V, value: int) -&gt; V:\n\"\"\"Sets the *micro* part of the [`Release`][versions.segments.Release] to the `value`.\n\n    Arguments:\n        value: The value to set the *micro* part to.\n\n    Returns:\n        The updated version.\n    \"\"\"\n    return self.set_release(self.release.set_micro(value))\n</code></pre>"},{"location":"reference/version/#versions.version.Version.set_patch","title":"<code>set_patch(value: int) -&gt; V</code>","text":"<p>Sets the patch part of the <code>Release</code> to the <code>value</code>.</p> <p>This is equivalent to <code>set_micro</code>.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>The value to set the patch part to.</p> required <p>Returns:</p> Type Description <code>V</code> <p>The updated version.</p> Source code in <code>versions/version.py</code> <pre><code>def set_patch(self: V, value: int) -&gt; V:\n\"\"\"Sets the *patch* part of the [`Release`][versions.segments.Release] to the `value`.\n\n    This is equivalent to [`set_micro`][versions.version.Version.set_micro].\n\n    Arguments:\n        value: The value to set the *patch* part to.\n\n    Returns:\n        The updated version.\n    \"\"\"\n    return self.set_release(self.release.set_patch(value))\n</code></pre>"},{"location":"reference/version/#versions.version.Version.set_at","title":"<code>set_at(index: int, value: int) -&gt; V</code>","text":"<p>Sets the <code>Release</code> part at the <code>index</code> to the <code>value</code>.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index to set the <code>value</code> at.</p> required <code>value</code> <code>int</code> <p>The value to set the part to.</p> required <p>Returns:</p> Type Description <code>V</code> <p>The updated version.</p> Source code in <code>versions/version.py</code> <pre><code>def set_at(self: V, index: int, value: int) -&gt; V:\n\"\"\"Sets the [`Release`][versions.segments.Release] part at the `index` to the `value`.\n\n    Arguments:\n        index: The index to set the `value` at.\n        value: The value to set the part to.\n\n    Returns:\n        The updated version.\n    \"\"\"\n    return self.set_release(self.release.set_at(index, value))\n</code></pre>"},{"location":"reference/version/#versions.version.Version.set_at_unchecked","title":"<code>set_at_unchecked(index: int, value: int) -&gt; V</code>","text":"<p>Sets the <code>Release</code> part at the <code>index</code> to the <code>value</code>.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index to set the <code>value</code> at.</p> required <code>value</code> <code>int</code> <p>The value to set the part to.</p> required <p>Raises:</p> Type Description <code>IndexError</code> <p>The index is out-of-bounds.</p> <p>Returns:</p> Type Description <code>V</code> <p>The updated version.</p> Source code in <code>versions/version.py</code> <pre><code>def set_at_unchecked(self: V, index: int, value: int) -&gt; V:\n\"\"\"Sets the [`Release`][versions.segments.Release] part at the `index` to the `value`.\n\n    Arguments:\n        index: The index to set the `value` at.\n        value: The value to set the part to.\n\n    Raises:\n        IndexError: The index is *out-of-bounds*.\n\n    Returns:\n        The updated version.\n    \"\"\"\n    return self.set_release(self.release.set_at_unchecked(index, value))\n</code></pre>"},{"location":"reference/version/#versions.version.Version.next_major","title":"<code>next_major() -&gt; V</code>","text":"<p>Bumps the major part of the <code>Release</code> if the version is stable, otherwise converts the version to be stable.</p> <p>Returns:</p> Type Description <code>V</code> <p>The bumped version.</p> Source code in <code>versions/version.py</code> <pre><code>def next_major(self: V) -&gt; V:\n\"\"\"Bumps the *major* part of the [`Release`][versions.segments.Release]\n    if the version is stable, otherwise converts the version to be stable.\n\n    Returns:\n        The bumped version.\n    \"\"\"\n    release = self.release\n\n    if self.is_stable():\n        release = release.next_major()\n\n    return self.create(self.epoch, release)\n</code></pre>"},{"location":"reference/version/#versions.version.Version.next_minor","title":"<code>next_minor() -&gt; V</code>","text":"<p>Bumps the minor part of the <code>Release</code> if the version is stable, otherwise converts the version to be stable.</p> <p>Returns:</p> Type Description <code>V</code> <p>The bumped version.</p> Source code in <code>versions/version.py</code> <pre><code>def next_minor(self: V) -&gt; V:\n\"\"\"Bumps the *minor* part of the [`Release`][versions.segments.Release]\n    if the version is stable, otherwise converts the version to be stable.\n\n    Returns:\n        The bumped version.\n    \"\"\"\n    release = self.release\n\n    if self.is_stable():\n        release = release.next_minor()\n\n    return self.create(self.epoch, release)\n</code></pre>"},{"location":"reference/version/#versions.version.Version.next_micro","title":"<code>next_micro() -&gt; V</code>","text":"<p>Bumps the micro part of the <code>Release</code> if the version is stable, otherwise converts the version to be stable.</p> <p>Returns:</p> Type Description <code>V</code> <p>The bumped version.</p> Source code in <code>versions/version.py</code> <pre><code>def next_micro(self: V) -&gt; V:\n\"\"\"Bumps the *micro* part of the [`Release`][versions.segments.Release]\n    if the version is stable, otherwise converts the version to be stable.\n\n    Returns:\n        The bumped version.\n    \"\"\"\n    release = self.release\n\n    if self.is_stable():\n        release = release.next_micro()\n\n    return self.create(self.epoch, release)\n</code></pre>"},{"location":"reference/version/#versions.version.Version.next_patch","title":"<code>next_patch() -&gt; V</code>","text":"<p>Bumps the patch part of the <code>Release</code> if the version is stable, otherwise converts the version to be stable.</p> <p>This is equivalent to <code>next_micro</code>.</p> <p>Returns:</p> Type Description <code>V</code> <p>The bumped version.</p> Source code in <code>versions/version.py</code> <pre><code>def next_patch(self: V) -&gt; V:\n\"\"\"Bumps the *patch* part of the [`Release`][versions.segments.Release]\n    if the version is stable, otherwise converts the version to be stable.\n\n    This is equivalent to [`next_micro`][versions.version.Version.next_micro].\n\n    Returns:\n        The bumped version.\n    \"\"\"\n    release = self.release\n\n    if self.is_stable():\n        release = release.next_patch()\n\n    return self.create(self.epoch, release)\n</code></pre>"},{"location":"reference/version/#versions.version.Version.next_at","title":"<code>next_at(index: int) -&gt; V</code>","text":"<p>Bumps the part of the <code>Release</code> at the <code>index</code> if the version is stable, otherwise converts the version to be stable.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index to bump the part at.</p> required <p>Returns:</p> Type Description <code>V</code> <p>The bumped version.</p> Source code in <code>versions/version.py</code> <pre><code>def next_at(self: V, index: int) -&gt; V:\n\"\"\"Bumps the part of the [`Release`][versions.segments.Release] at the `index`\n    if the version is stable, otherwise converts the version to be stable.\n\n    Arguments:\n        index: The index to bump the part at.\n\n    Returns:\n        The bumped version.\n    \"\"\"\n    release = self.release\n\n    if self.is_stable():\n        release = release.next_at(index)\n\n    return self.create(self.epoch, release)\n</code></pre>"},{"location":"reference/version/#versions.version.Version.has_major","title":"<code>has_major() -&gt; bool</code>","text":"<p>Checks if the <code>Release</code> has the major part.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the major part is present.</p> Source code in <code>versions/version.py</code> <pre><code>def has_major(self) -&gt; bool:\n\"\"\"Checks if the [`Release`][versions.segments.Release] has the *major* part.\n\n    Returns:\n        Whether the *major* part is present.\n    \"\"\"\n    return self.release.has_major()\n</code></pre>"},{"location":"reference/version/#versions.version.Version.has_minor","title":"<code>has_minor() -&gt; bool</code>","text":"<p>Checks if the <code>Release</code> has the minor part.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the minor part is present.</p> Source code in <code>versions/version.py</code> <pre><code>def has_minor(self) -&gt; bool:\n\"\"\"Checks if the [`Release`][versions.segments.Release] has the *minor* part.\n\n    Returns:\n        Whether the *minor* part is present.\n    \"\"\"\n    return self.release.has_minor()\n</code></pre>"},{"location":"reference/version/#versions.version.Version.has_micro","title":"<code>has_micro() -&gt; bool</code>","text":"<p>Checks if the <code>Release</code> has the micro part.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the micro part is present.</p> Source code in <code>versions/version.py</code> <pre><code>def has_micro(self) -&gt; bool:\n\"\"\"Checks if the [`Release`][versions.segments.Release] has the *micro* part.\n\n    Returns:\n        Whether the *micro* part is present.\n    \"\"\"\n    return self.release.has_micro()\n</code></pre>"},{"location":"reference/version/#versions.version.Version.has_patch","title":"<code>has_patch() -&gt; bool</code>","text":"<p>Checks if the <code>Release</code> has the patch part.</p> <p>This is equivalent to <code>has_micro</code>.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the patch part is present.</p> Source code in <code>versions/version.py</code> <pre><code>def has_patch(self) -&gt; bool:\n\"\"\"Checks if the [`Release`][versions.segments.Release] has the *patch* part.\n\n    This is equivalent to [`has_micro`][versions.version.Version.has_micro].\n\n    Returns:\n        Whether the *patch* part is present.\n    \"\"\"\n    return self.release.has_patch()\n</code></pre>"},{"location":"reference/version/#versions.version.Version.has_extra","title":"<code>has_extra() -&gt; bool</code>","text":"<p>Checks if the <code>Release</code> has any extra parts.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the extra parts are present.</p> Source code in <code>versions/version.py</code> <pre><code>def has_extra(self) -&gt; bool:\n\"\"\"Checks if the [`Release`][versions.segments.Release] has any *extra* parts.\n\n    Returns:\n        Whether the *extra* parts are present.\n    \"\"\"\n    return self.release.has_extra()\n</code></pre>"},{"location":"reference/version/#versions.version.Version.has_at","title":"<code>has_at(index: int) -&gt; bool</code>","text":"<p>Checks if the <code>Release</code> has a part at the <code>index</code>.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the part at the <code>index</code> is present.</p> Source code in <code>versions/version.py</code> <pre><code>def has_at(self, index: int) -&gt; bool:\n\"\"\"Checks if the [`Release`][versions.segments.Release] has a part at the `index`.\n\n    Returns:\n        Whether the part at the `index` is present.\n    \"\"\"\n    return self.release.has_at(index)\n</code></pre>"},{"location":"reference/version/#versions.version.Version.pad_to","title":"<code>pad_to(length: int, padding: int = DEFAULT_PADDING) -&gt; V</code>","text":"<p>Pads the <code>Release</code> to the <code>length</code> with <code>padding</code>.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>The length to pad the release to.</p> required <code>padding</code> <code>int</code> <p>The padding to use.</p> <code>DEFAULT_PADDING</code> <p>Returns:</p> Type Description <code>V</code> <p>The padded version.</p> Source code in <code>versions/version.py</code> <pre><code>def pad_to(self: V, length: int, padding: int = DEFAULT_PADDING) -&gt; V:\n\"\"\"Pads the [`Release`][versions.segments.Release] to the `length` with `padding`.\n\n    Arguments:\n        length: The length to pad the release to.\n        padding: The padding to use.\n\n    Returns:\n        The padded version.\n    \"\"\"\n    return self.set_release(self.release.pad_to(length, padding))\n</code></pre>"},{"location":"reference/version/#versions.version.Version.pad_to_index","title":"<code>pad_to_index(index: int, padding: int = DEFAULT_PADDING) -&gt; V</code>","text":"<p>Pads the <code>Release</code> to the <code>index</code> with <code>padding</code>.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index to pad the release to.</p> required <code>padding</code> <code>int</code> <p>The padding to use.</p> <code>DEFAULT_PADDING</code> <p>Returns:</p> Type Description <code>V</code> <p>The padded version.</p> Source code in <code>versions/version.py</code> <pre><code>def pad_to_index(self: V, index: int, padding: int = DEFAULT_PADDING) -&gt; V:\n\"\"\"Pads the [`Release`][versions.segments.Release] to the `index` with `padding`.\n\n    Arguments:\n        index: The index to pad the release to.\n        padding: The padding to use.\n\n    Returns:\n        The padded version.\n    \"\"\"\n    return self.set_release(self.release.pad_to_index(index, padding))\n</code></pre>"},{"location":"reference/version/#versions.version.Version.pad_to_next","title":"<code>pad_to_next(padding: int = DEFAULT_PADDING) -&gt; V</code>","text":"<p>Pads the <code>Release</code> to the next index.</p> <p>Parameters:</p> Name Type Description Default <code>padding</code> <code>int</code> <p>The padding to use.</p> <code>DEFAULT_PADDING</code> <p>Returns:</p> Type Description <code>V</code> <p>The padded version.</p> Source code in <code>versions/version.py</code> <pre><code>def pad_to_next(self: V, padding: int = DEFAULT_PADDING) -&gt; V:\n\"\"\"Pads the [`Release`][versions.segments.Release] to the next index.\n\n    Arguments:\n        padding: The padding to use.\n\n    Returns:\n        The padded version.\n    \"\"\"\n    return self.set_release(self.release.pad_to_next(padding))\n</code></pre>"},{"location":"reference/version/#versions.version.Version.is_pre_release","title":"<code>is_pre_release() -&gt; bool</code>","text":"<p>Checks if the version is pre-release.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the version is pre-release.</p> Source code in <code>versions/version.py</code> <pre><code>def is_pre_release(self) -&gt; bool:\n\"\"\"Checks if the version is *pre-release*.\n\n    Returns:\n        Whether the version is *pre-release*.\n    \"\"\"\n    return self.pre is not None\n</code></pre>"},{"location":"reference/version/#versions.version.Version.is_post_release","title":"<code>is_post_release() -&gt; bool</code>","text":"<p>Checks if the version is post-release.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the version is post-release.</p> Source code in <code>versions/version.py</code> <pre><code>def is_post_release(self) -&gt; bool:\n\"\"\"Checks if the version is *post-release*.\n\n    Returns:\n        Whether the version is *post-release*.\n    \"\"\"\n    return self.post is not None\n</code></pre>"},{"location":"reference/version/#versions.version.Version.is_dev_release","title":"<code>is_dev_release() -&gt; bool</code>","text":"<p>Checks if the version is dev-release.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the version is dev-release.</p> Source code in <code>versions/version.py</code> <pre><code>def is_dev_release(self) -&gt; bool:\n\"\"\"Checks if the version is *dev-release*.\n\n    Returns:\n        Whether the version is *dev-release*.\n    \"\"\"\n    return self.dev is not None\n</code></pre>"},{"location":"reference/version/#versions.version.Version.is_local","title":"<code>is_local() -&gt; bool</code>","text":"<p>Checks if the version is local.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the version is local.</p> Source code in <code>versions/version.py</code> <pre><code>def is_local(self) -&gt; bool:\n\"\"\"Checks if the version is *local*.\n\n    Returns:\n        Whether the version is *local*.\n    \"\"\"\n    return self.local is not None\n</code></pre>"},{"location":"reference/version/#versions.version.Version.is_unstable","title":"<code>is_unstable() -&gt; bool</code>","text":"<p>Checks if the version is unstable.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the version is unstable.</p> Source code in <code>versions/version.py</code> <pre><code>def is_unstable(self) -&gt; bool:\n\"\"\"Checks if the version is *unstable*.\n\n    Returns:\n        Whether the version is *unstable*.\n    \"\"\"\n    return self.is_pre_release() or self.is_dev_release()\n</code></pre>"},{"location":"reference/version/#versions.version.Version.is_stable","title":"<code>is_stable() -&gt; bool</code>","text":"<p>Checks if the version is stable.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the version is stable.</p> Source code in <code>versions/version.py</code> <pre><code>def is_stable(self) -&gt; bool:\n\"\"\"Checks if the version is *stable*.\n\n    Returns:\n        Whether the version is *stable*.\n    \"\"\"\n    return not self.is_unstable()\n</code></pre>"},{"location":"reference/version/#versions.version.Version.next_pre","title":"<code>next_pre() -&gt; V</code>","text":"<p>Bumps the <code>PreTag</code> if it is present, otherwise adds one to the version.</p> <p>Returns:</p> Type Description <code>V</code> <p>The bumped version.</p> Source code in <code>versions/version.py</code> <pre><code>def next_pre(self: V) -&gt; V:\n\"\"\"Bumps the [`PreTag`][versions.segments.PreTag] if it is present,\n    otherwise adds one to the version.\n\n    Returns:\n        The bumped version.\n    \"\"\"\n    pre = self.pre\n\n    if pre is None:\n        pre = PreTag()\n\n    else:\n        pre = pre.next()\n\n    return self.create(self.epoch, self.release, pre)\n</code></pre>"},{"location":"reference/version/#versions.version.Version.next_pre_phase","title":"<code>next_pre_phase() -&gt; Optional[V]</code>","text":"<p>Bumps the <code>PreTag</code> phase if it is present (and if possible), otherwise adds one to the version.</p> <p>Returns:</p> Type Description <code>Optional[V]</code> <p>The bumped version (if the next <code>PreTag</code> is present).</p> Source code in <code>versions/version.py</code> <pre><code>def next_pre_phase(self: V) -&gt; Optional[V]:\n\"\"\"Bumps the [`PreTag`][versions.segments.PreTag] phase if it is present (and if possible),\n    otherwise adds one to the version.\n\n    Returns:\n        The bumped version (if the next [`PreTag`][versions.segments.PreTag] is present).\n    \"\"\"\n    pre = self.pre\n\n    if pre is None:\n        pre = PreTag()\n\n    else:\n        pre = pre.next_phase()\n\n        if pre is None:\n            return None\n\n    return self.without_tags_and_local().with_pre(pre)\n</code></pre>"},{"location":"reference/version/#versions.version.Version.next_post","title":"<code>next_post() -&gt; V</code>","text":"<p>Bumps the <code>PostTag</code> if it is present, otherwise adds one to the version.</p> <p>Returns:</p> Type Description <code>V</code> <p>The bumped version.</p> Source code in <code>versions/version.py</code> <pre><code>def next_post(self: V) -&gt; V:\n\"\"\"Bumps the [`PostTag`][versions.segments.PostTag] if it is present,\n    otherwise adds one to the version.\n\n    Returns:\n        The bumped version.\n    \"\"\"\n    post = self.post\n\n    if post is None:\n        post = PostTag()\n\n    else:\n        post = post.next()\n\n    return self.with_post(post).without_dev_and_local()\n</code></pre>"},{"location":"reference/version/#versions.version.Version.next_dev","title":"<code>next_dev() -&gt; V</code>","text":"<p>Bumps the <code>DevTag</code> if it is present, otherwise adds one to the version.</p> <p>Returns:</p> Type Description <code>V</code> <p>The bumped version.</p> Source code in <code>versions/version.py</code> <pre><code>def next_dev(self: V) -&gt; V:\n\"\"\"Bumps the [`DevTag`][versions.segments.DevTag] if it is present,\n    otherwise adds one to the version.\n\n    Returns:\n        The bumped version.\n    \"\"\"\n    dev = self.dev\n\n    if dev is None:\n        dev = DevTag()\n\n    else:\n        dev = dev.next()\n\n    return self.with_dev(dev).without_local()\n</code></pre>"},{"location":"reference/version/#versions.version.Version.with_pre","title":"<code>with_pre(pre: PreTag) -&gt; V</code>","text":"<p>Updates a version to include <code>PreTag</code>.</p> <p>Parameters:</p> Name Type Description Default <code>pre</code> <code>PreTag</code> <p>The pre-release tag to include.</p> required <p>Returns:</p> Type Description <code>V</code> <p>The updated version.</p> Source code in <code>versions/version.py</code> <pre><code>def with_pre(self: V, pre: PreTag) -&gt; V:\n\"\"\"Updates a version to include [`PreTag`][versions.segments.PreTag].\n\n    Arguments:\n        pre: The *pre-release* tag to include.\n\n    Returns:\n        The updated version.\n    \"\"\"\n    return self.set_pre(pre)\n</code></pre>"},{"location":"reference/version/#versions.version.Version.with_post","title":"<code>with_post(post: PostTag) -&gt; V</code>","text":"<p>Updates a version to include <code>PostTag</code>.</p> <p>Parameters:</p> Name Type Description Default <code>post</code> <code>PostTag</code> <p>The post-release tag to include.</p> required <p>Returns:</p> Type Description <code>V</code> <p>The updated version.</p> Source code in <code>versions/version.py</code> <pre><code>def with_post(self: V, post: PostTag) -&gt; V:\n\"\"\"Updates a version to include [`PostTag`][versions.segments.PostTag].\n\n    Arguments:\n        post: The *post-release* tag to include.\n\n    Returns:\n        The updated version.\n    \"\"\"\n    return self.set_post(post)\n</code></pre>"},{"location":"reference/version/#versions.version.Version.with_dev","title":"<code>with_dev(dev: DevTag) -&gt; V</code>","text":"<p>Updates a version to include <code>DevTag</code>.</p> <p>Parameters:</p> Name Type Description Default <code>dev</code> <code>DevTag</code> <p>The dev-release tag to include.</p> required <p>Returns:</p> Type Description <code>V</code> <p>The updated version.</p> Source code in <code>versions/version.py</code> <pre><code>def with_dev(self: V, dev: DevTag) -&gt; V:\n\"\"\"Updates a version to include [`DevTag`][versions.segments.DevTag].\n\n    Arguments:\n        dev: The *dev-release* tag to include.\n\n    Returns:\n        The updated version.\n    \"\"\"\n    return self.set_dev(dev)\n</code></pre>"},{"location":"reference/version/#versions.version.Version.with_local","title":"<code>with_local(local: Local) -&gt; V</code>","text":"<p>Updates a version to include <code>Local</code>.</p> <p>Parameters:</p> Name Type Description Default <code>local</code> <code>Local</code> <p>The local segment to include.</p> required <p>Returns:</p> Type Description <code>V</code> <p>The updated version.</p> Source code in <code>versions/version.py</code> <pre><code>def with_local(self: V, local: Local) -&gt; V:\n\"\"\"Updates a version to include [`Local`][versions.segments.Local].\n\n    Arguments:\n        local: The *local* segment to include.\n\n    Returns:\n        The updated version.\n    \"\"\"\n    return self.set_local(local)\n</code></pre>"},{"location":"reference/version/#versions.version.Version.without_pre","title":"<code>without_pre() -&gt; V</code>","text":"<p>Updates a version, removing any <code>PreTag</code> from it.</p> <p>Returns:</p> Type Description <code>V</code> <p>The updated version.</p> Source code in <code>versions/version.py</code> <pre><code>def without_pre(self: V) -&gt; V:\n\"\"\"Updates a version, removing any [`PreTag`][versions.segments.PreTag] from it.\n\n    Returns:\n        The updated version.\n    \"\"\"\n    return self.set_pre(None)\n</code></pre>"},{"location":"reference/version/#versions.version.Version.without_post","title":"<code>without_post() -&gt; V</code>","text":"<p>Updates a version, removing any <code>PostTag</code> from it.</p> <p>Returns:</p> Type Description <code>V</code> <p>The updated version.</p> Source code in <code>versions/version.py</code> <pre><code>def without_post(self: V) -&gt; V:\n\"\"\"Updates a version, removing any [`PostTag`][versions.segments.PostTag] from it.\n\n    Returns:\n        The updated version.\n    \"\"\"\n    return self.set_post(None)\n</code></pre>"},{"location":"reference/version/#versions.version.Version.without_dev","title":"<code>without_dev() -&gt; V</code>","text":"<p>Updates a version, removing any <code>DevTag</code> from it.</p> <p>Returns:</p> Type Description <code>V</code> <p>The updated version.</p> Source code in <code>versions/version.py</code> <pre><code>def without_dev(self: V) -&gt; V:\n\"\"\"Updates a version, removing any [`DevTag`][versions.segments.DevTag] from it.\n\n    Returns:\n        The updated version.\n    \"\"\"\n    return self.set_dev(None)\n</code></pre>"},{"location":"reference/version/#versions.version.Version.without_local","title":"<code>without_local() -&gt; V</code>","text":"<p>Updates a version, removing any <code>Local</code> segment from it.</p> <p>Returns:</p> Type Description <code>V</code> <p>The updated version.</p> Source code in <code>versions/version.py</code> <pre><code>def without_local(self: V) -&gt; V:\n\"\"\"Updates a version, removing any [`Local`][versions.segments.Local] segment from it.\n\n    Returns:\n        The updated version.\n    \"\"\"\n    return self.set_local(None)\n</code></pre>"},{"location":"reference/version/#versions.version.Version.weaken","title":"<code>weaken(other: W) -&gt; W</code>","text":"<p>Weakens the <code>other</code> version for further comparison.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>W</code> <p>The version to weaken.</p> required <p>Returns:</p> Type Description <code>W</code> <p>The weakened version.</p> Source code in <code>versions/version.py</code> <pre><code>def weaken(self, other: W) -&gt; W:\n\"\"\"Weakens the `other` version for further comparison.\n\n    Arguments:\n        other: The version to weaken.\n\n    Returns:\n        The weakened version.\n    \"\"\"\n    if not self.is_local() and other.is_local():\n        other = other.without_local()\n\n    if not self.is_post_release() and other.is_post_release():\n        other = other.without_post()\n\n    return other\n</code></pre>"},{"location":"reference/version/#versions.version.Version.to_stable","title":"<code>to_stable() -&gt; V</code>","text":"<p>Forces a version to be stable.</p> <p>Returns:</p> Type Description <code>V</code> <p>The stable version.</p> Source code in <code>versions/version.py</code> <pre><code>def to_stable(self: V) -&gt; V:\n\"\"\"Forces a version to be stable.\n\n    Returns:\n        The stable version.\n    \"\"\"\n    return self if self.is_stable() else self.to_stable_unchecked()\n</code></pre>"},{"location":"reference/version/#versions.version.Version.to_stable_unchecked","title":"<code>to_stable_unchecked() -&gt; V</code>","text":"<p>Forces a version to be stable, without checking whether it is already stable.</p> <p>Returns:</p> Type Description <code>V</code> <p>The stable version.</p> Source code in <code>versions/version.py</code> <pre><code>def to_stable_unchecked(self: V) -&gt; V:\n\"\"\"Forces a version to be stable, without checking whether it is already stable.\n\n    Returns:\n        The stable version.\n    \"\"\"\n    return self.without_tags_and_local()\n</code></pre>"},{"location":"reference/version/#versions.version.Version.next_breaking","title":"<code>next_breaking() -&gt; V</code>","text":"<p>Returns the next breaking version.</p> <p>This function is slightly convoluted due to how <code>0.x.y</code> and <code>0.0.z</code> versions are handled:</p> version next breaking <code>1.2.3</code> <code>2.0.0</code> <code>1.2.0</code> <code>2.0.0</code> <code>1.0.0</code> <code>2.0.0</code> <code>0.2.3</code> <code>0.3.0</code> <code>0.0.3</code> <code>0.0.4</code> <code>0.0.0</code> <code>0.0.1</code> <code>0.0</code> <code>0.1.0</code> <code>0</code> <code>1.0.0</code> <p>Returns:</p> Type Description <code>V</code> <p>The next breaking <code>Version</code>.</p> Source code in <code>versions/version.py</code> <pre><code>def next_breaking(self: V) -&gt; V:\n\"\"\"Returns the next breaking version.\n\n    This function is slightly convoluted due to how `0.x.y` and `0.0.z` versions are handled:\n\n    | version | next breaking |\n    |---------|---------------|\n    | `1.2.3` | `2.0.0`       |\n    | `1.2.0` | `2.0.0`       |\n    | `1.0.0` | `2.0.0`       |\n    | `0.2.3` | `0.3.0`       |\n    | `0.0.3` | `0.0.4`       |\n    | `0.0.0` | `0.0.1`       |\n    | `0.0`   | `0.1.0`       |\n    | `0`     | `1.0.0`       |\n\n    Returns:\n        The next breaking [`Version`][versions.version.Version].\n    \"\"\"\n    if not self.major:\n        if self.minor:\n            return self.next_minor()\n\n        if self.has_micro():\n            return self.next_micro()\n\n        if self.has_minor():\n            return self.next_minor()\n\n        return self.next_major()\n\n    return self.to_stable().next_major()\n</code></pre>"},{"location":"reference/version/#versions.version.Version.normalize","title":"<code>normalize() -&gt; V</code>","text":"<p>Normalizes all version tags.</p> <p>Returns:</p> Type Description <code>V</code> <p>The normalized version.</p> Source code in <code>versions/version.py</code> <pre><code>def normalize(self: V) -&gt; V:\n\"\"\"Normalizes all version tags.\n\n    Returns:\n        The normalized version.\n    \"\"\"\n    pre = self.pre\n\n    if pre is not None:\n        pre = pre.normalize()\n\n    post = self.post\n\n    if post is not None:\n        post = post.normalize()\n\n    dev = self.dev\n\n    if dev is not None:\n        dev = dev.normalize()\n\n    return self.set_tags(pre, post, dev)\n</code></pre>"},{"location":"reference/version/#versions.version.Version.create","title":"<code>create(epoch: Optional[Epoch] = None, release: Optional[Release] = None, pre: Optional[PreTag] = None, post: Optional[PostTag] = None, dev: Optional[DevTag] = None, local: Optional[Local] = None) -&gt; V</code>  <code>classmethod</code>","text":"<p>Creates a <code>Version</code> from <code>epoch</code>, <code>release</code>, <code>pre</code>, <code>post</code>, <code>dev</code> and <code>local</code>.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Optional[Epoch]</code> <p>The epoch to use.</p> <code>None</code> <code>release</code> <code>Optional[Release]</code> <p>The release to use.</p> <code>None</code> <code>pre</code> <code>Optional[PreTag]</code> <p>The pre-release tag to use.</p> <code>None</code> <code>post</code> <code>Optional[PostTag]</code> <p>The post-release tag to use.</p> <code>None</code> <code>dev</code> <code>Optional[DevTag]</code> <p>The dev-release tag to use.</p> <code>None</code> <code>local</code> <code>Optional[Local]</code> <p>The local segment to use.</p> <code>None</code> <p>Returns:</p> Type Description <code>V</code> <p>The newly created <code>Version</code>.</p> Source code in <code>versions/version.py</code> <pre><code>@classmethod\ndef create(\n    cls: Type[V],\n    epoch: Optional[Epoch] = None,\n    release: Optional[Release] = None,\n    pre: Optional[PreTag] = None,\n    post: Optional[PostTag] = None,\n    dev: Optional[DevTag] = None,\n    local: Optional[Local] = None,\n) -&gt; V:\n\"\"\"Creates a [`Version`][versions.version.Version] from `epoch`, `release`,\n    `pre`, `post`, `dev` and `local`.\n\n    Arguments:\n        epoch: The *epoch* to use.\n        release: The *release* to use.\n        pre: The *pre-release* tag to use.\n        post: The *post-release* tag to use.\n        dev: The *dev-release* tag to use.\n        local: The *local* segment to use.\n\n    Returns:\n        The newly created [`Version`][versions.version.Version].\n    \"\"\"\n    if epoch is None:\n        epoch = Epoch()\n\n    if release is None:\n        release = Release()\n\n    return cls(epoch, release, pre, post, dev, local)\n</code></pre>"},{"location":"reference/version/#versions.version.Version.from_parts","title":"<code>from_parts(*parts: int, epoch: Optional[Epoch] = None, pre: Optional[PreTag] = None, post: Optional[PostTag] = None, dev: Optional[DevTag] = None, local: Optional[Local] = None) -&gt; V</code>  <code>classmethod</code>","text":"<p>Creates a <code>Version</code> from <code>parts</code>, <code>epoch</code>, <code>pre</code>, <code>post</code>, <code>dev</code> and <code>local</code>.</p> <p>Parameters:</p> Name Type Description Default <code>*parts</code> <code>int</code> <p>The parts of the release to use.</p> <code>()</code> <code>epoch</code> <code>Optional[Epoch]</code> <p>The epoch to use.</p> <code>None</code> <code>pre</code> <code>Optional[PreTag]</code> <p>The pre-release tag to use.</p> <code>None</code> <code>post</code> <code>Optional[PostTag]</code> <p>The post-release tag to use.</p> <code>None</code> <code>dev</code> <code>Optional[DevTag]</code> <p>The dev-release tag to use.</p> <code>None</code> <code>local</code> <code>Optional[Local]</code> <p>The local segment to use.</p> <code>None</code> <p>Returns:</p> Type Description <code>V</code> <p>The newly created <code>Version</code>.</p> Source code in <code>versions/version.py</code> <pre><code>@classmethod\ndef from_parts(\n    cls: Type[V],\n    *parts: int,\n    epoch: Optional[Epoch] = None,\n    pre: Optional[PreTag] = None,\n    post: Optional[PostTag] = None,\n    dev: Optional[DevTag] = None,\n    local: Optional[Local] = None,\n) -&gt; V:\n\"\"\"Creates a [`Version`][versions.version.Version] from `parts`,\n    `epoch`, `pre`, `post`, `dev` and `local`.\n\n    Arguments:\n        *parts: The parts of the *release* to use.\n        epoch: The *epoch* to use.\n        pre: The *pre-release* tag to use.\n        post: The *post-release* tag to use.\n        dev: The *dev-release* tag to use.\n        local: The *local* segment to use.\n\n    Returns:\n        The newly created [`Version`][versions.version.Version].\n    \"\"\"\n    release = Release(parts)\n\n    return cls.create(epoch, release, pre, post, dev, local)\n</code></pre>"},{"location":"reference/version/#versions.version.Version.matches","title":"<code>matches(specification: Specification) -&gt; bool</code>","text":"<p>Checks if a version matches the <code>specification</code>.</p> <p>Parameters:</p> Name Type Description Default <code>specification</code> <code>Specification</code> <p>The specification to check the version against.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the version matches the specification.</p> Source code in <code>versions/version.py</code> <pre><code>def matches(self, specification: Specification) -&gt; bool:\n\"\"\"Checks if a version matches the `specification`.\n\n    Arguments:\n        specification: The specification to check the version against.\n\n    Returns:\n        Whether the version matches the specification.\n    \"\"\"\n    return specification.accepts(self)\n</code></pre>"},{"location":"reference/version_sets/","title":"Version Sets","text":""},{"location":"reference/version_sets/#versions.version_sets.VersionSet","title":"<code>VersionSet = Union[VersionEmpty, VersionPoint, VersionRange, VersionUnion]</code>  <code>module-attribute</code>","text":"<p>The union of the following types:</p> <ul> <li><code>VersionEmpty</code></li> <li><code>VersionPoint</code></li> <li><code>VersionRange</code></li> <li><code>VersionUnion</code></li> </ul>"},{"location":"reference/version_sets/#versions.version_sets.VersionItem","title":"<code>VersionItem = Union[VersionPoint, VersionRange]</code>  <code>module-attribute</code>","text":"<p>The union of <code>VersionPoint</code> and <code>VersionRange</code>.</p>"},{"location":"reference/version_sets/#versions.version_sets.VersionSetProtocol","title":"<code>VersionSetProtocol</code>","text":"<p>         Bases: <code>Specification</code>, <code>Protocol</code></p> Source code in <code>versions/version_sets.py</code> <pre><code>@runtime_checkable\nclass VersionSetProtocol(Specification, Protocol):\n    @required\n    def is_empty(self) -&gt; bool:\n\"\"\"Checks if the set is *empty*.\n\n        Returns:\n            Whether the set is *empty*.\n        \"\"\"\n        raise NotImplementedError\n\n    @required\n    def is_universal(self) -&gt; bool:\n\"\"\"Checks if the set is the *universal*.\n\n        Returns:\n            Whether the set is *universal*.\n        \"\"\"\n        raise NotImplementedError\n\n    @required\n    def includes(self, version_set: VersionSet) -&gt; bool:\n\"\"\"Checks if the set includes `version_set`.\n\n        Returns:\n            Whether the set includes `version_set`.\n        \"\"\"\n        raise NotImplementedError\n\n    @required\n    def intersects(self, version_set: VersionSet) -&gt; bool:\n\"\"\"Checks if the set intersects `version_set`.\n\n        Returns:\n            Whether the set intersects `version_set`.\n        \"\"\"\n        raise NotImplementedError\n\n    @required\n    def contains(self, version: Version) -&gt; bool:\n\"\"\"Checks if the set contains some `version`.\n\n        Returns:\n            Whether the `version` is contained within the set.\n        \"\"\"\n        raise NotImplementedError\n\n    def accepts(self, version: Version) -&gt; bool:\n\"\"\"Checks if the set contains some `version`.\n\n        This is an implementation of the [`accepts`][versions.specification.Specification.accepts]\n        method of [`Specification`][versions.specification.Specification] protocol, equivalent to\n        [`self.contains(version)`][versions.version_sets.VersionSetProtocol.contains].\n\n        Returns:\n            Whether the `version` is accepted by the set.\n        \"\"\"\n        return self.contains(version)\n\n    @required\n    def intersection(self, version_set: VersionSet) -&gt; VersionSet:\n\"\"\"Computes the *intersection* of `self` and `version_set`.\n\n        Returns:\n            The set representing the *intersection* of `self` and `version_set`.\n        \"\"\"\n        raise NotImplementedError\n\n    @required\n    def union(self, version_set: VersionSet) -&gt; VersionSet:\n\"\"\"Computes the *union* of `self` and `version_set`.\n\n        Returns:\n            The set representing the *union* of `self` and `version_set`.\n        \"\"\"\n        raise NotImplementedError\n\n    @required\n    def difference(self, version_set: VersionSet) -&gt; VersionSet:\n\"\"\"Computes the *difference* of `self` and `version_set`.\n\n        Returns:\n            The set representing the *difference* of `self` and `version_set`.\n        \"\"\"\n        raise NotImplementedError\n\n    @required\n    def complement(self) -&gt; VersionSet:\n\"\"\"Computes the *complement* of `self`.\n\n        Returns:\n            The set representing the *complement* of `self`.\n        \"\"\"\n        raise NotImplementedError\n\n    def symmetric_difference(self, version_set: VersionSet) -&gt; VersionSet:\n\"\"\"Computes the *symmetric difference* of `self` and `version_set`.\n\n        Equivalent to [`self.union(version_set).difference(self.intersection(version_set))`]\n        [versions.version_sets.VersionSetProtocol.difference].\n\n        Returns:\n            The set representing the *symmetric difference* of `self` and `version_set`.\n        \"\"\"\n        return self.union(version_set).difference(self.intersection(version_set))\n\n    def __contains__(self, version: Version) -&gt; bool:\n\"\"\"Checks if the set contains some `version` via the *contains* (`in`) operation.\n\n        Returns:\n            Whether the `version` is contained within the set.\n        \"\"\"\n        return self.contains(version)\n\n    def __and__(self, version_set: VersionSet) -&gt; VersionSet:\n\"\"\"Computes the *intersection* of `self` and `version_set` via the *and* (`&amp;`) operation.\n\n        This is equivalent to [`self.intersection(version_set)`]\n        [versions.version_sets.VersionSetProtocol.intersection].\n\n        Returns:\n            The set representing the *intersection* of `self` and `version_set`.\n        \"\"\"\n        return self.intersection(version_set)\n\n    def __iand__(self, version_set: VersionSet) -&gt; VersionSet:\n\"\"\"Computes the *intersection* of `self` and `version_set` via the *and-assign*\n        (`&amp;=`) operation.\n\n        This is equivalent to [`self.intersection(version_set)`]\n        [versions.version_sets.VersionSetProtocol.intersection].\n\n        Returns:\n            The set representing the *intersection* of `self` and `version_set`.\n        \"\"\"\n        return self.intersection(version_set)\n\n    def __or__(self, version_set: VersionSet) -&gt; VersionSet:\n\"\"\"Computes the *union* of `self` and `version_set` via the *or* (`|`) operation.\n\n        This is equivalent to [`self.union(version_set)`]\n        [versions.version_sets.VersionSetProtocol.union].\n\n        Returns:\n            The set representing the *union* of `self` and `version_set`.\n        \"\"\"\n        return self.union(version_set)\n\n    def __ior__(self, version_set: VersionSet) -&gt; VersionSet:\n\"\"\"Computes the *union* of `self` and `version_set` via the *or-assign* (`|=`) operation.\n\n        This is equivalent to [`self.union(version_set)`]\n        [versions.version_sets.VersionSetProtocol.union].\n\n        Returns:\n            The set representing the *union* of `self` and `version_set`.\n        \"\"\"\n        return self.union(version_set)\n\n    def __sub__(self, version_set: VersionSet) -&gt; VersionSet:\n\"\"\"Computes the *difference* of `self` and `version_set` via the *sub* (`-`) operation.\n\n        This is equivalent to [`self.difference(version_set)`]\n        [versions.version_sets.VersionSetProtocol.difference].\n\n        Returns:\n            The set representing the *difference* of `self` and `version_set`.\n        \"\"\"\n        return self.difference(version_set)\n\n    def __isub__(self, version_set: VersionSet) -&gt; VersionSet:\n\"\"\"Computes the *difference* of `self` and `version_set` via the *sub-assign*\n        (`-=`) operation.\n\n        This is equivalent to [`self.difference(version_set)`]\n        [versions.version_sets.VersionSetProtocol.difference].\n\n        Returns:\n            The set representing the *difference* of `self` and `version_set`.\n        \"\"\"\n        return self.difference(version_set)\n\n    def __xor__(self, version_set: VersionSet) -&gt; VersionSet:\n\"\"\"Computes the *symmetric difference* of `self` and `version_set` via the *xor*\n        (`^`) operation.\n\n        This is equivalent to [`self.symmetric_difference(version_set)`]\n        [versions.version_sets.VersionSetProtocol.symmetric_difference].\n\n        Returns:\n            The set representing the *symmetric difference* of `self` and `version_set`.\n        \"\"\"\n        return self.symmetric_difference(version_set)\n\n    def __ixor__(self, version_set: VersionSet) -&gt; VersionSet:\n\"\"\"Computes the *symmetric difference* of `self` and `version_set` via the *xor-assign*\n        (`^=`) operation.\n\n        This is equivalent to [`self.symmetric_difference(version_set)`]\n        [versions.version_sets.VersionSetProtocol.symmetric_difference].\n\n        Returns:\n            The set representing the *symmetric difference* of `self` and `version_set`.\n        \"\"\"\n        return self.symmetric_difference(version_set)\n\n    def __negate__(self) -&gt; VersionSet:\n\"\"\"Computes the *complement* of `self` via the *negate* (`~`) operation.\n\n        This is equivalent to [`self.complement()`]\n        [versions.version_sets.VersionSetProtocol.complement].\n\n        Returns:\n            The set representing the *complement* of `self`.\n        \"\"\"\n        return self.complement()\n</code></pre>"},{"location":"reference/version_sets/#versions.version_sets.VersionSetProtocol.is_empty","title":"<code>is_empty() -&gt; bool</code>  <code>abstractmethod</code>","text":"<p>Checks if the set is empty.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the set is empty.</p> Source code in <code>versions/version_sets.py</code> <pre><code>@required\ndef is_empty(self) -&gt; bool:\n\"\"\"Checks if the set is *empty*.\n\n    Returns:\n        Whether the set is *empty*.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/version_sets/#versions.version_sets.VersionSetProtocol.is_universal","title":"<code>is_universal() -&gt; bool</code>  <code>abstractmethod</code>","text":"<p>Checks if the set is the universal.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the set is universal.</p> Source code in <code>versions/version_sets.py</code> <pre><code>@required\ndef is_universal(self) -&gt; bool:\n\"\"\"Checks if the set is the *universal*.\n\n    Returns:\n        Whether the set is *universal*.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/version_sets/#versions.version_sets.VersionSetProtocol.includes","title":"<code>includes(version_set: VersionSet) -&gt; bool</code>  <code>abstractmethod</code>","text":"<p>Checks if the set includes <code>version_set</code>.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the set includes <code>version_set</code>.</p> Source code in <code>versions/version_sets.py</code> <pre><code>@required\ndef includes(self, version_set: VersionSet) -&gt; bool:\n\"\"\"Checks if the set includes `version_set`.\n\n    Returns:\n        Whether the set includes `version_set`.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/version_sets/#versions.version_sets.VersionSetProtocol.intersects","title":"<code>intersects(version_set: VersionSet) -&gt; bool</code>  <code>abstractmethod</code>","text":"<p>Checks if the set intersects <code>version_set</code>.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the set intersects <code>version_set</code>.</p> Source code in <code>versions/version_sets.py</code> <pre><code>@required\ndef intersects(self, version_set: VersionSet) -&gt; bool:\n\"\"\"Checks if the set intersects `version_set`.\n\n    Returns:\n        Whether the set intersects `version_set`.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/version_sets/#versions.version_sets.VersionSetProtocol.contains","title":"<code>contains(version: Version) -&gt; bool</code>  <code>abstractmethod</code>","text":"<p>Checks if the set contains some <code>version</code>.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the <code>version</code> is contained within the set.</p> Source code in <code>versions/version_sets.py</code> <pre><code>@required\ndef contains(self, version: Version) -&gt; bool:\n\"\"\"Checks if the set contains some `version`.\n\n    Returns:\n        Whether the `version` is contained within the set.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/version_sets/#versions.version_sets.VersionSetProtocol.accepts","title":"<code>accepts(version: Version) -&gt; bool</code>","text":"<p>Checks if the set contains some <code>version</code>.</p> <p>This is an implementation of the <code>accepts</code> method of <code>Specification</code> protocol, equivalent to <code>self.contains(version)</code>.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the <code>version</code> is accepted by the set.</p> Source code in <code>versions/version_sets.py</code> <pre><code>def accepts(self, version: Version) -&gt; bool:\n\"\"\"Checks if the set contains some `version`.\n\n    This is an implementation of the [`accepts`][versions.specification.Specification.accepts]\n    method of [`Specification`][versions.specification.Specification] protocol, equivalent to\n    [`self.contains(version)`][versions.version_sets.VersionSetProtocol.contains].\n\n    Returns:\n        Whether the `version` is accepted by the set.\n    \"\"\"\n    return self.contains(version)\n</code></pre>"},{"location":"reference/version_sets/#versions.version_sets.VersionSetProtocol.intersection","title":"<code>intersection(version_set: VersionSet) -&gt; VersionSet</code>  <code>abstractmethod</code>","text":"<p>Computes the intersection of <code>self</code> and <code>version_set</code>.</p> <p>Returns:</p> Type Description <code>VersionSet</code> <p>The set representing the intersection of <code>self</code> and <code>version_set</code>.</p> Source code in <code>versions/version_sets.py</code> <pre><code>@required\ndef intersection(self, version_set: VersionSet) -&gt; VersionSet:\n\"\"\"Computes the *intersection* of `self` and `version_set`.\n\n    Returns:\n        The set representing the *intersection* of `self` and `version_set`.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/version_sets/#versions.version_sets.VersionSetProtocol.union","title":"<code>union(version_set: VersionSet) -&gt; VersionSet</code>  <code>abstractmethod</code>","text":"<p>Computes the union of <code>self</code> and <code>version_set</code>.</p> <p>Returns:</p> Type Description <code>VersionSet</code> <p>The set representing the union of <code>self</code> and <code>version_set</code>.</p> Source code in <code>versions/version_sets.py</code> <pre><code>@required\ndef union(self, version_set: VersionSet) -&gt; VersionSet:\n\"\"\"Computes the *union* of `self` and `version_set`.\n\n    Returns:\n        The set representing the *union* of `self` and `version_set`.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/version_sets/#versions.version_sets.VersionSetProtocol.difference","title":"<code>difference(version_set: VersionSet) -&gt; VersionSet</code>  <code>abstractmethod</code>","text":"<p>Computes the difference of <code>self</code> and <code>version_set</code>.</p> <p>Returns:</p> Type Description <code>VersionSet</code> <p>The set representing the difference of <code>self</code> and <code>version_set</code>.</p> Source code in <code>versions/version_sets.py</code> <pre><code>@required\ndef difference(self, version_set: VersionSet) -&gt; VersionSet:\n\"\"\"Computes the *difference* of `self` and `version_set`.\n\n    Returns:\n        The set representing the *difference* of `self` and `version_set`.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/version_sets/#versions.version_sets.VersionSetProtocol.complement","title":"<code>complement() -&gt; VersionSet</code>  <code>abstractmethod</code>","text":"<p>Computes the complement of <code>self</code>.</p> <p>Returns:</p> Type Description <code>VersionSet</code> <p>The set representing the complement of <code>self</code>.</p> Source code in <code>versions/version_sets.py</code> <pre><code>@required\ndef complement(self) -&gt; VersionSet:\n\"\"\"Computes the *complement* of `self`.\n\n    Returns:\n        The set representing the *complement* of `self`.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/version_sets/#versions.version_sets.VersionSetProtocol.symmetric_difference","title":"<code>symmetric_difference(version_set: VersionSet) -&gt; VersionSet</code>","text":"<p>Computes the symmetric difference of <code>self</code> and <code>version_set</code>.</p> <p>Equivalent to <code>self.union(version_set).difference(self.intersection(version_set))</code>.</p> <p>Returns:</p> Type Description <code>VersionSet</code> <p>The set representing the symmetric difference of <code>self</code> and <code>version_set</code>.</p> Source code in <code>versions/version_sets.py</code> <pre><code>def symmetric_difference(self, version_set: VersionSet) -&gt; VersionSet:\n\"\"\"Computes the *symmetric difference* of `self` and `version_set`.\n\n    Equivalent to [`self.union(version_set).difference(self.intersection(version_set))`]\n    [versions.version_sets.VersionSetProtocol.difference].\n\n    Returns:\n        The set representing the *symmetric difference* of `self` and `version_set`.\n    \"\"\"\n    return self.union(version_set).difference(self.intersection(version_set))\n</code></pre>"},{"location":"reference/version_sets/#versions.version_sets.VersionSetProtocol.__contains__","title":"<code>__contains__(version: Version) -&gt; bool</code>","text":"<p>Checks if the set contains some <code>version</code> via the contains (<code>in</code>) operation.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the <code>version</code> is contained within the set.</p> Source code in <code>versions/version_sets.py</code> <pre><code>def __contains__(self, version: Version) -&gt; bool:\n\"\"\"Checks if the set contains some `version` via the *contains* (`in`) operation.\n\n    Returns:\n        Whether the `version` is contained within the set.\n    \"\"\"\n    return self.contains(version)\n</code></pre>"},{"location":"reference/version_sets/#versions.version_sets.VersionSetProtocol.__and__","title":"<code>__and__(version_set: VersionSet) -&gt; VersionSet</code>","text":"<p>Computes the intersection of <code>self</code> and <code>version_set</code> via the and (<code>&amp;</code>) operation.</p> <p>This is equivalent to <code>self.intersection(version_set)</code>.</p> <p>Returns:</p> Type Description <code>VersionSet</code> <p>The set representing the intersection of <code>self</code> and <code>version_set</code>.</p> Source code in <code>versions/version_sets.py</code> <pre><code>def __and__(self, version_set: VersionSet) -&gt; VersionSet:\n\"\"\"Computes the *intersection* of `self` and `version_set` via the *and* (`&amp;`) operation.\n\n    This is equivalent to [`self.intersection(version_set)`]\n    [versions.version_sets.VersionSetProtocol.intersection].\n\n    Returns:\n        The set representing the *intersection* of `self` and `version_set`.\n    \"\"\"\n    return self.intersection(version_set)\n</code></pre>"},{"location":"reference/version_sets/#versions.version_sets.VersionSetProtocol.__iand__","title":"<code>__iand__(version_set: VersionSet) -&gt; VersionSet</code>","text":"<p>Computes the intersection of <code>self</code> and <code>version_set</code> via the and-assign (<code>&amp;=</code>) operation.</p> <p>This is equivalent to <code>self.intersection(version_set)</code>.</p> <p>Returns:</p> Type Description <code>VersionSet</code> <p>The set representing the intersection of <code>self</code> and <code>version_set</code>.</p> Source code in <code>versions/version_sets.py</code> <pre><code>def __iand__(self, version_set: VersionSet) -&gt; VersionSet:\n\"\"\"Computes the *intersection* of `self` and `version_set` via the *and-assign*\n    (`&amp;=`) operation.\n\n    This is equivalent to [`self.intersection(version_set)`]\n    [versions.version_sets.VersionSetProtocol.intersection].\n\n    Returns:\n        The set representing the *intersection* of `self` and `version_set`.\n    \"\"\"\n    return self.intersection(version_set)\n</code></pre>"},{"location":"reference/version_sets/#versions.version_sets.VersionSetProtocol.__or__","title":"<code>__or__(version_set: VersionSet) -&gt; VersionSet</code>","text":"<p>Computes the union of <code>self</code> and <code>version_set</code> via the or (<code>|</code>) operation.</p> <p>This is equivalent to <code>self.union(version_set)</code>.</p> <p>Returns:</p> Type Description <code>VersionSet</code> <p>The set representing the union of <code>self</code> and <code>version_set</code>.</p> Source code in <code>versions/version_sets.py</code> <pre><code>def __or__(self, version_set: VersionSet) -&gt; VersionSet:\n\"\"\"Computes the *union* of `self` and `version_set` via the *or* (`|`) operation.\n\n    This is equivalent to [`self.union(version_set)`]\n    [versions.version_sets.VersionSetProtocol.union].\n\n    Returns:\n        The set representing the *union* of `self` and `version_set`.\n    \"\"\"\n    return self.union(version_set)\n</code></pre>"},{"location":"reference/version_sets/#versions.version_sets.VersionSetProtocol.__ior__","title":"<code>__ior__(version_set: VersionSet) -&gt; VersionSet</code>","text":"<p>Computes the union of <code>self</code> and <code>version_set</code> via the or-assign (<code>|=</code>) operation.</p> <p>This is equivalent to <code>self.union(version_set)</code>.</p> <p>Returns:</p> Type Description <code>VersionSet</code> <p>The set representing the union of <code>self</code> and <code>version_set</code>.</p> Source code in <code>versions/version_sets.py</code> <pre><code>def __ior__(self, version_set: VersionSet) -&gt; VersionSet:\n\"\"\"Computes the *union* of `self` and `version_set` via the *or-assign* (`|=`) operation.\n\n    This is equivalent to [`self.union(version_set)`]\n    [versions.version_sets.VersionSetProtocol.union].\n\n    Returns:\n        The set representing the *union* of `self` and `version_set`.\n    \"\"\"\n    return self.union(version_set)\n</code></pre>"},{"location":"reference/version_sets/#versions.version_sets.VersionSetProtocol.__sub__","title":"<code>__sub__(version_set: VersionSet) -&gt; VersionSet</code>","text":"<p>Computes the difference of <code>self</code> and <code>version_set</code> via the sub (<code>-</code>) operation.</p> <p>This is equivalent to <code>self.difference(version_set)</code>.</p> <p>Returns:</p> Type Description <code>VersionSet</code> <p>The set representing the difference of <code>self</code> and <code>version_set</code>.</p> Source code in <code>versions/version_sets.py</code> <pre><code>def __sub__(self, version_set: VersionSet) -&gt; VersionSet:\n\"\"\"Computes the *difference* of `self` and `version_set` via the *sub* (`-`) operation.\n\n    This is equivalent to [`self.difference(version_set)`]\n    [versions.version_sets.VersionSetProtocol.difference].\n\n    Returns:\n        The set representing the *difference* of `self` and `version_set`.\n    \"\"\"\n    return self.difference(version_set)\n</code></pre>"},{"location":"reference/version_sets/#versions.version_sets.VersionSetProtocol.__isub__","title":"<code>__isub__(version_set: VersionSet) -&gt; VersionSet</code>","text":"<p>Computes the difference of <code>self</code> and <code>version_set</code> via the sub-assign (<code>-=</code>) operation.</p> <p>This is equivalent to <code>self.difference(version_set)</code>.</p> <p>Returns:</p> Type Description <code>VersionSet</code> <p>The set representing the difference of <code>self</code> and <code>version_set</code>.</p> Source code in <code>versions/version_sets.py</code> <pre><code>def __isub__(self, version_set: VersionSet) -&gt; VersionSet:\n\"\"\"Computes the *difference* of `self` and `version_set` via the *sub-assign*\n    (`-=`) operation.\n\n    This is equivalent to [`self.difference(version_set)`]\n    [versions.version_sets.VersionSetProtocol.difference].\n\n    Returns:\n        The set representing the *difference* of `self` and `version_set`.\n    \"\"\"\n    return self.difference(version_set)\n</code></pre>"},{"location":"reference/version_sets/#versions.version_sets.VersionSetProtocol.__xor__","title":"<code>__xor__(version_set: VersionSet) -&gt; VersionSet</code>","text":"<p>Computes the symmetric difference of <code>self</code> and <code>version_set</code> via the xor (<code>^</code>) operation.</p> <p>This is equivalent to <code>self.symmetric_difference(version_set)</code>.</p> <p>Returns:</p> Type Description <code>VersionSet</code> <p>The set representing the symmetric difference of <code>self</code> and <code>version_set</code>.</p> Source code in <code>versions/version_sets.py</code> <pre><code>def __xor__(self, version_set: VersionSet) -&gt; VersionSet:\n\"\"\"Computes the *symmetric difference* of `self` and `version_set` via the *xor*\n    (`^`) operation.\n\n    This is equivalent to [`self.symmetric_difference(version_set)`]\n    [versions.version_sets.VersionSetProtocol.symmetric_difference].\n\n    Returns:\n        The set representing the *symmetric difference* of `self` and `version_set`.\n    \"\"\"\n    return self.symmetric_difference(version_set)\n</code></pre>"},{"location":"reference/version_sets/#versions.version_sets.VersionSetProtocol.__ixor__","title":"<code>__ixor__(version_set: VersionSet) -&gt; VersionSet</code>","text":"<p>Computes the symmetric difference of <code>self</code> and <code>version_set</code> via the xor-assign (<code>^=</code>) operation.</p> <p>This is equivalent to <code>self.symmetric_difference(version_set)</code>.</p> <p>Returns:</p> Type Description <code>VersionSet</code> <p>The set representing the symmetric difference of <code>self</code> and <code>version_set</code>.</p> Source code in <code>versions/version_sets.py</code> <pre><code>def __ixor__(self, version_set: VersionSet) -&gt; VersionSet:\n\"\"\"Computes the *symmetric difference* of `self` and `version_set` via the *xor-assign*\n    (`^=`) operation.\n\n    This is equivalent to [`self.symmetric_difference(version_set)`]\n    [versions.version_sets.VersionSetProtocol.symmetric_difference].\n\n    Returns:\n        The set representing the *symmetric difference* of `self` and `version_set`.\n    \"\"\"\n    return self.symmetric_difference(version_set)\n</code></pre>"},{"location":"reference/version_sets/#versions.version_sets.VersionSetProtocol.__negate__","title":"<code>__negate__() -&gt; VersionSet</code>","text":"<p>Computes the complement of <code>self</code> via the negate (<code>~</code>) operation.</p> <p>This is equivalent to <code>self.complement()</code>.</p> <p>Returns:</p> Type Description <code>VersionSet</code> <p>The set representing the complement of <code>self</code>.</p> Source code in <code>versions/version_sets.py</code> <pre><code>def __negate__(self) -&gt; VersionSet:\n\"\"\"Computes the *complement* of `self` via the *negate* (`~`) operation.\n\n    This is equivalent to [`self.complement()`]\n    [versions.version_sets.VersionSetProtocol.complement].\n\n    Returns:\n        The set representing the *complement* of `self`.\n    \"\"\"\n    return self.complement()\n</code></pre>"},{"location":"reference/version_sets/#versions.version_sets.VersionEmpty","title":"<code>VersionEmpty</code>","text":"<p>         Bases: <code>Representation</code>, <code>ToString</code>, <code>VersionSetProtocol</code></p> <p>Represents empty version sets (<code>0</code>).</p> Source code in <code>versions/version_sets.py</code> <pre><code>@frozen(repr=False, order=False)\nclass VersionEmpty(Representation, ToString, VersionSetProtocol):\n\"\"\"Represents empty version sets (`0`).\"\"\"\n\n    def is_empty(self) -&gt; Literal[True]:\n        return True\n\n    def is_universal(self) -&gt; Literal[False]:\n        return False\n\n    def includes(self, version_set: VersionSet) -&gt; bool:\n        return version_set.is_empty()\n\n    def intersects(self, version_set: VersionSet) -&gt; Literal[False]:\n        return False\n\n    def contains(self, version: Version) -&gt; Literal[False]:\n        return False\n\n    def intersection(self: E, version_set: VersionSet) -&gt; E:\n        return self\n\n    def union(self, version_set: S) -&gt; S:\n        return version_set\n\n    def difference(self: E, version_set: VersionSet) -&gt; E:\n        return self\n\n    def symmetric_difference(self, version_set: S) -&gt; S:\n        return version_set\n\n    def complement(self) -&gt; VersionRange:\n        return UNIVERSAL_SET\n\n    def to_string(self) -&gt; str:\n        return EMPTY_VERSION\n</code></pre>"},{"location":"reference/version_sets/#versions.version_sets.VersionRange","title":"<code>VersionRange</code>","text":"<p>         Bases: <code>Representation</code>, <code>ToString</code>, <code>VersionSetProtocol</code></p> <p>Represents version ranges (<code>(v, w)</code>, <code>(v, w]</code>, <code>[v, w)</code> and <code>[v, w]</code>).</p> Source code in <code>versions/version_sets.py</code> <pre><code>@frozen(repr=False, eq=False, order=False)\nclass VersionRange(Representation, ToString, VersionSetProtocol):\n\"\"\"Represents version ranges (`(v, w)`, `(v, w]`, `[v, w)` and `[v, w]`).\"\"\"\n\n    min: Optional[Version] = None\n    max: Optional[Version] = None\n    include_min: bool = False\n    include_max: bool = False\n\n    def __attrs_post_init__(self) -&gt; None:\n        if self.min is None and self.include_min:\n            raise ValueError(CAN_NOT_INCLUDE_INFINITY)\n\n        if self.max is None and self.include_max:\n            raise ValueError(CAN_NOT_INCLUDE_INFINITY)\n\n        if self.comparable_min &gt; self.comparable_max:\n            raise ValueError(MIN_MAX_CONSTRAINT)\n\n    # range stuff\n\n    @property\n    def parameters(self) -&gt; Tuple[Optional[Version], Optional[Version], bool, bool]:\n        return (self.min, self.max, self.include_min, self.include_max)\n\n    @property\n    def exclude_min(self) -&gt; bool:\n        return not self.include_min\n\n    @property\n    def exclude_max(self) -&gt; bool:\n        return not self.include_max\n\n    @property\n    def comparable_min(self) -&gt; Union[Version, NegativeInfinity]:\n        min = self.min\n\n        return negative_infinity if min is None else min\n\n    @property\n    def comparable_max(self) -&gt; Union[Version, Infinity]:\n        max = self.max\n\n        return infinity if max is None else max\n\n    def is_closed(self) -&gt; bool:\n        return self.is_left_closed() and self.is_right_closed()\n\n    def is_left_closed(self) -&gt; bool:\n        return self.include_min\n\n    def is_right_closed(self) -&gt; bool:\n        return self.include_max\n\n    def is_open(self) -&gt; bool:\n        return self.is_left_open() and self.is_right_open()\n\n    def is_left_open(self) -&gt; bool:\n        return self.exclude_min\n\n    def is_right_open(self) -&gt; bool:\n        return self.exclude_max\n\n    def is_unbounded(self) -&gt; bool:\n        return self.is_left_unbounded() and self.is_right_unbounded()\n\n    def is_left_unbounded(self) -&gt; bool:\n        return self.min is None\n\n    def is_right_unbounded(self) -&gt; bool:\n        return self.max is None\n\n    def is_bounded(self) -&gt; bool:\n        return self.is_left_bounded() and self.is_right_bounded()\n\n    def is_left_bounded(self) -&gt; bool:\n        return self.min is not None\n\n    def is_right_bounded(self) -&gt; bool:\n        return self.max is not None\n\n    def is_empty_or_point(self) -&gt; bool:\n        return self.comparable_min == self.comparable_max\n\n    def is_lower(self, other: VersionRange) -&gt; bool:\n        self_comparable_min = self.comparable_min\n        other_comparable_min = other.comparable_min\n\n        if self_comparable_min &lt; other_comparable_min:\n            return True\n\n        if self_comparable_min &gt; other_comparable_min:\n            return False\n\n        return self.include_min and other.exclude_min\n\n    def is_higher(self, other: VersionRange) -&gt; bool:\n        self_comparable_max = self.comparable_max\n        other_comparable_max = other.comparable_max\n\n        if self_comparable_max &lt; other_comparable_max:\n            return False\n\n        if self_comparable_max &gt; other_comparable_max:\n            return True\n\n        return self.include_max and other.exclude_max\n\n    def is_strictly_lower(self, other: VersionRange) -&gt; bool:\n        self_comparable_max = self.comparable_max\n        other_comparable_min = other.comparable_min\n\n        if self_comparable_max &lt; other_comparable_min:\n            return True\n\n        if self_comparable_max &gt; other_comparable_min:\n            return False\n\n        return self.exclude_max or other.exclude_min\n\n    def is_strictly_higher(self, other: VersionRange) -&gt; bool:\n        self_comparable_min = self.comparable_min\n        other_comparable_max = other.comparable_max\n\n        if self_comparable_min &gt; other_comparable_max:\n            return True\n\n        if self_comparable_min &lt; other_comparable_max:\n            return False\n\n        return self.exclude_min or other.exclude_max\n\n    def is_left_adjacent(self, other: VersionRange) -&gt; bool:\n        return (self.max == other.min) and (self.include_max is other.exclude_min)\n\n    def is_right_adjacent(self, other: VersionRange) -&gt; bool:\n        return (self.min == other.max) and (self.include_min is other.exclude_max)\n\n    def is_adjacent(self, other: VersionRange) -&gt; bool:\n        return self.is_left_adjacent(other) or self.is_right_adjacent(other)\n\n    def __hash__(self) -&gt; int:\n        return hash(self.parameters)\n\n    def __eq__(self, other: Any) -&gt; bool:\n        return is_version_range(other) and self.parameters == other.parameters\n\n    def __ne__(self, other: Any) -&gt; bool:\n        return not self.__eq__(other)\n\n    def __lt__(self, other: VersionRange) -&gt; bool:\n        return self.compare(other).is_less()\n\n    def __le__(self, other: VersionRange) -&gt; bool:\n        return self.compare(other).is_less_or_equal()\n\n    def __gt__(self, other: VersionRange) -&gt; bool:\n        return self.compare(other).is_greater()\n\n    def __ge__(self, other: VersionRange) -&gt; bool:\n        return self.compare(other).is_greater_or_equal()\n\n    def compare(self, other: VersionRange) -&gt; Ordering:\n        self_comparable_min = self.comparable_min\n        other_comparable_min = other.comparable_min\n\n        if self_comparable_min &gt; other_comparable_min:\n            return Ordering.GREATER\n\n        if self_comparable_min &lt; other_comparable_min:\n            return Ordering.LESS\n\n        include_min = self.include_min\n\n        if include_min == other.exclude_min:\n            return Ordering.LESS if include_min else Ordering.GREATER\n\n        self_comparable_max = self.comparable_max\n        other_comparable_max = other.comparable_max\n\n        if self_comparable_max &gt; other_comparable_max:\n            return Ordering.GREATER\n\n        if self_comparable_max &lt; other_comparable_max:\n            return Ordering.LESS\n\n        include_max = self.include_max\n\n        if include_max == other.exclude_max:\n            return Ordering.GREATER if include_max else Ordering.LESS\n\n        return Ordering.EQUAL\n\n    # protocol implementation\n\n    def is_empty(self) -&gt; bool:\n        return self.is_empty_or_point() and not self.is_closed()\n\n    def is_point(self) -&gt; bool:\n        return self.is_empty_or_point() and self.is_closed()\n\n    def is_universal(self) -&gt; bool:\n        return self.is_unbounded()\n\n    @property\n    def version(self) -&gt; Version:\n        if self.is_point():\n            return self.version_unchecked\n\n        raise ValueError(RANGE_NOT_POINT)\n\n    @property\n    def version_unchecked(self) -&gt; Version:\n        version = self.min or self.max\n\n        if version is None:  # we can not violate the type system\n            raise ValueError(RANGE_NOT_POINT)\n\n        return version\n\n    def contains(self, version: Version) -&gt; bool:\n        comparable_min = self.comparable_min\n        comparable_max = self.comparable_max\n\n        if version &lt; comparable_min:\n            return False\n\n        if self.exclude_min and version == comparable_min:\n            return False\n\n        if version &gt; comparable_max:\n            return False\n\n        if self.exclude_max and version == comparable_max:\n            return False\n\n        return True\n\n    accepts = contains\n\n    def includes(self, version_set: VersionSet) -&gt; bool:\n        if is_version_empty(version_set):\n            return True\n\n        if is_version_point(version_set):\n            return self.contains(version_set.version)\n\n        if is_version_range(version_set):\n            return not version_set.is_lower(self) and not version_set.is_higher(self)\n\n        if is_version_union(version_set):\n            return all(self.includes(item) for item in version_set.items)\n\n        raise unexpected_version_set(version_set)\n\n    def intersects(self, version_set: VersionSet) -&gt; bool:\n        if is_version_empty(version_set):\n            return False\n\n        if is_version_point(version_set):\n            return self.contains(version_set.version)\n\n        if is_version_range(version_set):\n            return self.intersects_range(version_set)\n\n        if is_version_union(version_set):\n            return any(self.intersects(item) for item in version_set.items)\n\n        raise unexpected_version_set(version_set)\n\n    def intersects_range(self, range: VersionRange) -&gt; bool:\n        return not range.is_strictly_lower(self) and not range.is_strictly_higher(self)\n\n    def intersection(self, version_set: VersionSet) -&gt; VersionSet:\n        if is_version_empty(version_set):\n            return EMPTY_SET\n\n        if is_version_point(version_set):\n            return version_set.intersection(self)\n\n        if is_version_range(version_set):\n            if self.is_lower(version_set):\n                if self.is_strictly_lower(version_set):\n                    return EMPTY_SET\n\n                intersection_min = version_set.min\n                intersection_include_min = version_set.include_min\n\n            else:\n                if self.is_strictly_higher(version_set):\n                    return EMPTY_SET\n\n                intersection_min = self.min\n                intersection_include_min = self.include_min\n\n            if self.is_higher(version_set):\n                intersection_max = version_set.max\n                intersection_include_max = version_set.include_max\n\n            else:\n                intersection_max = self.max\n                intersection_include_max = self.include_max\n\n            # if we reached here, there is an actual range\n            intersection = VersionRange(\n                intersection_min,\n                intersection_max,\n                intersection_include_min,\n                intersection_include_max,\n            )\n\n            if intersection.is_point():\n                return VersionPoint(intersection.version)\n\n            return intersection\n\n        if is_version_union(version_set):\n            return version_set.intersection(self)\n\n        raise unexpected_version_set(version_set)\n\n    def union(self, version_set: VersionSet) -&gt; VersionSet:\n        if is_version_empty(version_set):\n            return self\n\n        if is_version_point(version_set):\n            version = version_set.version\n\n            if self.contains(version):\n                return self\n\n            if version == self.min:\n                return evolve(self, include_min=True)\n\n            if version == self.max:\n                return evolve(self, include_max=True)\n\n            return VersionUnion.of(self, version_set)\n\n        if is_version_range(version_set):\n            if not self.is_adjacent(version_set) and not self.intersects(version_set):\n                return VersionUnion.of(self, version_set)\n\n            if self.is_lower(version_set):\n                union_min = self.min\n                union_include_min = self.include_min\n\n            else:\n                union_min = version_set.min\n                union_include_min = version_set.include_min\n\n            if self.is_higher(version_set):\n                union_max = self.max\n                union_include_max = self.include_max\n\n            else:\n                union_max = version_set.max\n                union_include_max = version_set.include_max\n\n            return VersionRange(\n                union_min,\n                union_max,\n                union_include_min,\n                union_include_max,\n            )\n\n        if is_version_union(version_set):\n            return version_set.union(self)\n\n        raise unexpected_version_set(version_set)\n\n    def difference(self, version_set: VersionSet) -&gt; VersionSet:\n        if is_version_empty(version_set):\n            return self\n\n        if is_version_point(version_set):\n            version = version_set.version\n\n            if not self.contains(version):\n                return self\n\n            if version == self.min:\n                if self.exclude_min:\n                    return self\n\n                return evolve(self, include_min=False)\n\n            if version == self.max:\n                if self.exclude_max:\n                    return self\n\n                return evolve(self, include_max=False)\n\n            return VersionUnion.of(\n                evolve(self, max=version, include_max=False),\n                evolve(self, min=version, include_min=False),\n            )\n\n        if is_version_range(version_set):\n            if not self.intersects(version_set):\n                return self\n\n            before: Optional[VersionItem]\n\n            if not self.is_lower(version_set):\n                before = None\n\n            elif self.min == version_set.min:\n                before = VersionPoint(self.min)  # type: ignore\n\n            else:\n                before = evolve(self, max=version_set.min, include_max=version_set.exclude_min)\n\n            after: Optional[VersionItem]\n\n            if not self.is_higher(version_set):\n                after = None\n\n            elif self.max == version_set.max:\n                after = VersionPoint(self.max)  # type: ignore\n\n            else:\n                after = evolve(self, min=version_set.max, include_min=version_set.exclude_max)\n\n            if before is None and after is None:\n                return EMPTY_SET\n\n            if before is None:\n                return after  # type: ignore\n\n            if after is None:\n                return before  # type: ignore\n\n            return VersionUnion.of(before, after)\n\n        if is_version_union(version_set):\n            return VersionUnion.of_iterable(self.difference_iterator(version_set))\n\n        raise unexpected_version_set(version_set)\n\n    def difference_iterator(self, version_union: VersionUnion) -&gt; Iterator[VersionItem]:\n        current: VersionItem = self\n\n        for item in version_union.items:\n            if item.is_strictly_lower(current):\n                continue\n\n            if item.is_strictly_higher(current):\n                break\n\n            difference = current.difference(item)\n\n            if is_version_union(difference):\n                item, current = difference.items\n\n                yield item\n\n            if is_version_item(difference):\n                current = difference\n\n        yield current\n\n    def complement(self) -&gt; VersionSet:\n        return UNIVERSAL_SET.difference(self)\n\n    def to_string_iterator(self) -&gt; Iterator[str]:\n        if self.is_empty():\n            yield EMPTY_VERSION\n            return\n\n        if self.is_point():\n            yield self.version.to_string()\n            return\n\n        if self.is_universal():\n            yield UNIVERSE_VERSION\n            return\n\n        min = self.min\n\n        if min is not None:\n            min_operator = (\n                Operator.greater_or_equal(min) if self.include_min else Operator.greater(min)\n            )\n\n            yield min_operator.to_string()\n\n        max = self.max\n\n        if max is not None:\n            max_operator = Operator.less_or_equal(max) if self.include_max else Operator.less(max)\n\n            yield max_operator.to_string()\n\n    def to_short_string_iterator(self) -&gt; Iterator[str]:\n        if self.is_empty():\n            yield EMPTY_VERSION\n            return\n\n        if self.is_point():\n            yield self.version.to_short_string()\n            return\n\n        if self.is_universal():\n            yield UNIVERSE_VERSION\n            return\n\n        min = self.min\n\n        if min is not None:\n            min_operator = (\n                Operator.greater_or_equal(min) if self.include_min else Operator.greater(min)\n            )\n\n            yield min_operator.to_short_string()\n\n        max = self.max\n\n        if max is not None:\n            max_operator = Operator.less_or_equal(max) if self.include_max else Operator.less(max)\n\n            yield max_operator.to_short_string()\n\n    def to_string(self) -&gt; str:\n        return concat_comma_space(self.to_string_iterator())\n\n    def to_short_string(self) -&gt; str:\n        return concat_comma(self.to_short_string_iterator())\n</code></pre>"},{"location":"reference/version_sets/#versions.version_sets.VersionPoint","title":"<code>VersionPoint</code>","text":"<p>         Bases: <code>VersionRange</code></p> <p>Represents version points (<code>[v, v]</code> ranges, also known as singleton sets <code>{v}</code>).</p> Source code in <code>versions/version_sets.py</code> <pre><code>@frozen(repr=False, eq=False, order=False)\nclass VersionPoint(VersionRange):\n\"\"\"Represents version points (`[v, v]` ranges, also known as singleton sets `{v}`).\"\"\"\n\n    version: Version = field()\n\n    # initialize range fields accordingly\n\n    min: Version = field(init=False)\n    max: Version = field(init=False)\n\n    include_min: Literal[True] = field(default=True, init=False)\n    include_max: Literal[True] = field(default=True, init=False)\n\n    @min.default\n    def default_min(self) -&gt; Version:\n        return self.version\n\n    @max.default\n    def default_max(self) -&gt; Version:\n        return self.version\n\n    def is_empty(self) -&gt; bool:\n        return False\n\n    def is_point(self) -&gt; bool:\n        return True\n\n    def is_universal(self) -&gt; bool:\n        return False\n\n    def contains(self, version: Version) -&gt; bool:\n        # version = self.version.weaken(version)\n        return self.version == version\n\n    accepts = contains\n\n    def includes(self, version_set: VersionSet) -&gt; bool:\n        return version_set.is_empty() or (\n            is_version_point(version_set) and self.contains(version_set.version)\n        )\n\n    def intersects(self, version_set: VersionSet) -&gt; bool:\n        return version_set.contains(self.version)\n\n    def intersection(self, version_set: VersionSet) -&gt; VersionSet:\n        return self if version_set.contains(self.version) else EMPTY_SET\n\n    def union(self, version_set: VersionSet) -&gt; VersionSet:\n        if is_version_empty(version_set):\n            return self\n\n        if is_version_point(version_set):\n            if self.contains(version_set.version):\n                return self\n\n            return VersionUnion.of(self, version_set)\n\n        if version_set.contains(self.version):\n            return version_set\n\n        if is_version_range(version_set) or is_version_union(version_set):\n            return VersionUnion.of(self, version_set)\n\n        raise unexpected_version_set(version_set)\n\n    def difference(self, version_set: VersionSet) -&gt; VersionSet:\n        return EMPTY_SET if version_set.contains(self.version) else self\n\n    def complement(self) -&gt; VersionSet:\n        return UNIVERSAL_SET.difference(self)\n\n    def to_string(self) -&gt; str:\n        return self.version.to_string()\n\n    def to_short_string(self) -&gt; str:\n        return self.version.to_short_string()\n</code></pre>"},{"location":"reference/version_sets/#versions.version_sets.VersionUnion","title":"<code>VersionUnion</code>","text":"<p>         Bases: <code>Representation</code>, <code>ToString</code>, <code>Specification</code></p> <p>Represents version unions.</p> Source code in <code>versions/version_sets.py</code> <pre><code>@frozen(repr=False, order=False)\nclass VersionUnion(Representation, ToString, Specification):\n\"\"\"Represents version unions.\"\"\"\n\n    items: VersionItems = field()\n\n    @items.validator\n    def check_items(self, attribute: Attribute[VersionItems], items: VersionItems) -&gt; None:\n        check_items(items)\n\n    @classmethod\n    def of_unchecked(cls: Type[U], *items: VersionItem) -&gt; U:\n        return cls(items)\n\n    @classmethod\n    def of_iterable_unchecked(cls: Type[U], items: Iterable[VersionItem]) -&gt; U:\n        return cls(tuple(items))\n\n    @staticmethod\n    def extract(version_set: VersionSet) -&gt; Iterator[VersionItem]:\n        if is_version_union(version_set):\n            yield from version_set.items\n\n        if is_version_item(version_set):\n            yield version_set\n\n    @classmethod\n    def merge(cls, iterable: Iterable[VersionSet]) -&gt; VersionSet:\n        extracted = list(flatten(map(cls.extract, iterable)))\n\n        if not extracted:\n            return EMPTY_SET\n\n        if any(item.is_universal() for item in extracted):\n            return UNIVERSAL_SET\n\n        extracted.sort()  # since ranges and points are ordered\n\n        merged: List[VersionItem] = []\n\n        for item in extracted:\n            if not merged:  # nothing to merge yet\n                merged.append(item)\n\n            else:\n                last_item = last(merged)\n\n                if last_item.intersects(item) or last_item.is_adjacent(item):\n                    result = last_item.union(item)\n\n                    if is_version_item(result):\n                        set_last(merged, result)\n\n                    else:\n                        raise InternalError(UNEXPECTED_UNION)\n\n                else:\n                    merged.append(item)\n\n        if contains_only_item(merged):\n            return first(merged)\n\n        return cls.of_iterable_unchecked(merged)\n\n    @classmethod\n    def of(cls, *version_sets: VersionSet) -&gt; VersionSet:\n        return cls.of_iterable(version_sets)\n\n    @classmethod\n    def of_iterable(cls, version_sets: Iterable[VersionSet]) -&gt; VersionSet:\n        return cls.merge(version_sets)\n\n    @property\n    def exclude_version(self) -&gt; Optional[Version]:\n        complement = self.complement()\n\n        return complement.version if is_version_point(complement) else None\n\n    def is_empty(self) -&gt; bool:\n        return False\n\n    def is_universal(self) -&gt; bool:\n        return False\n\n    def contains(self, version: Version) -&gt; bool:\n        return any(item.contains(version) for item in self.items)\n\n    accepts = contains\n\n    def includes(self, version_set: VersionSet) -&gt; bool:\n        self_items = iter(self.items)\n        items = self.extract(version_set)\n\n        self_item = next_or_none(self_items)\n        item = next_or_none(items)\n\n        while self_item and item:\n            if self_item.includes(item):\n                item = next_or_none(items)\n\n            else:\n                self_item = next_or_none(self_items)\n\n        return item is None  # all items are covered\n\n    def intersects(self, version_set: VersionSet) -&gt; bool:\n        self_items = iter(self.items)\n        items = self.extract(version_set)\n\n        self_item = next_or_none(self_items)\n        item = next_or_none(items)\n\n        while self_item and item:\n            if self_item.intersects(item):\n                return True\n\n            if item.is_higher(self_item):\n                self_item = next_or_none(self_items)\n\n            else:\n                item = next_or_none(items)\n\n        return False  # none of the items are allowed\n\n    def intersection_iterator(self, version_set: VersionSet) -&gt; Iterator[VersionItem]:\n        self_items = iter(self.items)\n        items = self.extract(version_set)\n\n        self_item = next_or_none(self_items)\n        item = next_or_none(items)\n\n        while self_item and item:\n            intersection = self_item.intersection(item)\n\n            if is_version_item(intersection):\n                yield intersection\n\n            if item.is_higher(self_item):\n                self_item = next_or_none(self_items)\n\n            else:\n                item = next_or_none(items)\n\n    def intersection(self, version_set: VersionSet) -&gt; VersionSet:\n        return self.of_iterable(self.intersection_iterator(version_set))\n\n    def union(self, version_set: VersionSet) -&gt; VersionSet:\n        return self.of(self, version_set)\n\n    def difference(self, version_set: VersionSet) -&gt; VersionSet:\n        items_difference = ItemsDifference(iter(self.items), self.extract(version_set))\n        return self.of_iterable(items_difference.compute())\n\n    def complement(self) -&gt; VersionSet:\n        return UNIVERSAL_SET.difference(self)\n\n    def to_string(self) -&gt; str:\n        exclude_version = self.exclude_version\n\n        if exclude_version:\n            operator = Operator(OperatorType.NOT_EQUAL, exclude_version)\n\n            return operator.to_string()\n\n        return concat_pipes_spaced(item.to_string() for item in self.items)\n\n    def to_short_string(self) -&gt; str:\n        exclude_version = self.exclude_version\n\n        if exclude_version:\n            operator = Operator(OperatorType.NOT_EQUAL, exclude_version)\n\n            return operator.to_short_string()\n\n        return concat_pipes(item.to_short_string() for item in self.items)\n</code></pre>"},{"location":"reference/version_sets/#versions.version_sets.is_version_empty","title":"<code>is_version_empty(item: Any) -&gt; TypeGuard[VersionEmpty]</code>","text":"<p>Checks if an <code>item</code> is an instance of <code>VersionEmpty</code>.</p> <p>Returns:</p> Type Description <code>TypeGuard[VersionEmpty]</code> <p>Whether the <code>item</code> provided is an instance of <code>VersionEmpty</code>.</p> Source code in <code>versions/version_sets.py</code> <pre><code>def is_version_empty(item: Any) -&gt; TypeGuard[VersionEmpty]:\n\"\"\"Checks if an `item` is an instance of [`VersionEmpty`][versions.version_sets.VersionEmpty].\n\n    Returns:\n        Whether the `item` provided is an instance\n            of [`VersionEmpty`][versions.version_sets.VersionEmpty].\n    \"\"\"\n    return is_instance(item, VersionEmpty)\n</code></pre>"},{"location":"reference/version_sets/#versions.version_sets.is_version_point","title":"<code>is_version_point(item: Any) -&gt; TypeGuard[VersionPoint]</code>","text":"<p>Checks if an <code>item</code> is an instance of <code>VersionPoint</code>.</p> <p>Returns:</p> Type Description <code>TypeGuard[VersionPoint]</code> <p>Whether the <code>item</code> provided is an instance of <code>VersionPoint</code>.</p> Source code in <code>versions/version_sets.py</code> <pre><code>def is_version_point(item: Any) -&gt; TypeGuard[VersionPoint]:\n\"\"\"Checks if an `item` is an instance of [`VersionPoint`][versions.version_sets.VersionPoint].\n\n    Returns:\n        Whether the `item` provided is an instance\n            of [`VersionPoint`][versions.version_sets.VersionPoint].\n    \"\"\"\n    return is_instance(item, VersionPoint)\n</code></pre>"},{"location":"reference/version_sets/#versions.version_sets.is_version_range","title":"<code>is_version_range(item: Any) -&gt; TypeGuard[VersionRange]</code>","text":"<p>Checks if an <code>item</code> is an instance of <code>VersionRange</code>.</p> <p>Returns:</p> Type Description <code>TypeGuard[VersionRange]</code> <p>Whether the <code>item</code> provided is an instance of <code>VersionRange</code>.</p> Source code in <code>versions/version_sets.py</code> <pre><code>def is_version_range(item: Any) -&gt; TypeGuard[VersionRange]:\n\"\"\"Checks if an `item` is an instance of [`VersionRange`][versions.version_sets.VersionRange].\n\n    Returns:\n        Whether the `item` provided is an instance\n            of [`VersionRange`][versions.version_sets.VersionRange].\n    \"\"\"\n    return is_instance(item, VersionRange)\n</code></pre>"},{"location":"reference/version_sets/#versions.version_sets.is_version_union","title":"<code>is_version_union(item: Any) -&gt; TypeGuard[VersionUnion]</code>","text":"<p>Checks if an <code>item</code> is an instance of <code>VersionUnion</code>.</p> <p>Returns:</p> Type Description <code>TypeGuard[VersionUnion]</code> <p>Whether the <code>item</code> provided is an instance of <code>VersionUnion</code>.</p> Source code in <code>versions/version_sets.py</code> <pre><code>def is_version_union(item: Any) -&gt; TypeGuard[VersionUnion]:\n\"\"\"Checks if an `item` is an instance of [`VersionUnion`][versions.version_sets.VersionUnion].\n\n    Returns:\n        Whether the `item` provided is an instance\n            of [`VersionUnion`][versions.version_sets.VersionUnion].\n    \"\"\"\n    return is_instance(item, VersionUnion)\n</code></pre>"},{"location":"reference/version_sets/#versions.version_sets.is_version_item","title":"<code>is_version_item(item: Any) -&gt; TypeGuard[VersionItem]</code>","text":"<p>Checks if an <code>item</code> is an instance of <code>VersionItem</code>.</p> <p>Returns:</p> Type Description <code>TypeGuard[VersionItem]</code> <p>Whether the <code>item</code> provided is an instance of <code>VersionItem</code>.</p> Source code in <code>versions/version_sets.py</code> <pre><code>def is_version_item(item: Any) -&gt; TypeGuard[VersionItem]:\n\"\"\"Checks if an `item` is an instance of [`VersionItem`][versions.version_sets.VersionItem].\n\n    Returns:\n        Whether the `item` provided is an instance\n            of [`VersionItem`][versions.version_sets.VersionItem].\n    \"\"\"\n    return is_instance(item, VersionItemTypes)\n</code></pre>"},{"location":"reference/version_sets/#versions.version_sets.is_version_set","title":"<code>is_version_set(item: Any) -&gt; TypeGuard[VersionSet]</code>","text":"<p>Checks if an <code>item</code> is an instance of <code>VersionSet</code>.</p> <p>Returns:</p> Type Description <code>TypeGuard[VersionSet]</code> <p>Whether the <code>item</code> provided is an instance of <code>VersionSet</code>.</p> Source code in <code>versions/version_sets.py</code> <pre><code>def is_version_set(item: Any) -&gt; TypeGuard[VersionSet]:\n\"\"\"Checks if an `item` is an instance of [`VersionSet`][versions.version_sets.VersionSet].\n\n    Returns:\n        Whether the `item` provided is an instance\n            of [`VersionSet`][versions.version_sets.VersionSet].\n    \"\"\"\n    return is_instance(item, VersionSetTypes)\n</code></pre>"},{"location":"reference/versioned/","title":"Versioned","text":""},{"location":"reference/versioned/#versions.versioned.has_version","title":"<code>has_version = is_versioned</code>  <code>module-attribute</code>","text":"<p>An alias of <code>is_versioned</code>.</p>"},{"location":"reference/versioned/#versions.versioned.Versioned","title":"<code>Versioned</code>","text":"<p>         Bases: <code>Protocol</code></p> <p>Represents versioned objects, that is, objects that have the <code>__version__</code> attribute of type <code>str</code>.</p> Source code in <code>versions/versioned.py</code> <pre><code>@runtime_checkable\nclass Versioned(Protocol):\n\"\"\"Represents versioned objects, that is, objects that have the `__version__`\n    attribute of type [`str`][str].\n    \"\"\"\n\n    __version__: str\n</code></pre>"},{"location":"reference/versioned/#versions.versioned.is_versioned","title":"<code>is_versioned(item: Any) -&gt; TypeGuard[Versioned]</code>","text":"<p>Checks if the <code>item</code> implements the <code>Versioned</code> protocol.</p> <p>That is, whether the <code>item</code> has the <code>__version__</code> attribute of type <code>str</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>The item to check.</p> required <p>Returns:</p> Type Description <code>TypeGuard[Versioned]</code> <p>Whether the <code>item</code> implements the <code>Versioned</code> protocol.</p> Source code in <code>versions/versioned.py</code> <pre><code>def is_versioned(item: Any) -&gt; TypeGuard[Versioned]:\n\"\"\"Checks if the `item` implements the [`Versioned`][versions.versioned.Versioned] protocol.\n\n    That is, whether the `item` has the `__version__` attribute of type [`str`][str].\n\n    Parameters:\n        item: The item to check.\n\n    Returns:\n        Whether the `item` implements the [`Versioned`][versions.versioned.Versioned] protocol.\n    \"\"\"\n    return has_attribute(item, VERSION) and is_string(item.__version__)\n</code></pre>"},{"location":"reference/versioned/#versions.versioned.get_version","title":"<code>get_version(item: Any, version_type: Type[Version] = Version) -&gt; Optional[Version]</code>","text":"<p>Parses the version of the <code>item</code> if <code>has_version(item)</code>, otherwise this function returns <code>None</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>The item to fetch the version from.</p> required <code>version_type</code> <code>Type[Version]</code> <p>The type of the version to parse.</p> <code>Version</code> <p>Returns:</p> Type Description <code>Optional[Version]</code> <p>The version of <code>version_type</code> of the <code>item</code>, if one is present, otherwise <code>None</code>.</p> Source code in <code>versions/versioned.py</code> <pre><code>def get_version(item: Any, version_type: Type[Version] = Version) -&gt; Optional[Version]:\n\"\"\"Parses the version of the `item` if [`has_version(item)`][versions.versioned.has_version],\n    otherwise this function returns [`None`][None].\n\n    Parameters:\n        item: The item to fetch the version from.\n        version_type: The type of the version to parse.\n\n    Returns:\n        The version of `version_type` of the `item`, if one is present, otherwise [`None`][None].\n    \"\"\"\n    return get_version_unchecked(item, version_type) if has_version(item) else None\n</code></pre>"},{"location":"reference/versioned/#versions.versioned.get_version_unchecked","title":"<code>get_version_unchecked(item: Versioned, version_type: Type[Version] = Version) -&gt; Version</code>","text":"<p>Fetches the <code>__version__</code> attribute of the <code>item</code>, parsing it into the version of <code>version_type</code>, without checking whether the attribute exists.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Versioned</code> <p>The item to fetch the version from.</p> required <code>version_type</code> <code>Type[Version]</code> <p>The type of the version to parse.</p> <code>Version</code> <p>Returns:</p> Type Description <code>Version</code> <p>The version of <code>version_type</code> of the item.</p> Source code in <code>versions/versioned.py</code> <pre><code>def get_version_unchecked(item: Versioned, version_type: Type[Version] = Version) -&gt; Version:\n\"\"\"Fetches the `__version__` attribute of the `item`,\n    parsing it into the version of `version_type`, without checking whether the attribute exists.\n\n    Parameters:\n        item: The item to fetch the version from.\n        version_type: The type of the version to parse.\n\n    Returns:\n        The version of `version_type` of the item.\n    \"\"\"\n    return parse_version(item.__version__, version_type)\n</code></pre>"}]}