{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"versions Parsing, inspecting and specifying versions. Installing Python 3.7 or above is required. pip Installing the library with pip is quite simple: $ pip install versions Alternatively, the library can be installed from source: $ git clone https://github.com/nekitdev/versions.git $ cd versions $ python -m pip install . poetry You can add versions as a dependency with the following command: $ poetry add versions Or by directly specifying it in the configuration like so: [tool.poetry.dependencies] versions = \"^1.0.0-alpha.1\" Alternatively, you can add it directly from the source: [tool.poetry.dependencies.versions] git = \"https://github.com/nekitdev/versions.git\" Examples Versions parse_version is used to parse versions: from versions import parse_version version = parse_version ( \"1.0.0-dev.1+build.1\" ) print ( version ) # 1.0.0-dev.1+build.1 Segments All version segments can be fetched with their respective names: >>> print ( version . release ) 1.0.0 >>> version . release . parts ( 1 , 0 , 0 ) >>> print ( version . dev ) dev .1 >>> ( version . dev . phase , version . dev . value ) ( \"dev\" , 1 ) >>> print ( version . local ) build .1 >>> version . local . parts ( \"build\" , 1 ) Comparison Versions support total ordering: >>> v1 = parse_version ( \"1.0.0\" ) >>> v2 = parse_version ( \"2.0.0\" ) >>> v1 == v2 False >>> v1 != v2 True >>> v1 >= v2 False >>> v1 <= v2 True >>> v1 > v2 False >>> v1 < v2 True Specification versions also supports specifying version requirements and matching version against them: Since versions support total ordering, they can be checked using version sets (via parse_version_set ): >>> from versions import parse_version , parse_version_set >>> version_set = parse_version_set ( \"^1.0.0\" ) >>> version_set < VersionRange ( >= 1.0.0 , < 2.0.0 ) > >>> version = parse_version ( \"1.3.0\" ) >>> version < Version ( 1.3.0 ) > >>> version . matches ( version_set ) True >>> another = parse_version ( \"2.2.0\" ) >>> another . matches ( version_set ) False Documentation You can find the documentation here . Support If you need support with the library, you can send an email or refer to the official Discord server . Changelog You can find the changelog here . Security Policy You can find the Security Policy of versions here . Contributing If you are interested in contributing to versions , make sure to take a look at the Contributing Guide , as well as the Code of Conduct . License versions is licensed under the MIT License terms. See License for details.","title":"Index"},{"location":"#versions","text":"Parsing, inspecting and specifying versions.","title":"versions"},{"location":"#installing","text":"Python 3.7 or above is required.","title":"Installing"},{"location":"#pip","text":"Installing the library with pip is quite simple: $ pip install versions Alternatively, the library can be installed from source: $ git clone https://github.com/nekitdev/versions.git $ cd versions $ python -m pip install .","title":"pip"},{"location":"#poetry","text":"You can add versions as a dependency with the following command: $ poetry add versions Or by directly specifying it in the configuration like so: [tool.poetry.dependencies] versions = \"^1.0.0-alpha.1\" Alternatively, you can add it directly from the source: [tool.poetry.dependencies.versions] git = \"https://github.com/nekitdev/versions.git\"","title":"poetry"},{"location":"#examples","text":"","title":"Examples"},{"location":"#versions_1","text":"parse_version is used to parse versions: from versions import parse_version version = parse_version ( \"1.0.0-dev.1+build.1\" ) print ( version ) # 1.0.0-dev.1+build.1","title":"Versions"},{"location":"#segments","text":"All version segments can be fetched with their respective names: >>> print ( version . release ) 1.0.0 >>> version . release . parts ( 1 , 0 , 0 ) >>> print ( version . dev ) dev .1 >>> ( version . dev . phase , version . dev . value ) ( \"dev\" , 1 ) >>> print ( version . local ) build .1 >>> version . local . parts ( \"build\" , 1 )","title":"Segments"},{"location":"#comparison","text":"Versions support total ordering: >>> v1 = parse_version ( \"1.0.0\" ) >>> v2 = parse_version ( \"2.0.0\" ) >>> v1 == v2 False >>> v1 != v2 True >>> v1 >= v2 False >>> v1 <= v2 True >>> v1 > v2 False >>> v1 < v2 True","title":"Comparison"},{"location":"#specification","text":"versions also supports specifying version requirements and matching version against them: Since versions support total ordering, they can be checked using version sets (via parse_version_set ): >>> from versions import parse_version , parse_version_set >>> version_set = parse_version_set ( \"^1.0.0\" ) >>> version_set < VersionRange ( >= 1.0.0 , < 2.0.0 ) > >>> version = parse_version ( \"1.3.0\" ) >>> version < Version ( 1.3.0 ) > >>> version . matches ( version_set ) True >>> another = parse_version ( \"2.2.0\" ) >>> another . matches ( version_set ) False","title":"Specification"},{"location":"#documentation","text":"You can find the documentation here .","title":"Documentation"},{"location":"#support","text":"If you need support with the library, you can send an email or refer to the official Discord server .","title":"Support"},{"location":"#changelog","text":"You can find the changelog here .","title":"Changelog"},{"location":"#security-policy","text":"You can find the Security Policy of versions here .","title":"Security Policy"},{"location":"#contributing","text":"If you are interested in contributing to versions , make sure to take a look at the Contributing Guide , as well as the Code of Conduct .","title":"Contributing"},{"location":"#license","text":"versions is licensed under the MIT License terms. See License for details.","title":"License"},{"location":"changelog/","text":"Changelog","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"code_of_conduct/","text":"Code of Conduct Our Pledge We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation. We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community. Our Standards Examples of behavior that contributes to a positive environment for our community include: Demonstrating empathy and kindness toward other people Being respectful of differing opinions, viewpoints, and experiences Giving and gracefully accepting constructive feedback Accepting responsibility and apologizing to those affected by our mistakes, and learning from the experience Focusing on what is best not just for us as individuals, but for the overall community Examples of unacceptable behavior include: The use of sexualized language or imagery, and sexual attention or advances of any kind Trolling, insulting or derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or email address, without their explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Enforcement Responsibilities Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful. Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate. Scope This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official email address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Enforcement Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement to conduct@nekit.dev . All complaints will be reviewed and investigated promptly and fairly. All community leaders are obligated to respect the privacy and security of the reporter of any incident. Enforcement Guidelines Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct: 1. Correction Community Impact : Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community. Consequence : A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested. 2. Warning Community Impact : A violation through a single incident or series of actions. Consequence : A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban. 3. Temporary Ban Community Impact : A serious violation of community standards, including sustained inappropriate behavior. Consequence : A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban. 4. Permanent Ban Community Impact : Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals. Consequence : A permanent ban from any sort of public interaction within the community. Attribution This Code of Conduct is adapted from the Contributor Covenant , version 2.1, available at https://contributor-covenant.org/version/2/1/code_of_conduct . Community Impact Guidelines were inspired by Mozilla's Code of Conduct enforcement ladder . For answers to common questions about this code of conduct, see the FAQ at https://contributor-covenant.org/faq . Translations are available at https://contributor-covenant.org/translations .","title":"Code of Conduct"},{"location":"code_of_conduct/#code-of-conduct","text":"","title":"Code of Conduct"},{"location":"code_of_conduct/#our-pledge","text":"We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation. We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.","title":"Our Pledge"},{"location":"code_of_conduct/#our-standards","text":"Examples of behavior that contributes to a positive environment for our community include: Demonstrating empathy and kindness toward other people Being respectful of differing opinions, viewpoints, and experiences Giving and gracefully accepting constructive feedback Accepting responsibility and apologizing to those affected by our mistakes, and learning from the experience Focusing on what is best not just for us as individuals, but for the overall community Examples of unacceptable behavior include: The use of sexualized language or imagery, and sexual attention or advances of any kind Trolling, insulting or derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or email address, without their explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"code_of_conduct/#enforcement-responsibilities","text":"Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful. Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.","title":"Enforcement Responsibilities"},{"location":"code_of_conduct/#scope","text":"This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official email address, posting via an official social media account, or acting as an appointed representative at an online or offline event.","title":"Scope"},{"location":"code_of_conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement to conduct@nekit.dev . All complaints will be reviewed and investigated promptly and fairly. All community leaders are obligated to respect the privacy and security of the reporter of any incident.","title":"Enforcement"},{"location":"code_of_conduct/#enforcement-guidelines","text":"Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:","title":"Enforcement Guidelines"},{"location":"code_of_conduct/#1-correction","text":"Community Impact : Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community. Consequence : A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.","title":"1. Correction"},{"location":"code_of_conduct/#2-warning","text":"Community Impact : A violation through a single incident or series of actions. Consequence : A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.","title":"2. Warning"},{"location":"code_of_conduct/#3-temporary-ban","text":"Community Impact : A serious violation of community standards, including sustained inappropriate behavior. Consequence : A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.","title":"3. Temporary Ban"},{"location":"code_of_conduct/#4-permanent-ban","text":"Community Impact : Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals. Consequence : A permanent ban from any sort of public interaction within the community.","title":"4. Permanent Ban"},{"location":"code_of_conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 2.1, available at https://contributor-covenant.org/version/2/1/code_of_conduct . Community Impact Guidelines were inspired by Mozilla's Code of Conduct enforcement ladder . For answers to common questions about this code of conduct, see the FAQ at https://contributor-covenant.org/faq . Translations are available at https://contributor-covenant.org/translations .","title":"Attribution"},{"location":"contributing/","text":"","title":"Contributing"},{"location":"reference/","text":"Reference Parsing, inspecting and specifying versions. Example >>> from versions import parse_version , parse_version_set >>> version = parse_version ( \"1.0.0\" ) >>> version < Version ( 1.0.0 ) > >>> version_set = parse_version_set ( \"^1.0.0\" ) >>> version_set < VersionRange ( >= 1.0.0 , < 2.0.0 ) > >>> version . matches ( version_set ) True parse_version ( string , version_type = Version ) Parses a string into a version of version_type . Parameters: Name Type Description Default string str The string to parse. required version_type Type [ Version ] The version type to use in conversion. Version Returns: Type Description Version A newly parsed Version . Source code in versions/functions.py 27 28 29 30 31 32 33 34 35 36 37 def parse_version ( string : str , version_type : Type [ Version ] = Version ) -> Version : \"\"\"Parses a `string` into a version of `version_type`. Arguments: string: The string to parse. version_type: The version type to use in conversion. Returns: A newly parsed [`Version`][versions.version.Version]. \"\"\" return VersionParser ( version_type ) . parse ( string ) parse_specifier ( string , version_type = Version ) Parses a string into a version specifier with versions of version_type . Parameters: Name Type Description Default string str The string to parse. required version_type Type [ Version ] The version type to use in conversion. Version Returns: Type Description Specifier A newly parsed Specifier . Source code in versions/functions.py 40 41 42 43 44 45 46 47 48 49 50 def parse_specifier ( string : str , version_type : Type [ Version ] = Version ) -> Specifier : \"\"\"Parses a `string` into a version specifier with versions of `version_type`. Arguments: string: The string to parse. version_type: The version type to use in conversion. Returns: A newly parsed [`Specifier`][versions.specifiers.Specifier]. \"\"\" return SpecifierParser ( VersionParser ( version_type )) . parse ( string ) parse_version_set ( string , version_type = Version ) Parses a string into a version set with versions of version_type . Parameters: Name Type Description Default string str The string to parse. required version_type Type [ Version ] The version type to use in conversion. Version Returns: Type Description VersionSet A newly parsed Specifier . Source code in versions/functions.py 53 54 55 56 57 58 59 60 61 62 63 def parse_version_set ( string : str , version_type : Type [ Version ] = Version ) -> VersionSet : \"\"\"Parses a `string` into a version set with versions of `version_type`. Arguments: string: The string to parse. version_type: The version type to use in conversion. Returns: A newly parsed [`Specifier`][versions.specifiers.Specifier]. \"\"\" return VersionSetParser ( SpecifierParser ( VersionParser ( version_type ))) . parse ( string ) Version Bases: Representation , FromString , ToString Represents versions. Source code in versions/version.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 @frozen ( repr = False , eq = True , order = True ) class Version ( Representation , FromString , ToString ): \"\"\"Represents versions.\"\"\" epoch : Epoch = field ( factory = Epoch , eq = False , order = False ) release : Release = field ( factory = Release , eq = False , order = False ) pre : Optional [ PreTag ] = field ( default = None , eq = False , order = False ) post : Optional [ PostTag ] = field ( default = None , eq = False , order = False ) dev : Optional [ DevTag ] = field ( default = None , eq = False , order = False ) local : Optional [ Local ] = field ( default = None , eq = False , order = False ) compare_key : CompareKey = field ( repr = False , init = False , eq = True , order = True ) def __attrs_post_init__ ( self ) -> None : evolve_in_place ( self , compare_key = self . compute_compare_key ()) @staticmethod def compute_compare_tags ( pre : Optional [ PreTag ], post : Optional [ PostTag ], dev : Optional [ DevTag ] ) -> Tuple [ ComparePreTag , ComparePostTag , CompareDevTag ]: compare_pre : ComparePreTag compare_post : ComparePostTag compare_dev : CompareDevTag if pre is None : if post is None and dev is not None : compare_pre = negative_infinity else : compare_pre = infinity else : compare_pre = pre compare_post = negative_infinity if post is None else post compare_dev = infinity if dev is None else dev return ( compare_pre , compare_post , compare_dev ) @staticmethod def compute_compare_local ( local : Optional [ Local ]) -> CompareLocal : return negative_infinity if local is None else local def compute_compare_key ( self ) -> CompareKey : compare_epoch = self . epoch compare_release = self . release compare_pre , compare_post , compare_dev = self . compute_compare_tags ( self . pre , self . post , self . dev ) compare_local = self . compute_compare_local ( self . local ) return ( compare_epoch , compare_release , compare_pre , compare_post , compare_dev , compare_local , ) def to_string_iterator ( self ) -> Iterator [ str ]: epoch = self . epoch if epoch : yield epoch . to_string () yield EXCLAMATION yield self . release . to_string () pre = self . pre if pre : yield DASH yield pre . to_string () post = self . post if post : yield DASH yield post . to_string () dev = self . dev if dev : yield DASH yield dev . to_string () local = self . local if local : yield PLUS yield local . to_string () def to_short_string_iterator ( self ) -> Iterator [ str ]: epoch = self . epoch if epoch : yield epoch . to_short_string () yield EXCLAMATION yield self . release . to_short_string () pre = self . pre if pre : yield pre . to_short_string () post = self . post if post : yield DOT yield post . to_short_string () dev = self . dev if dev : yield DOT yield dev . to_short_string () local = self . local if local : yield PLUS yield local . to_short_string () def to_string ( self ) -> str : return concat_empty ( self . to_string_iterator ()) def to_short_string ( self ) -> str : return concat_empty ( self . to_short_string_iterator ()) @classmethod def from_string ( cls : Type [ V ], string : str ) -> V : return VersionParser ( cls ) . parse ( string ) @property def precision ( self ) -> int : return self . release . precision @property def last_index ( self ) -> int : return self . release . last_index @property def major ( self ) -> int : return self . release . major @property def minor ( self ) -> int : return self . release . minor @property def micro ( self ) -> int : return self . release . micro @property def patch ( self ) -> int : return self . release . patch @property def extra ( self ) -> Extra : return self . release . extra def get_major ( self ) -> int : return self . release . get_major () def get_minor ( self ) -> int : return self . release . get_minor () def get_micro ( self ) -> int : return self . release . get_micro () def get_patch ( self ) -> int : return self . release . get_patch () def get_extra ( self ) -> Extra : return self . release . get_extra () def get_at ( self , index : int , default : int = DEFAULT_VALUE ) -> int : return self . release . get_at ( index , default ) def get_at_unchecked ( self , index : int ) -> int : return self . release . get_at_unchecked ( index ) def is_semantic ( self ) -> bool : return self . release . is_semantic () def to_semantic ( self : V ) -> V : return self . update ( release = self . release . to_semantic ()) def set_major ( self : V , value : int ) -> V : return self . update ( release = self . release . set_major ( value )) def set_minor ( self : V , value : int ) -> V : return self . update ( release = self . release . set_minor ( value )) def set_micro ( self : V , value : int ) -> V : return self . update ( release = self . release . set_micro ( value )) def set_patch ( self : V , value : int ) -> V : return self . update ( release = self . release . set_patch ( value )) def set_at ( self : V , index : int , value : int ) -> V : return self . update ( release = self . release . set_at ( index , value )) def set_at_unchecked ( self : V , index : int , value : int ) -> V : return self . update ( release = self . release . set_at_unchecked ( index , value )) def next_major ( self : V ) -> V : release = self . release if self . is_stable (): release = release . next_major () return self . create ( self . epoch , release ) def next_minor ( self : V ) -> V : release = self . release if self . is_stable (): release = release . next_minor () return self . create ( self . epoch , release ) def next_micro ( self : V ) -> V : release = self . release if self . is_stable (): release = release . next_micro () return self . create ( self . epoch , release ) def next_patch ( self : V ) -> V : release = self . release if self . is_stable (): release = release . next_patch () return self . create ( self . epoch , release ) def next_at ( self : V , index : int ) -> V : release = self . release if self . is_stable (): release = release . next_at ( index ) return self . create ( self . epoch , release ) def has_major ( self ) -> bool : return self . release . has_major () def has_minor ( self ) -> bool : return self . release . has_minor () def has_micro ( self ) -> bool : return self . release . has_micro () def has_patch ( self ) -> bool : return self . release . has_patch () def has_extra ( self ) -> bool : return self . release . has_extra () def has_at ( self , index : int ) -> bool : return self . has_at ( index ) def pad_to ( self : V , length : int , padding : int = DEFAULT_PADDING ) -> V : return evolve ( self , release = self . release . pad_to ( length , padding )) def pad_to_index ( self : V , index : int , padding : int = DEFAULT_PADDING ) -> V : return evolve ( self , release = self . release . pad_to_index ( index , padding )) def pad_to_next ( self : V , padding : int = DEFAULT_PADDING ) -> V : return evolve ( self , release = self . release . pad_to_next ( padding )) def is_pre_release ( self ) -> bool : return self . pre is not None def is_post_release ( self ) -> bool : return self . post is not None def is_dev_release ( self ) -> bool : return self . dev is not None def is_local ( self ) -> bool : return self . local is not None def is_not_pre_release ( self ) -> bool : return self . pre is None def is_not_post_release ( self ) -> bool : return self . post is None def is_not_dev_release ( self ) -> bool : return self . dev is None def is_not_local ( self ) -> bool : return self . local is None def is_unstable ( self ) -> bool : return self . is_pre_release () or self . is_dev_release () def is_stable ( self ) -> bool : return self . is_not_pre_release () and self . is_not_dev_release () def next_pre ( self : V ) -> V : pre = self . pre if pre is None : pre = PreTag () else : pre = pre . next () return self . create ( self . epoch , self . release , pre ) def next_pre_phase ( self : V ) -> Optional [ V ]: pre = self . pre if pre is None : pre = PreTag () else : pre = pre . next_phase () if pre is None : return None return self . create ( self . epoch , self . release , pre ) def next_post ( self : V ) -> V : post = self . post if post is None : post = PostTag () else : post = post . next () return self . create ( self . epoch , self . release , self . pre , post , self . dev ) def next_dev ( self : V ) -> V : dev = self . dev if dev is None : dev = DevTag () else : dev = dev . next () return self . create ( self . epoch , self . release , self . pre , self . post , dev ) def with_pre ( self : V , pre : PreTag ) -> V : return self . update ( pre = pre ) def with_post ( self : V , post : PostTag ) -> V : return self . update ( post = post ) def with_dev ( self : V , dev : DevTag ) -> V : return self . update ( dev = dev ) def with_local ( self : V , local : Local ) -> V : return self . update ( local = local ) def without_pre ( self : V ) -> V : return self . update ( pre = None ) def without_post ( self : V ) -> V : return self . update ( post = None ) def without_dev ( self : V ) -> V : return self . update ( dev = None ) def without_local ( self : V ) -> V : return self . update ( local = None ) def update ( self : V , ** changes : Any ) -> V : return evolve ( self , ** changes ) def weaken ( self , other : W ) -> W : if not self . is_local () and other . is_local (): other = other . without_local () if not self . is_post_release () and other . is_post_release (): other = other . without_post () return other def to_stable ( self : V ) -> V : return self if self . is_stable () else self . create ( self . epoch , self . release ) def next_breaking ( self : V ) -> V : \"\"\"Returns the next breaking version. This function is slightly convoluted due to how `0.x.y` versions are handled: | version | next breaking | |---------|---------------| | `1.2.3` | `2.0.0` | | `1.2.0` | `2.0.0` | | `1.0.0` | `2.0.0` | | `0.2.3` | `0.3.0` | | `0.0.3` | `0.0.4` | | `0.0.0` | `0.0.1` | | `0.0` | `0.1.0` | | `0` | `1.0.0` | Returns: The next breaking [`Version`][versions.version.Version]. \"\"\" if not self . major : if self . minor : return self . next_minor () if self . has_micro (): return self . next_micro () if self . has_minor (): return self . next_minor () return self . next_major () return self . to_stable () . next_major () def normalize ( self : V ) -> V : pre = self . pre if pre : pre = pre . normalize () post = self . post if post : post = post . normalize () dev = self . dev if dev : dev = dev . normalize () return self . update ( pre = pre , post = post , dev = dev ) @classmethod def create ( cls : Type [ V ], epoch : Optional [ Epoch ] = None , release : Optional [ Release ] = None , pre : Optional [ PreTag ] = None , post : Optional [ PostTag ] = None , dev : Optional [ DevTag ] = None , local : Optional [ Local ] = None , ) -> V : if epoch is None : epoch = Epoch () if release is None : release = Release () return cls ( epoch , release , pre , post , dev , local ) @classmethod def from_parts ( cls : Type [ V ], major : int = DEFAULT_VALUE , minor : int = DEFAULT_VALUE , micro : int = DEFAULT_VALUE , * extra : int , epoch : Optional [ Epoch ] = None , pre : Optional [ PreTag ] = None , post : Optional [ PostTag ] = None , dev : Optional [ DevTag ] = None , local : Optional [ Local ] = None , ) -> V : release = Release . from_parts ( major , minor , micro , * extra ) return cls . create ( epoch , release , pre , post , dev , local ) def matches ( self , specification : Specification ) -> bool : return specification . accepts ( self ) next_breaking () Returns the next breaking version. This function is slightly convoluted due to how 0.x.y versions are handled: version next breaking 1.2.3 2.0.0 1.2.0 2.0.0 1.0.0 2.0.0 0.2.3 0.3.0 0.0.3 0.0.4 0.0.0 0.0.1 0.0 0.1.0 0 1.0.0 Returns: Type Description V The next breaking Version . Source code in versions/version.py 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 def next_breaking ( self : V ) -> V : \"\"\"Returns the next breaking version. This function is slightly convoluted due to how `0.x.y` versions are handled: | version | next breaking | |---------|---------------| | `1.2.3` | `2.0.0` | | `1.2.0` | `2.0.0` | | `1.0.0` | `2.0.0` | | `0.2.3` | `0.3.0` | | `0.0.3` | `0.0.4` | | `0.0.0` | `0.0.1` | | `0.0` | `0.1.0` | | `0` | `1.0.0` | Returns: The next breaking [`Version`][versions.version.Version]. \"\"\" if not self . major : if self . minor : return self . next_minor () if self . has_micro (): return self . next_micro () if self . has_minor (): return self . next_minor () return self . next_major () return self . to_stable () . next_major () Epoch Bases: Representation , FromString , ToString Represents the epoch part of the version ( e! ). Source code in versions/segments.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 @frozen ( repr = False , eq = True , order = True ) class Epoch ( Representation , FromString , ToString ): \"\"\"Represents the epoch part of the version (`e!`).\"\"\" value : int = field ( default = DEFAULT_VALUE ) def __bool__ ( self ) -> bool : return bool ( self . value ) @classmethod def create ( cls : Type [ E ], value : int = DEFAULT_VALUE ) -> E : return cls ( value ) @classmethod def from_string ( cls : Type [ E ], string : str ) -> E : return cls ( int ( string )) def to_string ( self ) -> str : return str ( self . value ) Release Bases: Representation , FromString , ToString Represents the release part of the version ( x.y.z ). Source code in versions/segments.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 @frozen ( repr = False , eq = True , order = True ) class Release ( Representation , FromString , ToString ): \"\"\"Represents the release part of the version (`x.y.z`).\"\"\" parts : Parts = field ( default = DEFAULT_PARTS , eq = False , order = False ) compare_parts : Parts = field ( repr = False , init = False , eq = True , order = True ) @parts . validator def check_parts ( self , attribute : Attribute [ Parts ], value : Parts ) -> None : if not value : raise ValueError ( EMPTY_RELEASE ) def __attrs_post_init__ ( self ) -> None : evolve_in_place ( self , compare_parts = self . compute_compare_parts ()) def compute_compare_parts ( self ) -> Parts : parts = self . parts index = count_leading_zeros ( reversed ( parts )) if index == self . precision : index -= 1 return self . slice_parts ( - index ) if index else parts @classmethod def create ( cls : Type [ R ], parts : Parts = DEFAULT_PARTS ) -> R : return cls ( parts ) @classmethod def from_iterable ( cls : Type [ R ], iterable : Iterable [ int ]) -> R : return cls ( tuple ( iterable )) @classmethod def from_parts ( cls : Type [ R ], * parts : int ) -> R : return cls ( parts ) def into_parts ( self ) -> Parts : return self . parts @property def precision ( self ) -> int : return len ( self . parts ) @property def last_index ( self ) -> int : return self . precision - 1 def get_major ( self ) -> int : return self . get_at ( MAJOR ) def get_minor ( self ) -> int : return self . get_at ( MINOR ) def get_micro ( self ) -> int : return self . get_at ( MICRO ) def get_patch ( self ) -> int : return self . get_at ( PATCH ) def get_extra ( self ) -> Extra : return self . parts [ TOTAL :] @property def extra ( self ) -> Extra : ... extra = property ( get_extra ) # type: ignore def get_at ( self , index : int , default : int = DEFAULT_VALUE ) -> int : return self . get_at_unchecked ( index ) if self . has_at ( index ) else default def get_at_unchecked ( self , index : int ) -> int : return self . parts [ index ] def is_semantic ( self ) -> bool : return self . precision == TOTAL def to_semantic ( self : R ) -> R : if self . has_extra (): return self . next_patch () . slice ( TOTAL ) return self if self . is_semantic () else self . pad_to ( TOTAL ) def set_major ( self : R , value : int ) -> R : return self . set_at ( MAJOR , value ) def set_minor ( self : R , value : int ) -> R : return self . set_at ( MINOR , value ) def set_micro ( self : R , value : int ) -> R : return self . set_at ( MICRO , value ) def set_patch ( self : R , value : int ) -> R : return self . set_at ( PATCH , value ) @property def major ( self ) -> int : ... @property def minor ( self ) -> int : ... @property def micro ( self ) -> int : ... @property def patch ( self ) -> int : ... major = property ( get_major , set_major ) # type: ignore minor = property ( get_minor , set_minor ) # type: ignore micro = property ( get_micro , set_micro ) # type: ignore patch = property ( get_patch , set_patch ) # type: ignore def set_at ( self : R , index : int , value : int ) -> R : return self . pad_to_index ( index ) . set_at_unchecked ( index , value ) def set_at_unchecked ( self : R , index : int , value : int ) -> R : mutable = list ( self . parts ) mutable [ index ] = value return self . from_iterable ( mutable ) def next_major ( self : R ) -> R : return self . next_at ( MAJOR ) def next_minor ( self : R ) -> R : return self . next_at ( MINOR ) def next_micro ( self : R ) -> R : return self . next_at ( MICRO ) def next_patch ( self : R ) -> R : return self . next_at ( PATCH ) def next_at ( self : R , index : int ) -> R : updated = self . set_at ( index , self . get_at ( index ) + 1 ) return updated . slice ( index + 1 ) . pad_to ( updated . precision ) def has_major ( self ) -> bool : return self . has_at ( MAJOR ) def has_minor ( self ) -> bool : return self . has_at ( MINOR ) def has_micro ( self ) -> bool : return self . has_at ( MICRO ) def has_patch ( self ) -> bool : return self . has_at ( PATCH ) def has_extra ( self ) -> bool : return self . has_at ( TOTAL ) def has_at ( self , index : int ) -> bool : return self . precision > index def pad_to ( self : R , length : int , padding : int = DEFAULT_PADDING ) -> R : if self . precision < length : return self . from_iterable ( pad_to_length ( length , padding , self . parts )) return self def pad_to_index ( self : R , index : int , padding : int = DEFAULT_PADDING ) -> R : return self . pad_to ( index + 1 , padding ) def pad_to_next ( self : R , padding : int = DEFAULT_PADDING ) -> R : return self . pad_to ( self . precision + 1 , padding ) def slice ( self : R , stop : int ) -> R : return self . create ( self . slice_parts ( stop )) def slice_parts ( self , stop : int ) -> Parts : return self . parts [: stop ] @classmethod def from_string ( cls : Type [ R ], string : str ) -> R : return cls . from_iterable ( map ( int , split_dot ( string ))) def to_string ( self ) -> str : return concat_dot ( map ( str , self . parts )) Tag Bases: Representation , FromString , ToString Represents various tag parts of the version ( tag.n ). Source code in versions/segments.py 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 @frozen ( repr = False , eq = True , order = True ) class Tag ( Representation , FromString , ToString ): \"\"\"Represents various tag parts of the version (`tag.n`).\"\"\" DEFAULT_PHASE : ClassVar [ str ] = PHASE_ALL_DEFAULT PHASE_SET : ClassVar [ Set [ str ]] = PHASE_ALL_SET phase : str = field ( converter = case_fold ) # type: ignore value : int = field ( default = DEFAULT_VALUE ) @phase . default def default_phase ( self ) -> str : return self . DEFAULT_PHASE @phase . validator def check_phase ( self , attribute : Attribute [ str ], value : str ) -> None : if value not in self . PHASE_SET : raise ValueError ( PHASE_NOT_ALLOWED . format ( value , get_name ( type ( self )))) def __attrs_post_init__ ( self ) -> None : evolve_in_place ( self , phase = self . expand ( self . phase )) @staticmethod def expand ( phase : str ) -> str : return SHORT_TO_PHASE . get ( phase , phase ) @staticmethod def reduce ( phase : str ) -> str : return PHASE_TO_SHORT . get ( phase , phase ) @staticmethod def normalize_phase ( phase : str ) -> str : return PHASE_TO_NORMAL . get ( phase , phase ) @classmethod def create ( cls : Type [ T ], phase : Optional [ str ] = None , value : int = DEFAULT_VALUE ) -> T : if phase is None : phase = cls . DEFAULT_PHASE return cls ( phase , value ) @classmethod def default_with_value ( cls : Type [ T ], value : int ) -> T : # TODO: change the name? return cls ( value = value ) @property def short ( self ) -> str : return self . reduce ( self . phase ) @property def normal ( self ) -> str : return self . normalize_phase ( self . phase ) def normalize ( self : T ) -> T : return evolve ( self , phase = self . normal ) def next ( self : T ) -> T : return evolve ( self , value = self . value + 1 ) def next_phase ( self : T ) -> Optional [ T ]: phase = PHASE_TO_NEXT . get ( self . phase ) return None if phase is None else self . create ( phase ) @classmethod def from_string ( cls : Type [ T ], string : str ) -> T : return TagParser ( cls ) . parse ( string ) def to_string ( self ) -> str : return concat_dot_args ( self . phase , str ( self . value )) def to_short_string ( self ) -> str : return concat_empty_args ( self . short , str ( self . value )) PreTag Bases: Tag Represents the pre-release part of the version ( pre.n ). Source code in versions/segments.py 376 377 378 379 380 381 @frozen ( repr = False , eq = True , order = True ) class PreTag ( Tag ): \"\"\"Represents the pre-release part of the version (`pre.n`).\"\"\" DEFAULT_PHASE = PHASE_PRE_DEFAULT PHASE_SET = PHASE_PRE_SET PostTag Bases: Tag Represents the post-release part of the version ( pre.n ). Source code in versions/segments.py 384 385 386 387 388 389 @frozen ( repr = False , eq = True , order = True ) class PostTag ( Tag ): \"\"\"Represents the post-release part of the version (`pre.n`).\"\"\" DEFAULT_PHASE = PHASE_POST_DEFAULT PHASE_SET = PHASE_POST_SET DevTag Bases: Tag Represents the dev-release part of the version ( dev.n ). Source code in versions/segments.py 392 393 394 395 396 397 @frozen ( repr = False , eq = True , order = True ) class DevTag ( Tag ): \"\"\"Represents the dev-release part of the version (`dev.n`).\"\"\" DEFAULT_PHASE = PHASE_DEV_DEFAULT PHASE_SET = PHASE_DEV_SET Local Bases: Representation , FromString , ToString Represents the local part of the version ( +abcdefg.n ) Source code in versions/segments.py 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 @frozen ( repr = False , eq = True , order = True ) class Local ( Representation , FromString , ToString ): \"\"\"Represents the local part of the version (`+abcdefg.n`)\"\"\" parts : LocalParts = field ( eq = False , order = False ) compare_parts : CompareLocalParts = field ( repr = False , init = False , eq = True , order = True ) @parts . validator def check_parts ( self , attribute : Attribute [ LocalParts ], value : LocalParts ) -> None : if not value : raise ValueError ( EMPTY_LOCAL ) def __attrs_post_init__ ( self ) -> None : evolve_in_place ( self , compare_parts = self . compute_compare_parts ()) def compute_compare_parts ( self ) -> CompareLocalParts : empty = EMPTY return tuple ( ( part , empty ) if is_int ( part ) else ( negative_infinity , part ) # type: ignore for part in self . parts ) @classmethod def create ( cls : Type [ L ], parts : LocalParts ) -> L : return cls ( parts ) @classmethod def from_iterable ( cls : Type [ L ], iterable : Iterable [ LocalPart ]) -> L : return cls ( tuple ( iterable )) @classmethod def from_parts ( cls : Type [ L ], * local_parts : LocalPart ) -> L : return cls ( local_parts ) def into_parts ( self ) -> LocalParts : return self . parts @classmethod def from_string ( cls : Type [ L ], string : str ) -> L : return cls . from_iterable ( map ( local_part , split_separators ( string ))) def to_string ( self ) -> str : return concat_dot ( map ( str , self . parts )) Specification Bases: Protocol The specification protocol for specifying version requirements. Source code in versions/specification.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @runtime_checkable class Specification ( Protocol ): \"\"\"The specification protocol for specifying version requirements.\"\"\" @abstractmethod def accepts ( self , version : Version ) -> bool : \"\"\"Checks if the `version` matches the specification. Arguments: version: The version to check. Returns: Whether the `version` matches the specification. \"\"\" raise NotImplementedError accepts ( version ) abstractmethod Checks if the version matches the specification. Parameters: Name Type Description Default version Version The version to check. required Returns: Type Description bool Whether the version matches the specification. Source code in versions/specification.py 18 19 20 21 22 23 24 25 26 27 28 @abstractmethod def accepts ( self , version : Version ) -> bool : \"\"\"Checks if the `version` matches the specification. Arguments: version: The version to check. Returns: Whether the `version` matches the specification. \"\"\" raise NotImplementedError VersionSet = Union [ VersionEmpty , VersionPoint , VersionRange , VersionUnion ] module-attribute The union of the following types: VersionEmpty VersionPoint VersionRange VersionUnion VersionEmpty Bases: Representation , ToString , VersionSetProtocol Represents version empty sets ( {} ). Source code in versions/version_sets.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 @frozen ( repr = False , order = False ) class VersionEmpty ( Representation , ToString , VersionSetProtocol ): \"\"\"Represents version empty sets (`{}`).\"\"\" def is_empty ( self ) -> Literal [ True ]: return True def is_universe ( self ) -> Literal [ False ]: return False def includes ( self , version_set : VersionSet ) -> bool : return version_set . is_empty () def intersects ( self , version_set : VersionSet ) -> Literal [ False ]: return False def contains ( self , version : Version ) -> Literal [ False ]: return False def intersection ( self : E , version_set : VersionSet ) -> E : return self def union ( self , version_set : S ) -> S : return version_set def difference ( self : E , version_set : VersionSet ) -> E : return self def symmetric_difference ( self , version_set : S ) -> S : return version_set def complement ( self ) -> VersionRange : return VersionRange () def to_string ( self ) -> str : return EMPTY_VERSION VersionRange Bases: Representation , ToString , VersionRangeProtocol , VersionSetProtocol Represents version ranges ( (x, y) , (x, y] , [x, y) and [x, y] ). Source code in versions/version_sets.py 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 @frozen ( repr = False , eq = False , order = False ) class VersionRange ( Representation , ToString , VersionRangeProtocol , VersionSetProtocol ): \"\"\"Represents version ranges (`(x, y)`, `(x, y]`, `[x, y)` and `[x, y]`).\"\"\" min : Optional [ Version ] = None max : Optional [ Version ] = None include_min : bool = False include_max : bool = False def __attrs_post_init__ ( self ) -> None : if self . min is None : evolve_in_place ( self , include_min = False ) if self . max is None : evolve_in_place ( self , include_max = False ) if self . comparable_min > self . comparable_max : raise ValueError # TODO: message? def is_empty ( self ) -> bool : return self . is_empty_or_point () and not self . is_closed () def is_point ( self ) -> bool : return self . is_empty_or_point () and self . is_closed () def is_universe ( self ) -> bool : return self . is_unbounded () @property def version ( self ) -> Version : version = self . min or self . max if version is None : raise ValueError # TODO: message? if self . is_point (): return version raise ValueError # TODO: message? def contains ( self , version : Version ) -> bool : comparable_min = self . comparable_min comparable_max = self . comparable_max # if is_not_infinity(comparable_max): # version = comparable_max.weaken(version) if version < comparable_min : return False if self . exclude_min and version == comparable_min : return False if version > comparable_max : return False if self . exclude_max and version == comparable_max : return False return True accepts = contains def includes ( self , version_set : VersionSet ) -> bool : if is_version_empty ( version_set ): return True if is_version_point ( version_set ): return self . contains ( version_set . version ) if is_version_range ( version_set ): return not version_set . is_lower ( self ) and not version_set . is_higher ( self ) if is_version_union ( version_set ): return all ( self . includes ( item ) for item in version_set . items ) raise TypeError # TODO: message? def intersects ( self , version_set : VersionSet ) -> bool : if is_version_empty ( version_set ): return False if is_version_point ( version_set ): return self . contains ( version_set . version ) if is_version_range ( version_set ): return self . intersects_range ( version_set ) if is_version_union ( version_set ): return any ( self . intersects ( item ) for item in version_set . items ) raise TypeError # TODO: message? def intersects_range ( self , range : VersionRange ) -> bool : return not range . is_strictly_lower ( self ) and not range . is_strictly_higher ( self ) def intersection ( self , version_set : VersionSet ) -> VersionSet : if is_version_empty ( version_set ): return VersionEmpty () if is_version_point ( version_set ): return version_set . intersection ( self ) if is_version_range ( version_set ): if self . is_lower ( version_set ): if self . is_strictly_lower ( version_set ): return VersionEmpty () intersection_min = version_set . min intersection_include_min = version_set . include_min else : if self . is_strictly_higher ( version_set ): return VersionEmpty () intersection_min = self . min intersection_include_min = self . include_min if self . is_higher ( version_set ): intersection_max = version_set . max intersection_include_max = version_set . include_max else : intersection_max = self . max intersection_include_max = self . include_max # if we reached here, there is an actual range intersection = VersionRange ( intersection_min , intersection_max , intersection_include_min , intersection_include_max , ) if intersection . is_point (): return VersionPoint ( intersection . version ) return intersection if is_version_union ( version_set ): return version_set . intersection ( self ) raise TypeError # TODO: message def union ( self , version_set : VersionSet ) -> VersionSet : if is_version_empty ( version_set ): return self if is_version_point ( version_set ): version = version_set . version if self . contains ( version ): return self if version == self . min : return evolve ( self , include_min = True ) if version == self . max : return evolve ( self , include_max = True ) return VersionUnion . of ( self , version_set ) if is_version_range ( version_set ): if not self . is_adjacent ( version_set ) and not self . intersects ( version_set ): return VersionUnion . of ( self , version_set ) if self . is_lower ( version_set ): union_min = self . min union_include_min = self . include_min else : union_min = version_set . min union_include_min = version_set . include_min if self . is_higher ( version_set ): union_max = self . max union_include_max = self . include_max else : union_max = version_set . max union_include_max = version_set . include_max return VersionRange ( union_min , union_max , union_include_min , union_include_max , ) if is_version_union ( version_set ): return version_set . union ( self ) raise TypeError # TODO: message def difference ( self , version_set : VersionSet ) -> VersionSet : if is_version_empty ( version_set ): return self if is_version_point ( version_set ): version = version_set . version if not self . contains ( version ): return self if version == self . min : if self . exclude_min : return self return evolve ( self , include_min = False ) if version == self . max : if self . exclude_max : return self return evolve ( self , include_max = False ) return VersionUnion . of ( evolve ( self , max = version , include_max = False ), evolve ( self , min = version , include_min = False ), ) if is_version_range ( version_set ): if not self . intersects ( version_set ): return self before : Optional [ VersionItem ] if not self . is_lower ( version_set ): before = None elif self . min == version_set . min : before = VersionPoint ( self . checked_min ) else : before = evolve ( self , max = version_set . min , include_max = version_set . exclude_min ) after : Optional [ VersionItem ] if not self . is_higher ( version_set ): after = None elif self . max == version_set . max : after = VersionPoint ( self . checked_max ) else : after = evolve ( self , min = version_set . max , include_min = version_set . exclude_max ) if before is None and after is None : return VersionEmpty () if before is None : return after # type: ignore if after is None : return before # type: ignore return VersionUnion . of ( before , after ) if is_version_union ( version_set ): return VersionUnion . of_iterable ( self . difference_iterator ( version_set )) raise TypeError # TODO: message? def difference_iterator ( self , version_union : VersionUnion ) -> Iterator [ VersionItem ]: current : VersionItem = self for item in version_union . items : if item . is_strictly_lower ( current ): continue if item . is_strictly_higher ( current ): break difference = current . difference ( item ) if is_version_union ( difference ): item , current = difference . items yield item if is_version_item ( difference ): current = difference yield current def complement ( self ) -> VersionSet : return VersionRange () . difference ( self ) def to_string_iterator ( self ) -> Iterator [ str ]: if self . is_empty (): yield EMPTY_VERSION return if self . is_point (): yield self . version . to_string () return if self . is_universe (): yield UNIVERSE_VERSION return min = self . min if min : min_type = OperatorType . GREATER_OR_EQUAL if self . include_min else OperatorType . GREATER min_operator = Operator ( min_type , min ) yield min_operator . to_string () max = self . max if max : max_type = OperatorType . LESS_OR_EQUAL if self . include_max else OperatorType . LESS max_operator = Operator ( max_type , max ) yield max_operator . to_string () def to_short_string_iterator ( self ) -> Iterator [ str ]: if self . is_empty (): yield EMPTY_VERSION return if self . is_point (): yield self . version . to_short_string () return if self . is_universe (): yield UNIVERSE_VERSION return min = self . min if min : min_type = OperatorType . GREATER_OR_EQUAL if self . include_min else OperatorType . GREATER min_operator = Operator ( min_type , min ) yield min_operator . to_short_string () max = self . max if max : max_type = OperatorType . LESS_OR_EQUAL if self . include_max else OperatorType . LESS max_operator = Operator ( max_type , max ) yield max_operator . to_short_string () def to_string ( self ) -> str : return concat_comma_space ( self . to_string_iterator ()) def to_short_string ( self ) -> str : return concat_comma ( self . to_short_string_iterator ()) VersionPoint Bases: Representation , ToString , VersionRangeProtocol , VersionSetProtocol Represents version points ( [v, v] aka {v} ). Source code in versions/version_sets.py 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 @frozen ( repr = False , eq = False , order = False ) class VersionPoint ( Representation , ToString , VersionRangeProtocol , VersionSetProtocol ): \"\"\"Represents version points (`[v, v]` aka `{v}`).\"\"\" version : Version @property def min ( self ) -> Optional [ Version ]: # type: ignore return self . version @property def max ( self ) -> Optional [ Version ]: # type: ignore return self . version @property def include_min ( self ) -> bool : # type: ignore return True @property def include_max ( self ) -> bool : # type: ignore return True def is_empty ( self ) -> bool : return False def is_point ( self ) -> bool : return True def is_universe ( self ) -> bool : return False def contains ( self , version : Version ) -> bool : # version = self.version.weaken(version) return self . version == version accepts = contains def includes ( self , version_set : VersionSet ) -> bool : return version_set . is_empty () or ( is_version_point ( version_set ) and self . contains ( version_set . version ) ) def intersects ( self , version_set : VersionSet ) -> bool : return version_set . contains ( self . version ) def intersection ( self , version_set : VersionSet ) -> VersionSet : return self if version_set . contains ( self . version ) else VersionEmpty () def union ( self , version_set : VersionSet ) -> VersionSet : if is_version_empty ( version_set ): return self if is_version_point ( version_set ): if self . contains ( version_set . version ): return self return VersionUnion . of ( self , version_set ) if version_set . contains ( self . version ): return version_set if is_version_range ( version_set ) or is_version_union ( version_set ): return VersionUnion . of ( self , version_set ) raise TypeError # TODO: message? def difference ( self , version_set : VersionSet ) -> VersionSet : return VersionEmpty () if version_set . contains ( self . version ) else self def complement ( self ) -> VersionSet : return VersionRange () . difference ( self ) def to_string ( self ) -> str : return self . version . to_string () def to_short_string ( self ) -> str : return self . version . to_short_string () VersionUnion Bases: Representation , ToString , Specification Represents version unions. Source code in versions/version_sets.py 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 @frozen ( repr = False , order = False ) class VersionUnion ( Representation , ToString , Specification ): \"\"\"Represents version unions.\"\"\" items : VersionItems = field () @items . validator def check_items ( self , attribute : Attribute [ VersionItems ], items : VersionItems ) -> None : check_items ( items ) @classmethod def extract ( cls , version_set : VersionSet ) -> Iterator [ VersionItem ]: if is_version_union ( version_set ): yield from version_set . items elif is_version_item ( version_set ): yield version_set else : raise TypeError # TODO: message? @classmethod def of ( cls , * version_sets : VersionSet ) -> VersionSet : return cls . of_iterable ( version_sets ) @classmethod def of_iterable ( cls , iterable : Iterable [ VersionSet ]) -> VersionSet : extracted = list ( flatten ( map ( cls . extract , iterable ))) if not extracted : return VersionEmpty () if any ( item . is_universe () for item in extracted ): return VersionRange () extracted . sort () merged : List [ VersionItem ] = [] for item in extracted : if not merged : merged . append ( item ) else : last_item = last ( merged ) if last_item . intersects ( item ) or last_item . is_adjacent ( item ): result = last_item . union ( item ) if is_version_item ( result ): set_last ( merged , result ) else : raise InternalError # TODO: message? else : merged . append ( item ) if contains_only_item ( merged ): return first ( merged ) return cls ( tuple ( merged )) @property def exclude_version ( self ) -> Optional [ Version ]: complement = self . complement () return complement . version if is_version_point ( complement ) else None def is_empty ( self ) -> bool : return False def is_universe ( self ) -> bool : return False def contains ( self , version : Version ) -> bool : return any ( item . contains ( version ) for item in self . items ) accepts = contains def includes ( self , version_set : VersionSet ) -> bool : self_items = iter ( self . items ) items = self . extract ( version_set ) self_item = next_or_none ( self_items ) item = next_or_none ( items ) while self_item and item : if self_item . includes ( item ): item = next_or_none ( items ) else : self_item = next_or_none ( self_items ) return item is None # all items are covered def intersects ( self , version_set : VersionSet ) -> bool : self_items = iter ( self . items ) items = self . extract ( version_set ) self_item = next_or_none ( self_items ) item = next_or_none ( items ) while self_item and item : if self_item . intersects ( item ): return True if item . is_higher ( self_item ): self_item = next_or_none ( self_items ) else : item = next_or_none ( items ) return False # none of the items are allowed def intersection_iterator ( self , version_set : VersionSet ) -> Iterator [ VersionItem ]: self_items = iter ( self . items ) items = self . extract ( version_set ) self_item = next_or_none ( self_items ) item = next_or_none ( items ) while self_item and item : intersection = self_item . intersection ( item ) if is_version_item ( intersection ): yield intersection if item . is_higher ( self_item ): self_item = next_or_none ( self_items ) else : item = next_or_none ( items ) def intersection ( self , version_set : VersionSet ) -> VersionSet : return self . of_iterable ( self . intersection_iterator ( version_set )) def union ( self , version_set : VersionSet ) -> VersionSet : return self . of ( self , version_set ) def difference ( self , version_set : VersionSet ) -> VersionSet : items_difference = ItemsDifference ( iter ( self . items ), self . extract ( version_set )) return self . of_iterable ( items_difference . compute ()) def complement ( self ) -> VersionSet : return VersionRange () . difference ( self ) def to_string ( self ) -> str : exclude_version = self . exclude_version if exclude_version : operator = Operator ( OperatorType . NOT_EQUAL , exclude_version ) return operator . to_string () return concat_pipes_spaced ( item . to_string () for item in self . items ) def to_short_string ( self ) -> str : exclude_version = self . exclude_version if exclude_version : operator = Operator ( OperatorType . NOT_EQUAL , exclude_version ) return operator . to_short_string () return concat_pipes ( item . to_short_string () for item in self . items ) Specifier Bases: Representation , ToString , Specification Represents all possible specifiers. Source code in versions/specifiers.py 43 44 class Specifier ( Representation , ToString , Specification ): \"\"\"Represents all possible specifiers.\"\"\" SpecifierFalse Bases: Specifier Represents specifiers that do not accept any version. Source code in versions/specifiers.py 50 51 52 53 54 55 56 57 58 @frozen ( repr = False ) class SpecifierFalse ( Specifier ): \"\"\"Represents specifiers that do not accept any version.\"\"\" def accepts ( self , version : Version ) -> Literal [ False ]: return False def to_string ( self ) -> str : return EMPTY_VERSION SpecifierTrue Bases: Specifier Represents specifiers that accept all versions. Source code in versions/specifiers.py 61 62 63 64 65 66 67 68 69 @frozen ( repr = False ) class SpecifierTrue ( Specifier ): \"\"\"Represents specifiers that accept all versions.\"\"\" def accepts ( self , version : Version ) -> Literal [ True ]: return True def to_string ( self ) -> str : return UNIVERSE_VERSION SpecifierSingle Bases: Operator , Specifier Represents specifiers that accept versions according to the Operator type. Source code in versions/specifiers.py 72 73 74 75 76 77 78 79 @frozen ( repr = False ) class SpecifierSingle ( Operator , Specifier ): \"\"\"Represents specifiers that accept versions according to the [`Operator`][versions.operators.Operator] type. \"\"\" def accepts ( self , version : Version ) -> bool : return self . partial_matches ( version ) SpecifierAny Bases: Specifier Represents collections of two or more specifiers that accept versions if any of the contained specifiers accept it. Source code in versions/specifiers.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 @frozen ( repr = False ) class SpecifierAny ( Specifier ): \"\"\"Represents collections of two or more specifiers that accept versions if any of the contained specifiers accept it. \"\"\" WRAP : ClassVar [ bool ] = False specifiers : Specifiers = field () @specifiers . validator def check_specifiers ( self , attribute : Attribute [ Specifiers ], specifiers : Specifiers ) -> None : check_specifiers ( specifiers ) @classmethod def of_specifiers ( cls , specifiers : Specifiers ) -> Specifier : if not specifiers : return SpecifierTrue () if contains_only_item ( specifiers ): return first ( specifiers ) return cls ( specifiers ) @classmethod def of ( cls , * specifiers : Specifier ) -> Specifier : return cls . of_specifiers ( specifiers ) @classmethod def of_iterable ( cls , iterable : Iterable [ Specifier ]) -> Specifier : return cls . of_specifiers ( tuple ( iterable )) def accepts ( self , version : Version ) -> bool : return any ( specifier . accepts ( version ) for specifier in self . specifiers ) def to_string ( self ) -> str : return create_wrap_around ( concat_pipes_spaced ( specifier . to_string () for specifier in self . specifiers ) ) def to_short_string ( self ) -> str : return create_wrap_around ( concat_pipes ( specifier . to_short_string () for specifier in self . specifiers ) ) SpecifierAll Bases: Specifier Represents collections of two or more specifiers that accept versions if and only if all of the contained specifiers accept it. Source code in versions/specifiers.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 @frozen ( repr = False ) class SpecifierAll ( Specifier ): \"\"\"Represents collections of two or more specifiers that accept versions if and only if all of the contained specifiers accept it. \"\"\" WRAP : ClassVar [ bool ] = False specifiers : Specifiers = field () @specifiers . validator def check_specifiers ( self , attribute : Attribute [ Specifiers ], specifiers : Specifiers ) -> None : check_specifiers ( specifiers ) @classmethod def of_specifiers ( cls , specifiers : Specifiers ) -> Specifier : if not specifiers : return SpecifierTrue () if contains_only_item ( specifiers ): return first ( specifiers ) return cls ( specifiers ) @classmethod def of ( cls , * specifiers : Specifier ) -> Specifier : return cls . of_specifiers ( specifiers ) @classmethod def of_iterable ( cls , iterable : Iterable [ Specifier ]) -> Specifier : return cls . of_specifiers ( tuple ( iterable )) def accepts ( self , version : Version ) -> bool : return all ( specifier . accepts ( version ) for specifier in self . specifiers ) def to_string ( self ) -> str : return create_wrap_around ( concat_comma_space ( specifier . to_string () for specifier in self . specifiers ) ) def to_short_string ( self ) -> str : return create_wrap_around ( concat_comma ( specifier . to_short_string () for specifier in self . specifiers ) ) is_specifier ( item ) Checks if an item is an instance of Specifier . Parameters: Name Type Description Default item Any The item to check. required Returns: Type Description TypeGuard [ Specifier ] Whether the item provided is an instance of Specifier . Source code in versions/specifiers.py 186 187 188 189 190 191 192 193 194 195 def is_specifier ( item : Any ) -> TypeGuard [ Specifier ]: \"\"\"Checks if an `item` is an instance of [`Specifier`][versions.specifiers.Specifier]. Arguments: item: The item to check. Returns: Whether the `item` provided is an instance of [`Specifier`][versions.specifiers.Specifier]. \"\"\" return is_instance ( item , Specifier ) is_specifier_false ( item ) Checks if an item is an instance of SpecifierFalse . Parameters: Name Type Description Default item Any The item to check. required Returns: Type Description TypeGuard [ SpecifierFalse ] Whether the item provided is an instance of TypeGuard [ SpecifierFalse ] SpecifierFalse . Source code in versions/specifiers.py 198 199 200 201 202 203 204 205 206 207 208 209 def is_specifier_false ( item : Any ) -> TypeGuard [ SpecifierFalse ]: \"\"\"Checks if an `item` is an instance of [`SpecifierFalse`][versions.specifiers.SpecifierFalse]. Arguments: item: The item to check. Returns: Whether the `item` provided is an instance of [`SpecifierFalse`][versions.specifiers.SpecifierFalse]. \"\"\" return is_instance ( item , SpecifierFalse ) is_specifier_true ( item ) Checks if an item is an instance of SpecifierTrue . Parameters: Name Type Description Default item Any The item to check. required Returns: Type Description TypeGuard [ SpecifierTrue ] Whether the item provided is an instance of TypeGuard [ SpecifierTrue ] SpecifierTrue . Source code in versions/specifiers.py 212 213 214 215 216 217 218 219 220 221 222 223 def is_specifier_true ( item : Any ) -> TypeGuard [ SpecifierTrue ]: \"\"\"Checks if an `item` is an instance of [`SpecifierTrue`][versions.specifiers.SpecifierTrue]. Arguments: item: The item to check. Returns: Whether the `item` provided is an instance of [`SpecifierTrue`][versions.specifiers.SpecifierTrue]. \"\"\" return is_instance ( item , SpecifierTrue ) is_specifier_single ( item ) Checks if an item is an instance of SpecifierSingle . Parameters: Name Type Description Default item Any The item to check. required Returns: Type Description TypeGuard [ SpecifierSingle ] Whether the item provided is an instance of TypeGuard [ SpecifierSingle ] SpecifierSingle . Source code in versions/specifiers.py 226 227 228 229 230 231 232 233 234 235 236 237 def is_specifier_single ( item : Any ) -> TypeGuard [ SpecifierSingle ]: \"\"\"Checks if an `item` is an instance of [`SpecifierSingle`][versions.specifiers.SpecifierSingle]. Arguments: item: The item to check. Returns: Whether the `item` provided is an instance of [`SpecifierSingle`][versions.specifiers.SpecifierSingle]. \"\"\" return is_instance ( item , SpecifierSingle ) is_specifier_any ( item ) Checks if an item is an instance of SpecifierAny . Parameters: Name Type Description Default item Any The item to check. required Returns: Type Description TypeGuard [ SpecifierAny ] Whether the item provided is an instance of TypeGuard [ SpecifierAny ] SpecifierAny . Source code in versions/specifiers.py 240 241 242 243 244 245 246 247 248 249 250 251 def is_specifier_any ( item : Any ) -> TypeGuard [ SpecifierAny ]: \"\"\"Checks if an `item` is an instance of [`SpecifierAny`][versions.specifiers.SpecifierAny]. Arguments: item: The item to check. Returns: Whether the `item` provided is an instance of [`SpecifierAny`][versions.specifiers.SpecifierAny]. \"\"\" return is_instance ( item , SpecifierAny ) is_specifier_all ( item ) Checks if an item is an instance of SpecifierAll . Parameters: Name Type Description Default item Any The item to check. required Returns: Type Description TypeGuard [ SpecifierAll ] Whether the item provided is an instance of TypeGuard [ SpecifierAll ] SpecifierAll . Source code in versions/specifiers.py 254 255 256 257 258 259 260 261 262 263 264 265 def is_specifier_all ( item : Any ) -> TypeGuard [ SpecifierAll ]: \"\"\"Checks if an `item` is an instance of [`SpecifierAll`][versions.specifiers.SpecifierAll]. Arguments: item: The item to check. Returns: Whether the `item` provided is an instance of [`SpecifierAll`][versions.specifiers.SpecifierAll]. \"\"\" return is_instance ( item , SpecifierAll ) simplify ( specifier ) Simplifies Specifier specification. Simplification is accomplished through converting to the version set and back. Source code in versions/converters.py 45 46 47 48 49 50 def simplify ( specifier : Specifier ) -> Specifier : \"\"\"Simplifies [`Specifier`][versions.specifiers.Specifier] specification. Simplification is accomplished through converting to the version set and back. \"\"\" return specifier_from_version_set ( specifier_to_version_set ( specifier )) specifier_to_version_set ( specifier ) Converts Specifier to VersionSet . There is an alias of this called version_set_from_specifier . Source code in versions/converters.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def specifier_to_version_set ( specifier : Specifier ) -> VersionSet : \"\"\"Converts [`Specifier`][versions.specifiers.Specifier] to [`VersionSet`][versions.version_sets.VersionSet]. There is an alias of this called `version_set_from_specifier`. \"\"\" if is_specifier_single ( specifier ): return specifier . translate ( specifier . version ) if is_specifier_false ( specifier ): return VersionEmpty () if is_specifier_true ( specifier ): return VersionRange () if is_specifier_all ( specifier ): return reduce ( intersection , map ( specifier_to_version_set , specifier . specifiers )) if is_specifier_any ( specifier ): return reduce ( union , map ( specifier_to_version_set , specifier . specifiers )) raise TypeError # TODO: message? version_set_to_specifier ( version_set ) Converts VersionSet to Specifier . There is an alias of this function called specifier_from_version_set . Source code in versions/converters.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 def version_set_to_specifier ( version_set : VersionSet ) -> Specifier : \"\"\"Converts [`VersionSet`][versions.version_sets.VersionSet] to [`Specifier`][versions.specifiers.Specifier]. There is an alias of this function called `specifier_from_version_set`. \"\"\" if is_version_empty ( version_set ): return SpecifierFalse () if is_version_point ( version_set ): return SpecifierSingle ( OperatorType . DOUBLE_EQUAL , version_set . version ) if is_version_range ( version_set ): if version_set . is_empty (): return SpecifierFalse () if version_set . is_universe (): return SpecifierTrue () if version_set . is_point (): return SpecifierSingle ( OperatorType . DOUBLE_EQUAL , version_set . version ) min = version_set . min max = version_set . max min_specifier = None max_specifier = None if min : min_type = ( OperatorType . GREATER_OR_EQUAL if version_set . include_min else OperatorType . GREATER ) min_specifier = SpecifierSingle ( min_type , min ) if max : max_type = OperatorType . LESS_OR_EQUAL if version_set . include_max else OperatorType . LESS max_specifier = SpecifierSingle ( max_type , max ) if min_specifier and max_specifier : return SpecifierAll . of ( min_specifier , max_specifier ) specifier = min_specifier or max_specifier if specifier is None : raise InternalError # TODO: message? return specifier if is_version_union ( version_set ): exclude_version = version_set . exclude_version if exclude_version : return SpecifierSingle ( OperatorType . NOT_EQUAL , exclude_version ) return SpecifierAny . of_iterable ( map ( version_set_to_specifier , version_set . items )) raise TypeError # TODO: message? OperatorType Bases: Enum Represents operator types. Source code in versions/operators.py 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 class OperatorType ( Enum ): \"\"\"Represents operator types.\"\"\" # official constraints TILDE_EQUAL = TILDE_EQUAL DOUBLE_EQUAL = DOUBLE_EQUAL NOT_EQUAL = NOT_EQUAL LESS = LESS LESS_OR_EQUAL = LESS_OR_EQUAL GREATER = GREATER GREATER_OR_EQUAL = GREATER_OR_EQUAL # additional constraints CARET = CARET EQUAL = EQUAL TILDE = TILDE # wildcard constraints WILDCARD_DOUBLE_EQUAL = WILDCARD_DOUBLE_EQUAL WILDCARD_EQUAL = WILDCARD_EQUAL WILDCARD_NOT_EQUAL = WILDCARD_NOT_EQUAL def is_wildcard ( self ) -> bool : \"\"\"Checks whether the operator is *wildcard*.\"\"\" return self in WILDCARD def is_unary ( self ) -> bool : \"\"\"Checks whether the operator is *unary*.\"\"\" return self in UNARY @property def string ( self ) -> str : return wildcard_type ( self . value ) is_wildcard () Checks whether the operator is wildcard . Source code in versions/operators.py 666 667 668 def is_wildcard ( self ) -> bool : \"\"\"Checks whether the operator is *wildcard*.\"\"\" return self in WILDCARD is_unary () Checks whether the operator is unary . Source code in versions/operators.py 670 671 672 def is_unary ( self ) -> bool : \"\"\"Checks whether the operator is *unary*.\"\"\" return self in UNARY Operator Bases: Representation , ToString Represents operators. Source code in versions/operators.py 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 @frozen ( repr = False ) class Operator ( Representation , ToString ): \"\"\"Represents operators.\"\"\" type : OperatorType version : Version def is_unary ( self ) -> bool : \"\"\"Checks whether the operator is *unary*.\"\"\" return self . type . is_unary () def is_wildcard ( self ) -> bool : \"\"\"Checks whether the operator is *wildcard*.\"\"\" return self . type . is_wildcard () @property def matches_and_translate ( self ) -> Tuple [ Matches , Translate ]: return OPERATOR [ self . type ] @property def matches ( self ) -> Matches : \"\"\"The `matches` function representing the operator.\"\"\" matches , _translate = self . matches_and_translate return matches @property def translate ( self ) -> Translate : \"\"\"The `translate` function representing the operator.\"\"\" _matches , translate = self . matches_and_translate return translate @property def partial_matches ( self ) -> PartialMatches : \"\"\"The partial `matches` function with `self.version` as the `version`.\"\"\" return partial_matches ( self . matches , self . version ) def to_string ( self ) -> str : string = self . version . to_string () if self . is_wildcard (): string = wildcard_string ( string ) if self . is_unary (): return concat_empty_args ( self . type . string , string ) return concat_space_args ( self . type . string , string ) def to_short_string ( self ) -> str : string = self . version . to_short_string () if self . is_wildcard (): string = wildcard_string ( string ) return concat_empty_args ( self . type . string , string ) is_unary () Checks whether the operator is unary . Source code in versions/operators.py 711 712 713 def is_unary ( self ) -> bool : \"\"\"Checks whether the operator is *unary*.\"\"\" return self . type . is_unary () is_wildcard () Checks whether the operator is wildcard . Source code in versions/operators.py 715 716 717 def is_wildcard ( self ) -> bool : \"\"\"Checks whether the operator is *wildcard*.\"\"\" return self . type . is_wildcard () matches () property The matches function representing the operator. Source code in versions/operators.py 723 724 725 726 727 728 @property def matches ( self ) -> Matches : \"\"\"The `matches` function representing the operator.\"\"\" matches , _translate = self . matches_and_translate return matches translate () property The translate function representing the operator. Source code in versions/operators.py 730 731 732 733 734 735 @property def translate ( self ) -> Translate : \"\"\"The `translate` function representing the operator.\"\"\" _matches , translate = self . matches_and_translate return translate partial_matches () property The partial matches function with self.version as the version . Source code in versions/operators.py 737 738 739 740 @property def partial_matches ( self ) -> PartialMatches : \"\"\"The partial `matches` function with `self.version` as the `version`.\"\"\" return partial_matches ( self . matches , self . version ) next_caret_breaking ( version ) Returns the next breaking version according to the caret ( ^ ) strategy. This function is slightly convoluted due to handling 0.x.y versions. See Version.next_breaking for more information. Example >>> from versions import next_caret_breaking , parse_version >>> version = parse_version ( \"1.0.0\" ) >>> version < Version ( 1.0.0 ) > >>> next_caret_breaking ( version ) < Version ( 2.0.0 ) > Parameters: Name Type Description Default version V The version to find next breaking version of. required Returns: Type Description V The next breaking version according to the version . Source code in versions/operators.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 def next_caret_breaking ( version : V ) -> V : \"\"\"Returns the next breaking version according to the *caret* (`^`) strategy. This function is slightly convoluted due to handling `0.x.y` versions. See [`Version.next_breaking`][versions.version.Version.next_breaking] for more information. Example: ```python >>> from versions import next_caret_breaking, parse_version >>> version = parse_version(\"1.0.0\") >>> version <Version (1.0.0)> >>> next_caret_breaking(version) <Version (2.0.0)> ``` Arguments: version: The version to find next breaking version of. Returns: The next breaking version according to the `version`. \"\"\" return version . next_breaking () next_tilde_equal_breaking ( version ) Returns the next breaking version according to the tilde-equal ( ~= ) strategy. This function simply bumps the last part of the release. Example >>> from versions import next_tilde_equal_breaking , parse_version >>> version = parse_version ( \"1.2.2\" ) >>> version < Version ( 1.2.2 ) > >>> next_tilde_equal_breaking ( version ) < Version ( 1.2.3 ) > Parameters: Name Type Description Default version V The version to find the next breaking version of. required Returns: Type Description V The next breaking Version according to the version . Source code in versions/operators.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 def next_tilde_equal_breaking ( version : V ) -> V : \"\"\"Returns the next breaking version according to the *tilde-equal* (`~=`) strategy. This function simply bumps the last part of the release. Example: ```python >>> from versions import next_tilde_equal_breaking, parse_version >>> version = parse_version(\"1.2.2\") >>> version <Version (1.2.2)> >>> next_tilde_equal_breaking(version) <Version (1.2.3)> ``` Arguments: version: The version to find the next breaking version of. Returns: The next breaking [`Version`][versions.version.Version] according to the `version`. \"\"\" index = version . last_index if index : return version . to_stable () . next_at ( index - 1 ) raise ValueError # TODO: message? next_tilde_breaking ( version ) Returns the next breaking version according to the tilde ( ~ ) strategy. This function simply bumps the minor part of the version if it is present, otherwise the major part is bumped. Example >>> from versions import next_tilde_equal_breaking , parse_version >>> version = parse_version ( \"2.0.0\" ) >>> version < Version ( 2.1.0 ) > >>> next_tilde_breaking ( version ) < Version ( 2.2.0 ) > Parameters: Name Type Description Default version V The version to find the next breaking version of. required Returns: Type Description V The next breaking Version according to the version . Source code in versions/operators.py 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 def next_tilde_breaking ( version : V ) -> V : \"\"\"Returns the next breaking version according to the *tilde* (`~`) strategy. This function simply bumps the minor part of the version if it is present, otherwise the major part is bumped. Example: ```python >>> from versions import next_tilde_equal_breaking, parse_version >>> version = parse_version(\"2.0.0\") >>> version <Version (2.1.0)> >>> next_tilde_breaking(version) <Version (2.2.0)> ``` Arguments: version: The version to find the next breaking version of. Returns: The next breaking [`Version`][versions.version.Version] according to the `version`. \"\"\" if version . has_minor (): return version . next_minor () return version . next_major () next_wildcard_breaking ( version ) Returns the next breaking version according to the wildcard ( * ) strategy. There are three cases to handle: If the wildcard is used within the pre part of the version, next breaking version has the same release with pre part removed. For example, x.y.z-rc.* is bumped to x.y.z . If the wildcard is used within the post part of the version, next breaking version has the last part of the release bumped. For instance, x.y.z-post.* is bumped to x.y.z' , where z' = z + 1 . Otherwise, the second to last part of the release is bumped. For example, x.y.* is bumped to x.y'.0 , where y' = y + 1 . Note that this function returns None if the given version is * . Example >>> from versions import next_wildcard_breaking , parse_version >>> version = parse_version ( \"4.2.0\" ) >>> version < Version ( 4.2.0 ) > >>> next_wildcard_breaking ( version ) < Version ( 4.3.0 ) > >>> other = parse_version ( \"1.2.3-rc.0\" ) >>> other < Version ( 1.2.3 - rc .0 ) > >>> next_wildcard_breaking ( other ) < Version ( 1.2.3 ) > >>> another = parse_version ( \"0.6.8-post.0\" ) >>> another < Version ( 0.6.8 - post .0 ) > >>> next_wildcard_breaking ( another ) < Version ( 0.6.9 ) > # nice Parameters: Name Type Description Default version V The version to find the next breaking version of. required Returns: Type Description Optional [ V ] The next breaking Version according to the version , or None . Source code in versions/operators.py 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 def next_wildcard_breaking ( version : V ) -> Optional [ V ]: \"\"\"Returns the next breaking version according to the *wildcard* (`*`) strategy. There are three cases to handle: - If the wildcard is used within the `pre` part of the version, next breaking version has the same release with `pre` part removed. For example, `x.y.z-rc.*` is bumped to `x.y.z`. - If the wildcard is used within the `post` part of the version, next breaking version has the last part of the release bumped. For instance, `x.y.z-post.*` is bumped to `x.y.z'`, where `z' = z + 1`. - Otherwise, the second to last part of the release is bumped. For example, `x.y.*` is bumped to `x.y'.0`, where `y' = y + 1`. Note that this function returns [`None`][None] if the given version is `*`. Example: ```python >>> from versions import next_wildcard_breaking, parse_version >>> version = parse_version(\"4.2.0\") >>> version <Version (4.2.0)> >>> next_wildcard_breaking(version) <Version (4.3.0)> >>> other = parse_version(\"1.2.3-rc.0\") >>> other <Version (1.2.3-rc.0)> >>> next_wildcard_breaking(other) <Version (1.2.3)> >>> another = parse_version(\"0.6.8-post.0\") >>> another <Version (0.6.8-post.0)> >>> next_wildcard_breaking(another) <Version (0.6.9)> # nice ``` Arguments: version: The version to find the next breaking version of. Returns: The next breaking [`Version`][versions.version.Version] according to the `version`, or [`None`][None]. \"\"\" index = version . last_index if version . is_stable () and not version . is_post_release (): # the wildcard was used within the release segment if not index : return None index -= 1 return version . next_at ( index ) # this will take care of unstable releases matches_caret ( version , against ) Checks if the version matches the caret ( ^ ) specification. This is functionally the same as: against <= version < next_caret_breaking ( against ) Parameters: Name Type Description Default version Version The version to check. required against Version The version to check version against. required Returns: Type Description bool Whether the version matches against . Source code in versions/operators.py 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 def matches_caret ( version : Version , against : Version ) -> bool : \"\"\"Checks if the `version` matches the *caret* (`^`) specification. This is functionally the same as: ```python against <= version < next_caret_breaking(against) ``` Arguments: version: The version to check. against: The version to check `version` against. Returns: Whether the `version` matches `against`. \"\"\" return against <= version < next_caret_breaking ( against ) matches_tilde_equal ( version , against ) Checks if the version matches the tilde-equal ( ~= ) specification. This is functionally the same as: against <= version < next_tilde_equal_breaking ( against ) Parameters: Name Type Description Default version Version The version to check. required against Version The version to check version against. required Returns: Type Description bool Whether the version matches against . Source code in versions/operators.py 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 def matches_tilde_equal ( version : Version , against : Version ) -> bool : \"\"\"Checks if the `version` matches the *tilde-equal* (`~=`) specification. This is functionally the same as: ```python against <= version < next_tilde_equal_breaking(against) ``` Arguments: version: The version to check. against: The version to check `version` against. Returns: Whether the `version` matches `against`. \"\"\" return against <= version < next_tilde_equal_breaking ( against ) matches_tilde ( version , against ) Checks if the version matches the tilde ( ~ ) specification. This is functionally the same as: against <= version < next_tilde_breaking ( against ) Parameters: Name Type Description Default version Version The version to check. required against Version The version to check version against. required Returns: Type Description bool Whether the version matches against . Source code in versions/operators.py 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 def matches_tilde ( version : Version , against : Version ) -> bool : \"\"\"Checks if the `version` matches the *tilde* (`~`) specification. This is functionally the same as: ```python against <= version < next_tilde_breaking(against) ``` Arguments: version: The version to check. against: The version to check `version` against. Returns: Whether the `version` matches `against`. \"\"\" return against <= version < next_tilde_breaking ( against ) matches_equal ( version , against ) Checks if the version matches the equal ( == ) specification. This is functionally the same as: version == against Parameters: Name Type Description Default version Version The version to check. required against Version The version to check version against. required Returns: Type Description bool Whether the version matches against . Source code in versions/operators.py 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 def matches_equal ( version : Version , against : Version ) -> bool : \"\"\"Checks if the `version` matches the *equal* (`==`) specification. This is functionally the same as: ```python version == against ``` Arguments: version: The version to check. against: The version to check `version` against. Returns: Whether the `version` matches `against`. \"\"\" return version == against matches_not_equal ( version , against ) Checks if the version matches the not-equal ( != ) specification. This is functionally the same as: version != against Parameters: Name Type Description Default version Version The version to check. required against Version The version to check version against. required Returns: Type Description bool Whether the version matches against . Source code in versions/operators.py 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 def matches_not_equal ( version : Version , against : Version ) -> bool : \"\"\"Checks if the `version` matches the *not-equal* (`!=`) specification. This is functionally the same as: ```python version != against ``` Arguments: version: The version to check. against: The version to check `version` against. Returns: Whether the `version` matches `against`. \"\"\" return version != against matches_less ( version , against ) Checks if the version matches the less ( < ) specification. This is functionally the same as: version < against Parameters: Name Type Description Default version Version The version to check. required against Version The version to check version against. required Returns: Type Description bool Whether the version matches against . Source code in versions/operators.py 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 def matches_less ( version : Version , against : Version ) -> bool : \"\"\"Checks if the `version` matches the *less* (`<`) specification. This is functionally the same as: ```python version < against ``` Arguments: version: The version to check. against: The version to check `version` against. Returns: Whether the `version` matches `against`. \"\"\" return version < against matches_less_or_equal ( version , against ) Checks if the version matches the less-or-equal ( <= ) specification. This is functionally the same as: version <= against Parameters: Name Type Description Default version Version The version to check. required against Version The version to check version against. required Returns: Type Description bool Whether the version matches against . Source code in versions/operators.py 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 def matches_less_or_equal ( version : Version , against : Version ) -> bool : \"\"\"Checks if the `version` matches the *less-or-equal* (`<=`) specification. This is functionally the same as: ```python version <= against ``` Arguments: version: The version to check. against: The version to check `version` against. Returns: Whether the `version` matches `against`. \"\"\" return version <= against matches_greater ( version , against ) Checks if the version matches the greater ( > ) specification. This is functionally the same as: version > against Parameters: Name Type Description Default version Version The version to check. required against Version The version to check version against. required Returns: Type Description bool Whether the version matches against . Source code in versions/operators.py 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 def matches_greater ( version : Version , against : Version ) -> bool : \"\"\"Checks if the `version` matches the *greater* (`>`) specification. This is functionally the same as: ```python version > against ``` Arguments: version: The version to check. against: The version to check `version` against. Returns: Whether the `version` matches `against`. \"\"\" return version > against matches_greater_or_equal ( version , against ) Checks if the version matches the greater-or-equal ( >= ) specification. This is functionally the same as: version >= against Parameters: Name Type Description Default version Version The version to check. required against Version The version to check version against. required Returns: Type Description bool Whether the version matches against . Source code in versions/operators.py 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 def matches_greater_or_equal ( version : Version , against : Version ) -> bool : \"\"\"Checks if the `version` matches the *greater-or-equal* (`>=`) specification. This is functionally the same as: ```python version >= against ``` Arguments: version: The version to check. against: The version to check `version` against. Returns: Whether the `version` matches `against`. \"\"\" return version >= against matches_wildcard_equal ( version , against ) Checks if the version matches the wildcard-equal ( == * ) specification. This is functionally the same as: wildcard = next_wildcard_breaking ( against ) wildcard is None or against <= version < wildcard Parameters: Name Type Description Default version Version The version to check. required against Version The version to check version against. required Returns: Type Description bool Whether the version matches against . Source code in versions/operators.py 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 def matches_wildcard_equal ( version : Version , against : Version ) -> bool : \"\"\"Checks if the `version` matches the *wildcard-equal* (`== *`) specification. This is functionally the same as: ```python wildcard = next_wildcard_breaking(against) wildcard is None or against <= version < wildcard ``` Arguments: version: The version to check. against: The version to check `version` against. Returns: Whether the `version` matches `against`. \"\"\" wildcard = next_wildcard_breaking ( against ) if wildcard is None : return True return against <= version < wildcard matches_wildcard_not_equal ( version , against ) Checks if the version matches the wildcard-not-equal ( != * ) specification. This is functionally the same as: wildcard = next_wildcard_breaking ( against ) wildcard is not None and ( version < against or version >= wildcard ) Parameters: Name Type Description Default version Version The version to check. required against Version The version to check version against. required Returns: Type Description bool Whether the version matches against . Source code in versions/operators.py 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 def matches_wildcard_not_equal ( version : Version , against : Version ) -> bool : \"\"\"Checks if the `version` matches the *wildcard-not-equal* (`!= *`) specification. This is functionally the same as: ```python wildcard = next_wildcard_breaking(against) wildcard is not None and (version < against or version >= wildcard) ``` Arguments: version: The version to check. against: The version to check `version` against. Returns: Whether the `version` matches `against`. \"\"\" return not matches_wildcard_equal ( version , against ) translate_caret ( version ) Translate the version into a version set according to the caret ( ^ ) strategy. This function returns the [version, next_caret_breaking(version)) range. Parameters: Name Type Description Default version Version The version to translate. required Returns: Type Description VersionRange The version set representing the caret specification. Source code in versions/operators.py 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 def translate_caret ( version : Version ) -> VersionRange : \"\"\"Translate the `version` into a version set according to the *caret* (`^`) strategy. This function returns the `[version, next_caret_breaking(version))` range. Arguments: version: The version to translate. Returns: The version set representing the *caret* specification. \"\"\" return VersionRange ( min = version , max = next_caret_breaking ( version ), include_min = True , include_max = False , ) translate_tilde_equal ( version ) Translate the version into a version set according to the tilde-equal ( ~= ) strategy. This function returns the [version, next_tilde_equal_breaking(version)) range. Parameters: Name Type Description Default version Version The version to translate. required Returns: Type Description VersionRange The version set representing the tilde-equal specification. Source code in versions/operators.py 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 def translate_tilde_equal ( version : Version ) -> VersionRange : \"\"\"Translate the `version` into a version set according to the *tilde-equal* (`~=`) strategy. This function returns the `[version, next_tilde_equal_breaking(version))` range. Arguments: version: The version to translate. Returns: The version set representing the *tilde-equal* specification. \"\"\" return VersionRange ( min = version , max = next_tilde_equal_breaking ( version ), include_min = True , include_max = False , ) translate_tilde ( version ) Translate the version into a version set according to the tilde ( ~ ) strategy. This function returns the [version, next_tilde_breaking(version)) range. Parameters: Name Type Description Default version Version The version to translate. required Returns: Type Description VersionRange The version set representing the tilde-equal specification. Source code in versions/operators.py 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 def translate_tilde ( version : Version ) -> VersionRange : \"\"\"Translate the `version` into a version set according to the *tilde* (`~`) strategy. This function returns the `[version, next_tilde_breaking(version))` range. Arguments: version: The version to translate. Returns: The version set representing the *tilde-equal* specification. \"\"\" return VersionRange ( min = version , max = next_tilde_breaking ( version ), include_min = True , include_max = False , ) translate_equal ( version ) Translate the version into a version set according to the equal ( == ) strategy. This function returns the [version, version] range (aka version point). Parameters: Name Type Description Default version Version The version to translate. required Returns: Type Description VersionPoint The version set representing the equal specification. Source code in versions/operators.py 514 515 516 517 518 519 520 521 522 523 524 525 def translate_equal ( version : Version ) -> VersionPoint : \"\"\"Translate the `version` into a version set according to the *equal* (`==`) strategy. This function returns the `[version, version]` range (aka `version` point). Arguments: version: The version to translate. Returns: The version set representing the *equal* specification. \"\"\" return VersionPoint ( version ) translate_not_equal ( version ) Translate the version into a version set according to the not-equal ( != ) strategy. This function returns the (e, version) | (version, w) union. Parameters: Name Type Description Default version Version The version to translate. required Returns: Type Description VersionUnion The version set representing the not-equal specification. Source code in versions/operators.py 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 def translate_not_equal ( version : Version ) -> VersionUnion : \"\"\"Translate the `version` into a version set according to the *not-equal* (`!=`) strategy. This function returns the `(e, version) | (version, w)` union. Arguments: version: The version to translate. Returns: The version set representing the *not-equal* specification. \"\"\" result = translate_equal ( version ) . complement () if is_version_union ( result ): return result raise InternalError # TODO: message? translate_less ( version ) Translate the version into a version set according to the less ( < ) strategy. This function returns the (e, version) range. Parameters: Name Type Description Default version Version The version to translate. required Returns: Type Description VersionRange The version set representing the less specification. Source code in versions/operators.py 547 548 549 550 551 552 553 554 555 556 557 558 def translate_less ( version : Version ) -> VersionRange : \"\"\"Translate the `version` into a version set according to the *less* (`<`) strategy. This function returns the `(e, version)` range. Arguments: version: The version to translate. Returns: The version set representing the *less* specification. \"\"\" return VersionRange ( max = version , include_max = False ) translate_less_or_equal ( version ) Translate the version into a version set according to the less-or-equal ( <= ) strategy. This function returns the (e, version] range. Parameters: Name Type Description Default version Version The version to translate. required Returns: Type Description VersionRange The version set representing the less-or-equal specification. Source code in versions/operators.py 561 562 563 564 565 566 567 568 569 570 571 572 def translate_less_or_equal ( version : Version ) -> VersionRange : \"\"\"Translate the `version` into a version set according to the *less-or-equal* (`<=`) strategy. This function returns the `(e, version]` range. Arguments: version: The version to translate. Returns: The version set representing the *less-or-equal* specification. \"\"\" return VersionRange ( max = version , include_max = True ) translate_greater ( version ) Translate the version into a version set according to the greater ( > ) strategy. This function returns the (version, w) range. Parameters: Name Type Description Default version Version The version to translate. required Returns: Type Description VersionRange The version set representing the greater specification. Source code in versions/operators.py 575 576 577 578 579 580 581 582 583 584 585 586 def translate_greater ( version : Version ) -> VersionRange : \"\"\"Translate the `version` into a version set according to the *greater* (`>`) strategy. This function returns the `(version, w)` range. Arguments: version: The version to translate. Returns: The version set representing the *greater* specification. \"\"\" return VersionRange ( min = version , include_min = False ) translate_greater_or_equal ( version ) Translate the version into a version set according to the greater-or-equal ( >= ) strategy. This function returns the [version, w) range. Parameters: Name Type Description Default version Version The version to translate. required Returns: Type Description VersionRange The version set representing the greater-or-equal specification. Source code in versions/operators.py 589 590 591 592 593 594 595 596 597 598 599 600 601 def translate_greater_or_equal ( version : Version ) -> VersionRange : \"\"\"Translate the `version` into a version set according to the *greater-or-equal* (`>=`) strategy. This function returns the `[version, w)` range. Arguments: version: The version to translate. Returns: The version set representing the *greater-or-equal* specification. \"\"\" return VersionRange ( min = version , include_min = True ) translate_wildcard_equal ( version ) Translate the version into a version set according to the wildcard-equal ( == * ) strategy. This function returns the [version, next_wildcard_version(version)) range in most cases, except for when the version is * : then the (e, w) range is returned. Parameters: Name Type Description Default version Version The version to translate. required Returns: Type Description VersionRange The version set representing the wildcard-equal specification. Source code in versions/operators.py 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 def translate_wildcard_equal ( version : Version ) -> VersionRange : \"\"\"Translate the `version` into a version set according to the *wildcard-equal* (`== *`) strategy. This function returns the `[version, next_wildcard_version(version))` range in most cases, except for when the version is `*`: then the `(e, w)` range is returned. Arguments: version: The version to translate. Returns: The version set representing the *wildcard-equal* specification. \"\"\" wildcard = next_wildcard_breaking ( version ) if wildcard is None : return VersionRange () return VersionRange ( min = version , max = wildcard , include_min = True , include_max = False ) translate_wildcard_not_equal ( version ) Translate the version into a version set according to the wildcard-not-equal ( != * ) strategy. This function returns the (e, version) | (next_wildcard_breaking(version), w) union in most cases, except for when the version is * : then the {} empty set is returned. Parameters: Name Type Description Default version Version The version to translate. required Returns: Type Description Union [ VersionEmpty , VersionUnion ] The version set representing the wildcard-not-equal specification. Source code in versions/operators.py 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 def translate_wildcard_not_equal ( version : Version ) -> Union [ VersionEmpty , VersionUnion ]: \"\"\"Translate the `version` into a version set according to the *wildcard-not-equal* (`!= *`) strategy. This function returns the `(e, version) | (next_wildcard_breaking(version), w)` union in most cases, except for when the version is `*`: then the `{}` empty set is returned. Arguments: version: The version to translate. Returns: The version set representing the *wildcard-not-equal* specification. \"\"\" result = translate_wildcard_equal ( version ) . complement () if is_version_empty ( result ) or is_version_union ( result ): return result raise InternalError # TODO: message? ParseError Bases: ValueError Parsing has failed. Source code in versions/errors.py 10 11 class ParseError ( ValueError ): \"\"\"Parsing has failed.\"\"\" ParseSpecificationError Bases: ParseError Parsing a specification has failed. Source code in versions/errors.py 14 15 class ParseSpecificationError ( ParseError ): \"\"\"Parsing a specification has failed.\"\"\" ParseTagError Bases: ParseError Parsing a version tag has failed. Source code in versions/errors.py 18 19 class ParseTagError ( ParseError ): \"\"\"Parsing a version tag has failed.\"\"\" ParseVersionError Bases: ParseError Parsing a version has failed. Source code in versions/errors.py 22 23 class ParseVersionError ( ParseError ): \"\"\"Parsing a version has failed.\"\"\" InternalError Bases: RuntimeError An internal error has occured. Source code in versions/errors.py 26 27 class InternalError ( RuntimeError ): \"\"\"An internal error has occured.\"\"\"","title":"Reference"},{"location":"reference/#reference","text":"Parsing, inspecting and specifying versions.","title":"Reference"},{"location":"reference/#versions--example","text":">>> from versions import parse_version , parse_version_set >>> version = parse_version ( \"1.0.0\" ) >>> version < Version ( 1.0.0 ) > >>> version_set = parse_version_set ( \"^1.0.0\" ) >>> version_set < VersionRange ( >= 1.0.0 , < 2.0.0 ) > >>> version . matches ( version_set ) True","title":"Example"},{"location":"reference/#versions.functions.parse_version","text":"Parses a string into a version of version_type . Parameters: Name Type Description Default string str The string to parse. required version_type Type [ Version ] The version type to use in conversion. Version Returns: Type Description Version A newly parsed Version . Source code in versions/functions.py 27 28 29 30 31 32 33 34 35 36 37 def parse_version ( string : str , version_type : Type [ Version ] = Version ) -> Version : \"\"\"Parses a `string` into a version of `version_type`. Arguments: string: The string to parse. version_type: The version type to use in conversion. Returns: A newly parsed [`Version`][versions.version.Version]. \"\"\" return VersionParser ( version_type ) . parse ( string )","title":"parse_version()"},{"location":"reference/#versions.functions.parse_specifier","text":"Parses a string into a version specifier with versions of version_type . Parameters: Name Type Description Default string str The string to parse. required version_type Type [ Version ] The version type to use in conversion. Version Returns: Type Description Specifier A newly parsed Specifier . Source code in versions/functions.py 40 41 42 43 44 45 46 47 48 49 50 def parse_specifier ( string : str , version_type : Type [ Version ] = Version ) -> Specifier : \"\"\"Parses a `string` into a version specifier with versions of `version_type`. Arguments: string: The string to parse. version_type: The version type to use in conversion. Returns: A newly parsed [`Specifier`][versions.specifiers.Specifier]. \"\"\" return SpecifierParser ( VersionParser ( version_type )) . parse ( string )","title":"parse_specifier()"},{"location":"reference/#versions.functions.parse_version_set","text":"Parses a string into a version set with versions of version_type . Parameters: Name Type Description Default string str The string to parse. required version_type Type [ Version ] The version type to use in conversion. Version Returns: Type Description VersionSet A newly parsed Specifier . Source code in versions/functions.py 53 54 55 56 57 58 59 60 61 62 63 def parse_version_set ( string : str , version_type : Type [ Version ] = Version ) -> VersionSet : \"\"\"Parses a `string` into a version set with versions of `version_type`. Arguments: string: The string to parse. version_type: The version type to use in conversion. Returns: A newly parsed [`Specifier`][versions.specifiers.Specifier]. \"\"\" return VersionSetParser ( SpecifierParser ( VersionParser ( version_type ))) . parse ( string )","title":"parse_version_set()"},{"location":"reference/#versions.version.Version","text":"Bases: Representation , FromString , ToString Represents versions. Source code in versions/version.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 @frozen ( repr = False , eq = True , order = True ) class Version ( Representation , FromString , ToString ): \"\"\"Represents versions.\"\"\" epoch : Epoch = field ( factory = Epoch , eq = False , order = False ) release : Release = field ( factory = Release , eq = False , order = False ) pre : Optional [ PreTag ] = field ( default = None , eq = False , order = False ) post : Optional [ PostTag ] = field ( default = None , eq = False , order = False ) dev : Optional [ DevTag ] = field ( default = None , eq = False , order = False ) local : Optional [ Local ] = field ( default = None , eq = False , order = False ) compare_key : CompareKey = field ( repr = False , init = False , eq = True , order = True ) def __attrs_post_init__ ( self ) -> None : evolve_in_place ( self , compare_key = self . compute_compare_key ()) @staticmethod def compute_compare_tags ( pre : Optional [ PreTag ], post : Optional [ PostTag ], dev : Optional [ DevTag ] ) -> Tuple [ ComparePreTag , ComparePostTag , CompareDevTag ]: compare_pre : ComparePreTag compare_post : ComparePostTag compare_dev : CompareDevTag if pre is None : if post is None and dev is not None : compare_pre = negative_infinity else : compare_pre = infinity else : compare_pre = pre compare_post = negative_infinity if post is None else post compare_dev = infinity if dev is None else dev return ( compare_pre , compare_post , compare_dev ) @staticmethod def compute_compare_local ( local : Optional [ Local ]) -> CompareLocal : return negative_infinity if local is None else local def compute_compare_key ( self ) -> CompareKey : compare_epoch = self . epoch compare_release = self . release compare_pre , compare_post , compare_dev = self . compute_compare_tags ( self . pre , self . post , self . dev ) compare_local = self . compute_compare_local ( self . local ) return ( compare_epoch , compare_release , compare_pre , compare_post , compare_dev , compare_local , ) def to_string_iterator ( self ) -> Iterator [ str ]: epoch = self . epoch if epoch : yield epoch . to_string () yield EXCLAMATION yield self . release . to_string () pre = self . pre if pre : yield DASH yield pre . to_string () post = self . post if post : yield DASH yield post . to_string () dev = self . dev if dev : yield DASH yield dev . to_string () local = self . local if local : yield PLUS yield local . to_string () def to_short_string_iterator ( self ) -> Iterator [ str ]: epoch = self . epoch if epoch : yield epoch . to_short_string () yield EXCLAMATION yield self . release . to_short_string () pre = self . pre if pre : yield pre . to_short_string () post = self . post if post : yield DOT yield post . to_short_string () dev = self . dev if dev : yield DOT yield dev . to_short_string () local = self . local if local : yield PLUS yield local . to_short_string () def to_string ( self ) -> str : return concat_empty ( self . to_string_iterator ()) def to_short_string ( self ) -> str : return concat_empty ( self . to_short_string_iterator ()) @classmethod def from_string ( cls : Type [ V ], string : str ) -> V : return VersionParser ( cls ) . parse ( string ) @property def precision ( self ) -> int : return self . release . precision @property def last_index ( self ) -> int : return self . release . last_index @property def major ( self ) -> int : return self . release . major @property def minor ( self ) -> int : return self . release . minor @property def micro ( self ) -> int : return self . release . micro @property def patch ( self ) -> int : return self . release . patch @property def extra ( self ) -> Extra : return self . release . extra def get_major ( self ) -> int : return self . release . get_major () def get_minor ( self ) -> int : return self . release . get_minor () def get_micro ( self ) -> int : return self . release . get_micro () def get_patch ( self ) -> int : return self . release . get_patch () def get_extra ( self ) -> Extra : return self . release . get_extra () def get_at ( self , index : int , default : int = DEFAULT_VALUE ) -> int : return self . release . get_at ( index , default ) def get_at_unchecked ( self , index : int ) -> int : return self . release . get_at_unchecked ( index ) def is_semantic ( self ) -> bool : return self . release . is_semantic () def to_semantic ( self : V ) -> V : return self . update ( release = self . release . to_semantic ()) def set_major ( self : V , value : int ) -> V : return self . update ( release = self . release . set_major ( value )) def set_minor ( self : V , value : int ) -> V : return self . update ( release = self . release . set_minor ( value )) def set_micro ( self : V , value : int ) -> V : return self . update ( release = self . release . set_micro ( value )) def set_patch ( self : V , value : int ) -> V : return self . update ( release = self . release . set_patch ( value )) def set_at ( self : V , index : int , value : int ) -> V : return self . update ( release = self . release . set_at ( index , value )) def set_at_unchecked ( self : V , index : int , value : int ) -> V : return self . update ( release = self . release . set_at_unchecked ( index , value )) def next_major ( self : V ) -> V : release = self . release if self . is_stable (): release = release . next_major () return self . create ( self . epoch , release ) def next_minor ( self : V ) -> V : release = self . release if self . is_stable (): release = release . next_minor () return self . create ( self . epoch , release ) def next_micro ( self : V ) -> V : release = self . release if self . is_stable (): release = release . next_micro () return self . create ( self . epoch , release ) def next_patch ( self : V ) -> V : release = self . release if self . is_stable (): release = release . next_patch () return self . create ( self . epoch , release ) def next_at ( self : V , index : int ) -> V : release = self . release if self . is_stable (): release = release . next_at ( index ) return self . create ( self . epoch , release ) def has_major ( self ) -> bool : return self . release . has_major () def has_minor ( self ) -> bool : return self . release . has_minor () def has_micro ( self ) -> bool : return self . release . has_micro () def has_patch ( self ) -> bool : return self . release . has_patch () def has_extra ( self ) -> bool : return self . release . has_extra () def has_at ( self , index : int ) -> bool : return self . has_at ( index ) def pad_to ( self : V , length : int , padding : int = DEFAULT_PADDING ) -> V : return evolve ( self , release = self . release . pad_to ( length , padding )) def pad_to_index ( self : V , index : int , padding : int = DEFAULT_PADDING ) -> V : return evolve ( self , release = self . release . pad_to_index ( index , padding )) def pad_to_next ( self : V , padding : int = DEFAULT_PADDING ) -> V : return evolve ( self , release = self . release . pad_to_next ( padding )) def is_pre_release ( self ) -> bool : return self . pre is not None def is_post_release ( self ) -> bool : return self . post is not None def is_dev_release ( self ) -> bool : return self . dev is not None def is_local ( self ) -> bool : return self . local is not None def is_not_pre_release ( self ) -> bool : return self . pre is None def is_not_post_release ( self ) -> bool : return self . post is None def is_not_dev_release ( self ) -> bool : return self . dev is None def is_not_local ( self ) -> bool : return self . local is None def is_unstable ( self ) -> bool : return self . is_pre_release () or self . is_dev_release () def is_stable ( self ) -> bool : return self . is_not_pre_release () and self . is_not_dev_release () def next_pre ( self : V ) -> V : pre = self . pre if pre is None : pre = PreTag () else : pre = pre . next () return self . create ( self . epoch , self . release , pre ) def next_pre_phase ( self : V ) -> Optional [ V ]: pre = self . pre if pre is None : pre = PreTag () else : pre = pre . next_phase () if pre is None : return None return self . create ( self . epoch , self . release , pre ) def next_post ( self : V ) -> V : post = self . post if post is None : post = PostTag () else : post = post . next () return self . create ( self . epoch , self . release , self . pre , post , self . dev ) def next_dev ( self : V ) -> V : dev = self . dev if dev is None : dev = DevTag () else : dev = dev . next () return self . create ( self . epoch , self . release , self . pre , self . post , dev ) def with_pre ( self : V , pre : PreTag ) -> V : return self . update ( pre = pre ) def with_post ( self : V , post : PostTag ) -> V : return self . update ( post = post ) def with_dev ( self : V , dev : DevTag ) -> V : return self . update ( dev = dev ) def with_local ( self : V , local : Local ) -> V : return self . update ( local = local ) def without_pre ( self : V ) -> V : return self . update ( pre = None ) def without_post ( self : V ) -> V : return self . update ( post = None ) def without_dev ( self : V ) -> V : return self . update ( dev = None ) def without_local ( self : V ) -> V : return self . update ( local = None ) def update ( self : V , ** changes : Any ) -> V : return evolve ( self , ** changes ) def weaken ( self , other : W ) -> W : if not self . is_local () and other . is_local (): other = other . without_local () if not self . is_post_release () and other . is_post_release (): other = other . without_post () return other def to_stable ( self : V ) -> V : return self if self . is_stable () else self . create ( self . epoch , self . release ) def next_breaking ( self : V ) -> V : \"\"\"Returns the next breaking version. This function is slightly convoluted due to how `0.x.y` versions are handled: | version | next breaking | |---------|---------------| | `1.2.3` | `2.0.0` | | `1.2.0` | `2.0.0` | | `1.0.0` | `2.0.0` | | `0.2.3` | `0.3.0` | | `0.0.3` | `0.0.4` | | `0.0.0` | `0.0.1` | | `0.0` | `0.1.0` | | `0` | `1.0.0` | Returns: The next breaking [`Version`][versions.version.Version]. \"\"\" if not self . major : if self . minor : return self . next_minor () if self . has_micro (): return self . next_micro () if self . has_minor (): return self . next_minor () return self . next_major () return self . to_stable () . next_major () def normalize ( self : V ) -> V : pre = self . pre if pre : pre = pre . normalize () post = self . post if post : post = post . normalize () dev = self . dev if dev : dev = dev . normalize () return self . update ( pre = pre , post = post , dev = dev ) @classmethod def create ( cls : Type [ V ], epoch : Optional [ Epoch ] = None , release : Optional [ Release ] = None , pre : Optional [ PreTag ] = None , post : Optional [ PostTag ] = None , dev : Optional [ DevTag ] = None , local : Optional [ Local ] = None , ) -> V : if epoch is None : epoch = Epoch () if release is None : release = Release () return cls ( epoch , release , pre , post , dev , local ) @classmethod def from_parts ( cls : Type [ V ], major : int = DEFAULT_VALUE , minor : int = DEFAULT_VALUE , micro : int = DEFAULT_VALUE , * extra : int , epoch : Optional [ Epoch ] = None , pre : Optional [ PreTag ] = None , post : Optional [ PostTag ] = None , dev : Optional [ DevTag ] = None , local : Optional [ Local ] = None , ) -> V : release = Release . from_parts ( major , minor , micro , * extra ) return cls . create ( epoch , release , pre , post , dev , local ) def matches ( self , specification : Specification ) -> bool : return specification . accepts ( self )","title":"Version"},{"location":"reference/#versions.version.Version.next_breaking","text":"Returns the next breaking version. This function is slightly convoluted due to how 0.x.y versions are handled: version next breaking 1.2.3 2.0.0 1.2.0 2.0.0 1.0.0 2.0.0 0.2.3 0.3.0 0.0.3 0.0.4 0.0.0 0.0.1 0.0 0.1.0 0 1.0.0 Returns: Type Description V The next breaking Version . Source code in versions/version.py 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 def next_breaking ( self : V ) -> V : \"\"\"Returns the next breaking version. This function is slightly convoluted due to how `0.x.y` versions are handled: | version | next breaking | |---------|---------------| | `1.2.3` | `2.0.0` | | `1.2.0` | `2.0.0` | | `1.0.0` | `2.0.0` | | `0.2.3` | `0.3.0` | | `0.0.3` | `0.0.4` | | `0.0.0` | `0.0.1` | | `0.0` | `0.1.0` | | `0` | `1.0.0` | Returns: The next breaking [`Version`][versions.version.Version]. \"\"\" if not self . major : if self . minor : return self . next_minor () if self . has_micro (): return self . next_micro () if self . has_minor (): return self . next_minor () return self . next_major () return self . to_stable () . next_major ()","title":"next_breaking()"},{"location":"reference/#versions.segments.Epoch","text":"Bases: Representation , FromString , ToString Represents the epoch part of the version ( e! ). Source code in versions/segments.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 @frozen ( repr = False , eq = True , order = True ) class Epoch ( Representation , FromString , ToString ): \"\"\"Represents the epoch part of the version (`e!`).\"\"\" value : int = field ( default = DEFAULT_VALUE ) def __bool__ ( self ) -> bool : return bool ( self . value ) @classmethod def create ( cls : Type [ E ], value : int = DEFAULT_VALUE ) -> E : return cls ( value ) @classmethod def from_string ( cls : Type [ E ], string : str ) -> E : return cls ( int ( string )) def to_string ( self ) -> str : return str ( self . value )","title":"Epoch"},{"location":"reference/#versions.segments.Release","text":"Bases: Representation , FromString , ToString Represents the release part of the version ( x.y.z ). Source code in versions/segments.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 @frozen ( repr = False , eq = True , order = True ) class Release ( Representation , FromString , ToString ): \"\"\"Represents the release part of the version (`x.y.z`).\"\"\" parts : Parts = field ( default = DEFAULT_PARTS , eq = False , order = False ) compare_parts : Parts = field ( repr = False , init = False , eq = True , order = True ) @parts . validator def check_parts ( self , attribute : Attribute [ Parts ], value : Parts ) -> None : if not value : raise ValueError ( EMPTY_RELEASE ) def __attrs_post_init__ ( self ) -> None : evolve_in_place ( self , compare_parts = self . compute_compare_parts ()) def compute_compare_parts ( self ) -> Parts : parts = self . parts index = count_leading_zeros ( reversed ( parts )) if index == self . precision : index -= 1 return self . slice_parts ( - index ) if index else parts @classmethod def create ( cls : Type [ R ], parts : Parts = DEFAULT_PARTS ) -> R : return cls ( parts ) @classmethod def from_iterable ( cls : Type [ R ], iterable : Iterable [ int ]) -> R : return cls ( tuple ( iterable )) @classmethod def from_parts ( cls : Type [ R ], * parts : int ) -> R : return cls ( parts ) def into_parts ( self ) -> Parts : return self . parts @property def precision ( self ) -> int : return len ( self . parts ) @property def last_index ( self ) -> int : return self . precision - 1 def get_major ( self ) -> int : return self . get_at ( MAJOR ) def get_minor ( self ) -> int : return self . get_at ( MINOR ) def get_micro ( self ) -> int : return self . get_at ( MICRO ) def get_patch ( self ) -> int : return self . get_at ( PATCH ) def get_extra ( self ) -> Extra : return self . parts [ TOTAL :] @property def extra ( self ) -> Extra : ... extra = property ( get_extra ) # type: ignore def get_at ( self , index : int , default : int = DEFAULT_VALUE ) -> int : return self . get_at_unchecked ( index ) if self . has_at ( index ) else default def get_at_unchecked ( self , index : int ) -> int : return self . parts [ index ] def is_semantic ( self ) -> bool : return self . precision == TOTAL def to_semantic ( self : R ) -> R : if self . has_extra (): return self . next_patch () . slice ( TOTAL ) return self if self . is_semantic () else self . pad_to ( TOTAL ) def set_major ( self : R , value : int ) -> R : return self . set_at ( MAJOR , value ) def set_minor ( self : R , value : int ) -> R : return self . set_at ( MINOR , value ) def set_micro ( self : R , value : int ) -> R : return self . set_at ( MICRO , value ) def set_patch ( self : R , value : int ) -> R : return self . set_at ( PATCH , value ) @property def major ( self ) -> int : ... @property def minor ( self ) -> int : ... @property def micro ( self ) -> int : ... @property def patch ( self ) -> int : ... major = property ( get_major , set_major ) # type: ignore minor = property ( get_minor , set_minor ) # type: ignore micro = property ( get_micro , set_micro ) # type: ignore patch = property ( get_patch , set_patch ) # type: ignore def set_at ( self : R , index : int , value : int ) -> R : return self . pad_to_index ( index ) . set_at_unchecked ( index , value ) def set_at_unchecked ( self : R , index : int , value : int ) -> R : mutable = list ( self . parts ) mutable [ index ] = value return self . from_iterable ( mutable ) def next_major ( self : R ) -> R : return self . next_at ( MAJOR ) def next_minor ( self : R ) -> R : return self . next_at ( MINOR ) def next_micro ( self : R ) -> R : return self . next_at ( MICRO ) def next_patch ( self : R ) -> R : return self . next_at ( PATCH ) def next_at ( self : R , index : int ) -> R : updated = self . set_at ( index , self . get_at ( index ) + 1 ) return updated . slice ( index + 1 ) . pad_to ( updated . precision ) def has_major ( self ) -> bool : return self . has_at ( MAJOR ) def has_minor ( self ) -> bool : return self . has_at ( MINOR ) def has_micro ( self ) -> bool : return self . has_at ( MICRO ) def has_patch ( self ) -> bool : return self . has_at ( PATCH ) def has_extra ( self ) -> bool : return self . has_at ( TOTAL ) def has_at ( self , index : int ) -> bool : return self . precision > index def pad_to ( self : R , length : int , padding : int = DEFAULT_PADDING ) -> R : if self . precision < length : return self . from_iterable ( pad_to_length ( length , padding , self . parts )) return self def pad_to_index ( self : R , index : int , padding : int = DEFAULT_PADDING ) -> R : return self . pad_to ( index + 1 , padding ) def pad_to_next ( self : R , padding : int = DEFAULT_PADDING ) -> R : return self . pad_to ( self . precision + 1 , padding ) def slice ( self : R , stop : int ) -> R : return self . create ( self . slice_parts ( stop )) def slice_parts ( self , stop : int ) -> Parts : return self . parts [: stop ] @classmethod def from_string ( cls : Type [ R ], string : str ) -> R : return cls . from_iterable ( map ( int , split_dot ( string ))) def to_string ( self ) -> str : return concat_dot ( map ( str , self . parts ))","title":"Release"},{"location":"reference/#versions.segments.Tag","text":"Bases: Representation , FromString , ToString Represents various tag parts of the version ( tag.n ). Source code in versions/segments.py 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 @frozen ( repr = False , eq = True , order = True ) class Tag ( Representation , FromString , ToString ): \"\"\"Represents various tag parts of the version (`tag.n`).\"\"\" DEFAULT_PHASE : ClassVar [ str ] = PHASE_ALL_DEFAULT PHASE_SET : ClassVar [ Set [ str ]] = PHASE_ALL_SET phase : str = field ( converter = case_fold ) # type: ignore value : int = field ( default = DEFAULT_VALUE ) @phase . default def default_phase ( self ) -> str : return self . DEFAULT_PHASE @phase . validator def check_phase ( self , attribute : Attribute [ str ], value : str ) -> None : if value not in self . PHASE_SET : raise ValueError ( PHASE_NOT_ALLOWED . format ( value , get_name ( type ( self )))) def __attrs_post_init__ ( self ) -> None : evolve_in_place ( self , phase = self . expand ( self . phase )) @staticmethod def expand ( phase : str ) -> str : return SHORT_TO_PHASE . get ( phase , phase ) @staticmethod def reduce ( phase : str ) -> str : return PHASE_TO_SHORT . get ( phase , phase ) @staticmethod def normalize_phase ( phase : str ) -> str : return PHASE_TO_NORMAL . get ( phase , phase ) @classmethod def create ( cls : Type [ T ], phase : Optional [ str ] = None , value : int = DEFAULT_VALUE ) -> T : if phase is None : phase = cls . DEFAULT_PHASE return cls ( phase , value ) @classmethod def default_with_value ( cls : Type [ T ], value : int ) -> T : # TODO: change the name? return cls ( value = value ) @property def short ( self ) -> str : return self . reduce ( self . phase ) @property def normal ( self ) -> str : return self . normalize_phase ( self . phase ) def normalize ( self : T ) -> T : return evolve ( self , phase = self . normal ) def next ( self : T ) -> T : return evolve ( self , value = self . value + 1 ) def next_phase ( self : T ) -> Optional [ T ]: phase = PHASE_TO_NEXT . get ( self . phase ) return None if phase is None else self . create ( phase ) @classmethod def from_string ( cls : Type [ T ], string : str ) -> T : return TagParser ( cls ) . parse ( string ) def to_string ( self ) -> str : return concat_dot_args ( self . phase , str ( self . value )) def to_short_string ( self ) -> str : return concat_empty_args ( self . short , str ( self . value ))","title":"Tag"},{"location":"reference/#versions.segments.PreTag","text":"Bases: Tag Represents the pre-release part of the version ( pre.n ). Source code in versions/segments.py 376 377 378 379 380 381 @frozen ( repr = False , eq = True , order = True ) class PreTag ( Tag ): \"\"\"Represents the pre-release part of the version (`pre.n`).\"\"\" DEFAULT_PHASE = PHASE_PRE_DEFAULT PHASE_SET = PHASE_PRE_SET","title":"PreTag"},{"location":"reference/#versions.segments.PostTag","text":"Bases: Tag Represents the post-release part of the version ( pre.n ). Source code in versions/segments.py 384 385 386 387 388 389 @frozen ( repr = False , eq = True , order = True ) class PostTag ( Tag ): \"\"\"Represents the post-release part of the version (`pre.n`).\"\"\" DEFAULT_PHASE = PHASE_POST_DEFAULT PHASE_SET = PHASE_POST_SET","title":"PostTag"},{"location":"reference/#versions.segments.DevTag","text":"Bases: Tag Represents the dev-release part of the version ( dev.n ). Source code in versions/segments.py 392 393 394 395 396 397 @frozen ( repr = False , eq = True , order = True ) class DevTag ( Tag ): \"\"\"Represents the dev-release part of the version (`dev.n`).\"\"\" DEFAULT_PHASE = PHASE_DEV_DEFAULT PHASE_SET = PHASE_DEV_SET","title":"DevTag"},{"location":"reference/#versions.segments.Local","text":"Bases: Representation , FromString , ToString Represents the local part of the version ( +abcdefg.n ) Source code in versions/segments.py 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 @frozen ( repr = False , eq = True , order = True ) class Local ( Representation , FromString , ToString ): \"\"\"Represents the local part of the version (`+abcdefg.n`)\"\"\" parts : LocalParts = field ( eq = False , order = False ) compare_parts : CompareLocalParts = field ( repr = False , init = False , eq = True , order = True ) @parts . validator def check_parts ( self , attribute : Attribute [ LocalParts ], value : LocalParts ) -> None : if not value : raise ValueError ( EMPTY_LOCAL ) def __attrs_post_init__ ( self ) -> None : evolve_in_place ( self , compare_parts = self . compute_compare_parts ()) def compute_compare_parts ( self ) -> CompareLocalParts : empty = EMPTY return tuple ( ( part , empty ) if is_int ( part ) else ( negative_infinity , part ) # type: ignore for part in self . parts ) @classmethod def create ( cls : Type [ L ], parts : LocalParts ) -> L : return cls ( parts ) @classmethod def from_iterable ( cls : Type [ L ], iterable : Iterable [ LocalPart ]) -> L : return cls ( tuple ( iterable )) @classmethod def from_parts ( cls : Type [ L ], * local_parts : LocalPart ) -> L : return cls ( local_parts ) def into_parts ( self ) -> LocalParts : return self . parts @classmethod def from_string ( cls : Type [ L ], string : str ) -> L : return cls . from_iterable ( map ( local_part , split_separators ( string ))) def to_string ( self ) -> str : return concat_dot ( map ( str , self . parts ))","title":"Local"},{"location":"reference/#versions.specification.Specification","text":"Bases: Protocol The specification protocol for specifying version requirements. Source code in versions/specification.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @runtime_checkable class Specification ( Protocol ): \"\"\"The specification protocol for specifying version requirements.\"\"\" @abstractmethod def accepts ( self , version : Version ) -> bool : \"\"\"Checks if the `version` matches the specification. Arguments: version: The version to check. Returns: Whether the `version` matches the specification. \"\"\" raise NotImplementedError","title":"Specification"},{"location":"reference/#versions.specification.Specification.accepts","text":"Checks if the version matches the specification. Parameters: Name Type Description Default version Version The version to check. required Returns: Type Description bool Whether the version matches the specification. Source code in versions/specification.py 18 19 20 21 22 23 24 25 26 27 28 @abstractmethod def accepts ( self , version : Version ) -> bool : \"\"\"Checks if the `version` matches the specification. Arguments: version: The version to check. Returns: Whether the `version` matches the specification. \"\"\" raise NotImplementedError","title":"accepts()"},{"location":"reference/#versions.version_sets.VersionSet","text":"The union of the following types: VersionEmpty VersionPoint VersionRange VersionUnion","title":"VersionSet"},{"location":"reference/#versions.version_sets.VersionEmpty","text":"Bases: Representation , ToString , VersionSetProtocol Represents version empty sets ( {} ). Source code in versions/version_sets.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 @frozen ( repr = False , order = False ) class VersionEmpty ( Representation , ToString , VersionSetProtocol ): \"\"\"Represents version empty sets (`{}`).\"\"\" def is_empty ( self ) -> Literal [ True ]: return True def is_universe ( self ) -> Literal [ False ]: return False def includes ( self , version_set : VersionSet ) -> bool : return version_set . is_empty () def intersects ( self , version_set : VersionSet ) -> Literal [ False ]: return False def contains ( self , version : Version ) -> Literal [ False ]: return False def intersection ( self : E , version_set : VersionSet ) -> E : return self def union ( self , version_set : S ) -> S : return version_set def difference ( self : E , version_set : VersionSet ) -> E : return self def symmetric_difference ( self , version_set : S ) -> S : return version_set def complement ( self ) -> VersionRange : return VersionRange () def to_string ( self ) -> str : return EMPTY_VERSION","title":"VersionEmpty"},{"location":"reference/#versions.version_sets.VersionRange","text":"Bases: Representation , ToString , VersionRangeProtocol , VersionSetProtocol Represents version ranges ( (x, y) , (x, y] , [x, y) and [x, y] ). Source code in versions/version_sets.py 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 @frozen ( repr = False , eq = False , order = False ) class VersionRange ( Representation , ToString , VersionRangeProtocol , VersionSetProtocol ): \"\"\"Represents version ranges (`(x, y)`, `(x, y]`, `[x, y)` and `[x, y]`).\"\"\" min : Optional [ Version ] = None max : Optional [ Version ] = None include_min : bool = False include_max : bool = False def __attrs_post_init__ ( self ) -> None : if self . min is None : evolve_in_place ( self , include_min = False ) if self . max is None : evolve_in_place ( self , include_max = False ) if self . comparable_min > self . comparable_max : raise ValueError # TODO: message? def is_empty ( self ) -> bool : return self . is_empty_or_point () and not self . is_closed () def is_point ( self ) -> bool : return self . is_empty_or_point () and self . is_closed () def is_universe ( self ) -> bool : return self . is_unbounded () @property def version ( self ) -> Version : version = self . min or self . max if version is None : raise ValueError # TODO: message? if self . is_point (): return version raise ValueError # TODO: message? def contains ( self , version : Version ) -> bool : comparable_min = self . comparable_min comparable_max = self . comparable_max # if is_not_infinity(comparable_max): # version = comparable_max.weaken(version) if version < comparable_min : return False if self . exclude_min and version == comparable_min : return False if version > comparable_max : return False if self . exclude_max and version == comparable_max : return False return True accepts = contains def includes ( self , version_set : VersionSet ) -> bool : if is_version_empty ( version_set ): return True if is_version_point ( version_set ): return self . contains ( version_set . version ) if is_version_range ( version_set ): return not version_set . is_lower ( self ) and not version_set . is_higher ( self ) if is_version_union ( version_set ): return all ( self . includes ( item ) for item in version_set . items ) raise TypeError # TODO: message? def intersects ( self , version_set : VersionSet ) -> bool : if is_version_empty ( version_set ): return False if is_version_point ( version_set ): return self . contains ( version_set . version ) if is_version_range ( version_set ): return self . intersects_range ( version_set ) if is_version_union ( version_set ): return any ( self . intersects ( item ) for item in version_set . items ) raise TypeError # TODO: message? def intersects_range ( self , range : VersionRange ) -> bool : return not range . is_strictly_lower ( self ) and not range . is_strictly_higher ( self ) def intersection ( self , version_set : VersionSet ) -> VersionSet : if is_version_empty ( version_set ): return VersionEmpty () if is_version_point ( version_set ): return version_set . intersection ( self ) if is_version_range ( version_set ): if self . is_lower ( version_set ): if self . is_strictly_lower ( version_set ): return VersionEmpty () intersection_min = version_set . min intersection_include_min = version_set . include_min else : if self . is_strictly_higher ( version_set ): return VersionEmpty () intersection_min = self . min intersection_include_min = self . include_min if self . is_higher ( version_set ): intersection_max = version_set . max intersection_include_max = version_set . include_max else : intersection_max = self . max intersection_include_max = self . include_max # if we reached here, there is an actual range intersection = VersionRange ( intersection_min , intersection_max , intersection_include_min , intersection_include_max , ) if intersection . is_point (): return VersionPoint ( intersection . version ) return intersection if is_version_union ( version_set ): return version_set . intersection ( self ) raise TypeError # TODO: message def union ( self , version_set : VersionSet ) -> VersionSet : if is_version_empty ( version_set ): return self if is_version_point ( version_set ): version = version_set . version if self . contains ( version ): return self if version == self . min : return evolve ( self , include_min = True ) if version == self . max : return evolve ( self , include_max = True ) return VersionUnion . of ( self , version_set ) if is_version_range ( version_set ): if not self . is_adjacent ( version_set ) and not self . intersects ( version_set ): return VersionUnion . of ( self , version_set ) if self . is_lower ( version_set ): union_min = self . min union_include_min = self . include_min else : union_min = version_set . min union_include_min = version_set . include_min if self . is_higher ( version_set ): union_max = self . max union_include_max = self . include_max else : union_max = version_set . max union_include_max = version_set . include_max return VersionRange ( union_min , union_max , union_include_min , union_include_max , ) if is_version_union ( version_set ): return version_set . union ( self ) raise TypeError # TODO: message def difference ( self , version_set : VersionSet ) -> VersionSet : if is_version_empty ( version_set ): return self if is_version_point ( version_set ): version = version_set . version if not self . contains ( version ): return self if version == self . min : if self . exclude_min : return self return evolve ( self , include_min = False ) if version == self . max : if self . exclude_max : return self return evolve ( self , include_max = False ) return VersionUnion . of ( evolve ( self , max = version , include_max = False ), evolve ( self , min = version , include_min = False ), ) if is_version_range ( version_set ): if not self . intersects ( version_set ): return self before : Optional [ VersionItem ] if not self . is_lower ( version_set ): before = None elif self . min == version_set . min : before = VersionPoint ( self . checked_min ) else : before = evolve ( self , max = version_set . min , include_max = version_set . exclude_min ) after : Optional [ VersionItem ] if not self . is_higher ( version_set ): after = None elif self . max == version_set . max : after = VersionPoint ( self . checked_max ) else : after = evolve ( self , min = version_set . max , include_min = version_set . exclude_max ) if before is None and after is None : return VersionEmpty () if before is None : return after # type: ignore if after is None : return before # type: ignore return VersionUnion . of ( before , after ) if is_version_union ( version_set ): return VersionUnion . of_iterable ( self . difference_iterator ( version_set )) raise TypeError # TODO: message? def difference_iterator ( self , version_union : VersionUnion ) -> Iterator [ VersionItem ]: current : VersionItem = self for item in version_union . items : if item . is_strictly_lower ( current ): continue if item . is_strictly_higher ( current ): break difference = current . difference ( item ) if is_version_union ( difference ): item , current = difference . items yield item if is_version_item ( difference ): current = difference yield current def complement ( self ) -> VersionSet : return VersionRange () . difference ( self ) def to_string_iterator ( self ) -> Iterator [ str ]: if self . is_empty (): yield EMPTY_VERSION return if self . is_point (): yield self . version . to_string () return if self . is_universe (): yield UNIVERSE_VERSION return min = self . min if min : min_type = OperatorType . GREATER_OR_EQUAL if self . include_min else OperatorType . GREATER min_operator = Operator ( min_type , min ) yield min_operator . to_string () max = self . max if max : max_type = OperatorType . LESS_OR_EQUAL if self . include_max else OperatorType . LESS max_operator = Operator ( max_type , max ) yield max_operator . to_string () def to_short_string_iterator ( self ) -> Iterator [ str ]: if self . is_empty (): yield EMPTY_VERSION return if self . is_point (): yield self . version . to_short_string () return if self . is_universe (): yield UNIVERSE_VERSION return min = self . min if min : min_type = OperatorType . GREATER_OR_EQUAL if self . include_min else OperatorType . GREATER min_operator = Operator ( min_type , min ) yield min_operator . to_short_string () max = self . max if max : max_type = OperatorType . LESS_OR_EQUAL if self . include_max else OperatorType . LESS max_operator = Operator ( max_type , max ) yield max_operator . to_short_string () def to_string ( self ) -> str : return concat_comma_space ( self . to_string_iterator ()) def to_short_string ( self ) -> str : return concat_comma ( self . to_short_string_iterator ())","title":"VersionRange"},{"location":"reference/#versions.version_sets.VersionPoint","text":"Bases: Representation , ToString , VersionRangeProtocol , VersionSetProtocol Represents version points ( [v, v] aka {v} ). Source code in versions/version_sets.py 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 @frozen ( repr = False , eq = False , order = False ) class VersionPoint ( Representation , ToString , VersionRangeProtocol , VersionSetProtocol ): \"\"\"Represents version points (`[v, v]` aka `{v}`).\"\"\" version : Version @property def min ( self ) -> Optional [ Version ]: # type: ignore return self . version @property def max ( self ) -> Optional [ Version ]: # type: ignore return self . version @property def include_min ( self ) -> bool : # type: ignore return True @property def include_max ( self ) -> bool : # type: ignore return True def is_empty ( self ) -> bool : return False def is_point ( self ) -> bool : return True def is_universe ( self ) -> bool : return False def contains ( self , version : Version ) -> bool : # version = self.version.weaken(version) return self . version == version accepts = contains def includes ( self , version_set : VersionSet ) -> bool : return version_set . is_empty () or ( is_version_point ( version_set ) and self . contains ( version_set . version ) ) def intersects ( self , version_set : VersionSet ) -> bool : return version_set . contains ( self . version ) def intersection ( self , version_set : VersionSet ) -> VersionSet : return self if version_set . contains ( self . version ) else VersionEmpty () def union ( self , version_set : VersionSet ) -> VersionSet : if is_version_empty ( version_set ): return self if is_version_point ( version_set ): if self . contains ( version_set . version ): return self return VersionUnion . of ( self , version_set ) if version_set . contains ( self . version ): return version_set if is_version_range ( version_set ) or is_version_union ( version_set ): return VersionUnion . of ( self , version_set ) raise TypeError # TODO: message? def difference ( self , version_set : VersionSet ) -> VersionSet : return VersionEmpty () if version_set . contains ( self . version ) else self def complement ( self ) -> VersionSet : return VersionRange () . difference ( self ) def to_string ( self ) -> str : return self . version . to_string () def to_short_string ( self ) -> str : return self . version . to_short_string ()","title":"VersionPoint"},{"location":"reference/#versions.version_sets.VersionUnion","text":"Bases: Representation , ToString , Specification Represents version unions. Source code in versions/version_sets.py 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 @frozen ( repr = False , order = False ) class VersionUnion ( Representation , ToString , Specification ): \"\"\"Represents version unions.\"\"\" items : VersionItems = field () @items . validator def check_items ( self , attribute : Attribute [ VersionItems ], items : VersionItems ) -> None : check_items ( items ) @classmethod def extract ( cls , version_set : VersionSet ) -> Iterator [ VersionItem ]: if is_version_union ( version_set ): yield from version_set . items elif is_version_item ( version_set ): yield version_set else : raise TypeError # TODO: message? @classmethod def of ( cls , * version_sets : VersionSet ) -> VersionSet : return cls . of_iterable ( version_sets ) @classmethod def of_iterable ( cls , iterable : Iterable [ VersionSet ]) -> VersionSet : extracted = list ( flatten ( map ( cls . extract , iterable ))) if not extracted : return VersionEmpty () if any ( item . is_universe () for item in extracted ): return VersionRange () extracted . sort () merged : List [ VersionItem ] = [] for item in extracted : if not merged : merged . append ( item ) else : last_item = last ( merged ) if last_item . intersects ( item ) or last_item . is_adjacent ( item ): result = last_item . union ( item ) if is_version_item ( result ): set_last ( merged , result ) else : raise InternalError # TODO: message? else : merged . append ( item ) if contains_only_item ( merged ): return first ( merged ) return cls ( tuple ( merged )) @property def exclude_version ( self ) -> Optional [ Version ]: complement = self . complement () return complement . version if is_version_point ( complement ) else None def is_empty ( self ) -> bool : return False def is_universe ( self ) -> bool : return False def contains ( self , version : Version ) -> bool : return any ( item . contains ( version ) for item in self . items ) accepts = contains def includes ( self , version_set : VersionSet ) -> bool : self_items = iter ( self . items ) items = self . extract ( version_set ) self_item = next_or_none ( self_items ) item = next_or_none ( items ) while self_item and item : if self_item . includes ( item ): item = next_or_none ( items ) else : self_item = next_or_none ( self_items ) return item is None # all items are covered def intersects ( self , version_set : VersionSet ) -> bool : self_items = iter ( self . items ) items = self . extract ( version_set ) self_item = next_or_none ( self_items ) item = next_or_none ( items ) while self_item and item : if self_item . intersects ( item ): return True if item . is_higher ( self_item ): self_item = next_or_none ( self_items ) else : item = next_or_none ( items ) return False # none of the items are allowed def intersection_iterator ( self , version_set : VersionSet ) -> Iterator [ VersionItem ]: self_items = iter ( self . items ) items = self . extract ( version_set ) self_item = next_or_none ( self_items ) item = next_or_none ( items ) while self_item and item : intersection = self_item . intersection ( item ) if is_version_item ( intersection ): yield intersection if item . is_higher ( self_item ): self_item = next_or_none ( self_items ) else : item = next_or_none ( items ) def intersection ( self , version_set : VersionSet ) -> VersionSet : return self . of_iterable ( self . intersection_iterator ( version_set )) def union ( self , version_set : VersionSet ) -> VersionSet : return self . of ( self , version_set ) def difference ( self , version_set : VersionSet ) -> VersionSet : items_difference = ItemsDifference ( iter ( self . items ), self . extract ( version_set )) return self . of_iterable ( items_difference . compute ()) def complement ( self ) -> VersionSet : return VersionRange () . difference ( self ) def to_string ( self ) -> str : exclude_version = self . exclude_version if exclude_version : operator = Operator ( OperatorType . NOT_EQUAL , exclude_version ) return operator . to_string () return concat_pipes_spaced ( item . to_string () for item in self . items ) def to_short_string ( self ) -> str : exclude_version = self . exclude_version if exclude_version : operator = Operator ( OperatorType . NOT_EQUAL , exclude_version ) return operator . to_short_string () return concat_pipes ( item . to_short_string () for item in self . items )","title":"VersionUnion"},{"location":"reference/#versions.specifiers.Specifier","text":"Bases: Representation , ToString , Specification Represents all possible specifiers. Source code in versions/specifiers.py 43 44 class Specifier ( Representation , ToString , Specification ): \"\"\"Represents all possible specifiers.\"\"\"","title":"Specifier"},{"location":"reference/#versions.specifiers.SpecifierFalse","text":"Bases: Specifier Represents specifiers that do not accept any version. Source code in versions/specifiers.py 50 51 52 53 54 55 56 57 58 @frozen ( repr = False ) class SpecifierFalse ( Specifier ): \"\"\"Represents specifiers that do not accept any version.\"\"\" def accepts ( self , version : Version ) -> Literal [ False ]: return False def to_string ( self ) -> str : return EMPTY_VERSION","title":"SpecifierFalse"},{"location":"reference/#versions.specifiers.SpecifierTrue","text":"Bases: Specifier Represents specifiers that accept all versions. Source code in versions/specifiers.py 61 62 63 64 65 66 67 68 69 @frozen ( repr = False ) class SpecifierTrue ( Specifier ): \"\"\"Represents specifiers that accept all versions.\"\"\" def accepts ( self , version : Version ) -> Literal [ True ]: return True def to_string ( self ) -> str : return UNIVERSE_VERSION","title":"SpecifierTrue"},{"location":"reference/#versions.specifiers.SpecifierSingle","text":"Bases: Operator , Specifier Represents specifiers that accept versions according to the Operator type. Source code in versions/specifiers.py 72 73 74 75 76 77 78 79 @frozen ( repr = False ) class SpecifierSingle ( Operator , Specifier ): \"\"\"Represents specifiers that accept versions according to the [`Operator`][versions.operators.Operator] type. \"\"\" def accepts ( self , version : Version ) -> bool : return self . partial_matches ( version )","title":"SpecifierSingle"},{"location":"reference/#versions.specifiers.SpecifierAny","text":"Bases: Specifier Represents collections of two or more specifiers that accept versions if any of the contained specifiers accept it. Source code in versions/specifiers.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 @frozen ( repr = False ) class SpecifierAny ( Specifier ): \"\"\"Represents collections of two or more specifiers that accept versions if any of the contained specifiers accept it. \"\"\" WRAP : ClassVar [ bool ] = False specifiers : Specifiers = field () @specifiers . validator def check_specifiers ( self , attribute : Attribute [ Specifiers ], specifiers : Specifiers ) -> None : check_specifiers ( specifiers ) @classmethod def of_specifiers ( cls , specifiers : Specifiers ) -> Specifier : if not specifiers : return SpecifierTrue () if contains_only_item ( specifiers ): return first ( specifiers ) return cls ( specifiers ) @classmethod def of ( cls , * specifiers : Specifier ) -> Specifier : return cls . of_specifiers ( specifiers ) @classmethod def of_iterable ( cls , iterable : Iterable [ Specifier ]) -> Specifier : return cls . of_specifiers ( tuple ( iterable )) def accepts ( self , version : Version ) -> bool : return any ( specifier . accepts ( version ) for specifier in self . specifiers ) def to_string ( self ) -> str : return create_wrap_around ( concat_pipes_spaced ( specifier . to_string () for specifier in self . specifiers ) ) def to_short_string ( self ) -> str : return create_wrap_around ( concat_pipes ( specifier . to_short_string () for specifier in self . specifiers ) )","title":"SpecifierAny"},{"location":"reference/#versions.specifiers.SpecifierAll","text":"Bases: Specifier Represents collections of two or more specifiers that accept versions if and only if all of the contained specifiers accept it. Source code in versions/specifiers.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 @frozen ( repr = False ) class SpecifierAll ( Specifier ): \"\"\"Represents collections of two or more specifiers that accept versions if and only if all of the contained specifiers accept it. \"\"\" WRAP : ClassVar [ bool ] = False specifiers : Specifiers = field () @specifiers . validator def check_specifiers ( self , attribute : Attribute [ Specifiers ], specifiers : Specifiers ) -> None : check_specifiers ( specifiers ) @classmethod def of_specifiers ( cls , specifiers : Specifiers ) -> Specifier : if not specifiers : return SpecifierTrue () if contains_only_item ( specifiers ): return first ( specifiers ) return cls ( specifiers ) @classmethod def of ( cls , * specifiers : Specifier ) -> Specifier : return cls . of_specifiers ( specifiers ) @classmethod def of_iterable ( cls , iterable : Iterable [ Specifier ]) -> Specifier : return cls . of_specifiers ( tuple ( iterable )) def accepts ( self , version : Version ) -> bool : return all ( specifier . accepts ( version ) for specifier in self . specifiers ) def to_string ( self ) -> str : return create_wrap_around ( concat_comma_space ( specifier . to_string () for specifier in self . specifiers ) ) def to_short_string ( self ) -> str : return create_wrap_around ( concat_comma ( specifier . to_short_string () for specifier in self . specifiers ) )","title":"SpecifierAll"},{"location":"reference/#versions.specifiers.is_specifier","text":"Checks if an item is an instance of Specifier . Parameters: Name Type Description Default item Any The item to check. required Returns: Type Description TypeGuard [ Specifier ] Whether the item provided is an instance of Specifier . Source code in versions/specifiers.py 186 187 188 189 190 191 192 193 194 195 def is_specifier ( item : Any ) -> TypeGuard [ Specifier ]: \"\"\"Checks if an `item` is an instance of [`Specifier`][versions.specifiers.Specifier]. Arguments: item: The item to check. Returns: Whether the `item` provided is an instance of [`Specifier`][versions.specifiers.Specifier]. \"\"\" return is_instance ( item , Specifier )","title":"is_specifier()"},{"location":"reference/#versions.specifiers.is_specifier_false","text":"Checks if an item is an instance of SpecifierFalse . Parameters: Name Type Description Default item Any The item to check. required Returns: Type Description TypeGuard [ SpecifierFalse ] Whether the item provided is an instance of TypeGuard [ SpecifierFalse ] SpecifierFalse . Source code in versions/specifiers.py 198 199 200 201 202 203 204 205 206 207 208 209 def is_specifier_false ( item : Any ) -> TypeGuard [ SpecifierFalse ]: \"\"\"Checks if an `item` is an instance of [`SpecifierFalse`][versions.specifiers.SpecifierFalse]. Arguments: item: The item to check. Returns: Whether the `item` provided is an instance of [`SpecifierFalse`][versions.specifiers.SpecifierFalse]. \"\"\" return is_instance ( item , SpecifierFalse )","title":"is_specifier_false()"},{"location":"reference/#versions.specifiers.is_specifier_true","text":"Checks if an item is an instance of SpecifierTrue . Parameters: Name Type Description Default item Any The item to check. required Returns: Type Description TypeGuard [ SpecifierTrue ] Whether the item provided is an instance of TypeGuard [ SpecifierTrue ] SpecifierTrue . Source code in versions/specifiers.py 212 213 214 215 216 217 218 219 220 221 222 223 def is_specifier_true ( item : Any ) -> TypeGuard [ SpecifierTrue ]: \"\"\"Checks if an `item` is an instance of [`SpecifierTrue`][versions.specifiers.SpecifierTrue]. Arguments: item: The item to check. Returns: Whether the `item` provided is an instance of [`SpecifierTrue`][versions.specifiers.SpecifierTrue]. \"\"\" return is_instance ( item , SpecifierTrue )","title":"is_specifier_true()"},{"location":"reference/#versions.specifiers.is_specifier_single","text":"Checks if an item is an instance of SpecifierSingle . Parameters: Name Type Description Default item Any The item to check. required Returns: Type Description TypeGuard [ SpecifierSingle ] Whether the item provided is an instance of TypeGuard [ SpecifierSingle ] SpecifierSingle . Source code in versions/specifiers.py 226 227 228 229 230 231 232 233 234 235 236 237 def is_specifier_single ( item : Any ) -> TypeGuard [ SpecifierSingle ]: \"\"\"Checks if an `item` is an instance of [`SpecifierSingle`][versions.specifiers.SpecifierSingle]. Arguments: item: The item to check. Returns: Whether the `item` provided is an instance of [`SpecifierSingle`][versions.specifiers.SpecifierSingle]. \"\"\" return is_instance ( item , SpecifierSingle )","title":"is_specifier_single()"},{"location":"reference/#versions.specifiers.is_specifier_any","text":"Checks if an item is an instance of SpecifierAny . Parameters: Name Type Description Default item Any The item to check. required Returns: Type Description TypeGuard [ SpecifierAny ] Whether the item provided is an instance of TypeGuard [ SpecifierAny ] SpecifierAny . Source code in versions/specifiers.py 240 241 242 243 244 245 246 247 248 249 250 251 def is_specifier_any ( item : Any ) -> TypeGuard [ SpecifierAny ]: \"\"\"Checks if an `item` is an instance of [`SpecifierAny`][versions.specifiers.SpecifierAny]. Arguments: item: The item to check. Returns: Whether the `item` provided is an instance of [`SpecifierAny`][versions.specifiers.SpecifierAny]. \"\"\" return is_instance ( item , SpecifierAny )","title":"is_specifier_any()"},{"location":"reference/#versions.specifiers.is_specifier_all","text":"Checks if an item is an instance of SpecifierAll . Parameters: Name Type Description Default item Any The item to check. required Returns: Type Description TypeGuard [ SpecifierAll ] Whether the item provided is an instance of TypeGuard [ SpecifierAll ] SpecifierAll . Source code in versions/specifiers.py 254 255 256 257 258 259 260 261 262 263 264 265 def is_specifier_all ( item : Any ) -> TypeGuard [ SpecifierAll ]: \"\"\"Checks if an `item` is an instance of [`SpecifierAll`][versions.specifiers.SpecifierAll]. Arguments: item: The item to check. Returns: Whether the `item` provided is an instance of [`SpecifierAll`][versions.specifiers.SpecifierAll]. \"\"\" return is_instance ( item , SpecifierAll )","title":"is_specifier_all()"},{"location":"reference/#versions.converters.simplify","text":"Simplifies Specifier specification. Simplification is accomplished through converting to the version set and back. Source code in versions/converters.py 45 46 47 48 49 50 def simplify ( specifier : Specifier ) -> Specifier : \"\"\"Simplifies [`Specifier`][versions.specifiers.Specifier] specification. Simplification is accomplished through converting to the version set and back. \"\"\" return specifier_from_version_set ( specifier_to_version_set ( specifier ))","title":"simplify()"},{"location":"reference/#versions.converters.specifier_to_version_set","text":"Converts Specifier to VersionSet . There is an alias of this called version_set_from_specifier . Source code in versions/converters.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def specifier_to_version_set ( specifier : Specifier ) -> VersionSet : \"\"\"Converts [`Specifier`][versions.specifiers.Specifier] to [`VersionSet`][versions.version_sets.VersionSet]. There is an alias of this called `version_set_from_specifier`. \"\"\" if is_specifier_single ( specifier ): return specifier . translate ( specifier . version ) if is_specifier_false ( specifier ): return VersionEmpty () if is_specifier_true ( specifier ): return VersionRange () if is_specifier_all ( specifier ): return reduce ( intersection , map ( specifier_to_version_set , specifier . specifiers )) if is_specifier_any ( specifier ): return reduce ( union , map ( specifier_to_version_set , specifier . specifiers )) raise TypeError # TODO: message?","title":"specifier_to_version_set()"},{"location":"reference/#versions.converters.version_set_to_specifier","text":"Converts VersionSet to Specifier . There is an alias of this function called specifier_from_version_set . Source code in versions/converters.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 def version_set_to_specifier ( version_set : VersionSet ) -> Specifier : \"\"\"Converts [`VersionSet`][versions.version_sets.VersionSet] to [`Specifier`][versions.specifiers.Specifier]. There is an alias of this function called `specifier_from_version_set`. \"\"\" if is_version_empty ( version_set ): return SpecifierFalse () if is_version_point ( version_set ): return SpecifierSingle ( OperatorType . DOUBLE_EQUAL , version_set . version ) if is_version_range ( version_set ): if version_set . is_empty (): return SpecifierFalse () if version_set . is_universe (): return SpecifierTrue () if version_set . is_point (): return SpecifierSingle ( OperatorType . DOUBLE_EQUAL , version_set . version ) min = version_set . min max = version_set . max min_specifier = None max_specifier = None if min : min_type = ( OperatorType . GREATER_OR_EQUAL if version_set . include_min else OperatorType . GREATER ) min_specifier = SpecifierSingle ( min_type , min ) if max : max_type = OperatorType . LESS_OR_EQUAL if version_set . include_max else OperatorType . LESS max_specifier = SpecifierSingle ( max_type , max ) if min_specifier and max_specifier : return SpecifierAll . of ( min_specifier , max_specifier ) specifier = min_specifier or max_specifier if specifier is None : raise InternalError # TODO: message? return specifier if is_version_union ( version_set ): exclude_version = version_set . exclude_version if exclude_version : return SpecifierSingle ( OperatorType . NOT_EQUAL , exclude_version ) return SpecifierAny . of_iterable ( map ( version_set_to_specifier , version_set . items )) raise TypeError # TODO: message?","title":"version_set_to_specifier()"},{"location":"reference/#versions.operators.OperatorType","text":"Bases: Enum Represents operator types. Source code in versions/operators.py 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 class OperatorType ( Enum ): \"\"\"Represents operator types.\"\"\" # official constraints TILDE_EQUAL = TILDE_EQUAL DOUBLE_EQUAL = DOUBLE_EQUAL NOT_EQUAL = NOT_EQUAL LESS = LESS LESS_OR_EQUAL = LESS_OR_EQUAL GREATER = GREATER GREATER_OR_EQUAL = GREATER_OR_EQUAL # additional constraints CARET = CARET EQUAL = EQUAL TILDE = TILDE # wildcard constraints WILDCARD_DOUBLE_EQUAL = WILDCARD_DOUBLE_EQUAL WILDCARD_EQUAL = WILDCARD_EQUAL WILDCARD_NOT_EQUAL = WILDCARD_NOT_EQUAL def is_wildcard ( self ) -> bool : \"\"\"Checks whether the operator is *wildcard*.\"\"\" return self in WILDCARD def is_unary ( self ) -> bool : \"\"\"Checks whether the operator is *unary*.\"\"\" return self in UNARY @property def string ( self ) -> str : return wildcard_type ( self . value )","title":"OperatorType"},{"location":"reference/#versions.operators.OperatorType.is_wildcard","text":"Checks whether the operator is wildcard . Source code in versions/operators.py 666 667 668 def is_wildcard ( self ) -> bool : \"\"\"Checks whether the operator is *wildcard*.\"\"\" return self in WILDCARD","title":"is_wildcard()"},{"location":"reference/#versions.operators.OperatorType.is_unary","text":"Checks whether the operator is unary . Source code in versions/operators.py 670 671 672 def is_unary ( self ) -> bool : \"\"\"Checks whether the operator is *unary*.\"\"\" return self in UNARY","title":"is_unary()"},{"location":"reference/#versions.operators.Operator","text":"Bases: Representation , ToString Represents operators. Source code in versions/operators.py 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 @frozen ( repr = False ) class Operator ( Representation , ToString ): \"\"\"Represents operators.\"\"\" type : OperatorType version : Version def is_unary ( self ) -> bool : \"\"\"Checks whether the operator is *unary*.\"\"\" return self . type . is_unary () def is_wildcard ( self ) -> bool : \"\"\"Checks whether the operator is *wildcard*.\"\"\" return self . type . is_wildcard () @property def matches_and_translate ( self ) -> Tuple [ Matches , Translate ]: return OPERATOR [ self . type ] @property def matches ( self ) -> Matches : \"\"\"The `matches` function representing the operator.\"\"\" matches , _translate = self . matches_and_translate return matches @property def translate ( self ) -> Translate : \"\"\"The `translate` function representing the operator.\"\"\" _matches , translate = self . matches_and_translate return translate @property def partial_matches ( self ) -> PartialMatches : \"\"\"The partial `matches` function with `self.version` as the `version`.\"\"\" return partial_matches ( self . matches , self . version ) def to_string ( self ) -> str : string = self . version . to_string () if self . is_wildcard (): string = wildcard_string ( string ) if self . is_unary (): return concat_empty_args ( self . type . string , string ) return concat_space_args ( self . type . string , string ) def to_short_string ( self ) -> str : string = self . version . to_short_string () if self . is_wildcard (): string = wildcard_string ( string ) return concat_empty_args ( self . type . string , string )","title":"Operator"},{"location":"reference/#versions.operators.Operator.is_unary","text":"Checks whether the operator is unary . Source code in versions/operators.py 711 712 713 def is_unary ( self ) -> bool : \"\"\"Checks whether the operator is *unary*.\"\"\" return self . type . is_unary ()","title":"is_unary()"},{"location":"reference/#versions.operators.Operator.is_wildcard","text":"Checks whether the operator is wildcard . Source code in versions/operators.py 715 716 717 def is_wildcard ( self ) -> bool : \"\"\"Checks whether the operator is *wildcard*.\"\"\" return self . type . is_wildcard ()","title":"is_wildcard()"},{"location":"reference/#versions.operators.Operator.matches","text":"The matches function representing the operator. Source code in versions/operators.py 723 724 725 726 727 728 @property def matches ( self ) -> Matches : \"\"\"The `matches` function representing the operator.\"\"\" matches , _translate = self . matches_and_translate return matches","title":"matches()"},{"location":"reference/#versions.operators.Operator.translate","text":"The translate function representing the operator. Source code in versions/operators.py 730 731 732 733 734 735 @property def translate ( self ) -> Translate : \"\"\"The `translate` function representing the operator.\"\"\" _matches , translate = self . matches_and_translate return translate","title":"translate()"},{"location":"reference/#versions.operators.Operator.partial_matches","text":"The partial matches function with self.version as the version . Source code in versions/operators.py 737 738 739 740 @property def partial_matches ( self ) -> PartialMatches : \"\"\"The partial `matches` function with `self.version` as the `version`.\"\"\" return partial_matches ( self . matches , self . version )","title":"partial_matches()"},{"location":"reference/#versions.operators.next_caret_breaking","text":"Returns the next breaking version according to the caret ( ^ ) strategy. This function is slightly convoluted due to handling 0.x.y versions. See Version.next_breaking for more information. Example >>> from versions import next_caret_breaking , parse_version >>> version = parse_version ( \"1.0.0\" ) >>> version < Version ( 1.0.0 ) > >>> next_caret_breaking ( version ) < Version ( 2.0.0 ) > Parameters: Name Type Description Default version V The version to find next breaking version of. required Returns: Type Description V The next breaking version according to the version . Source code in versions/operators.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 def next_caret_breaking ( version : V ) -> V : \"\"\"Returns the next breaking version according to the *caret* (`^`) strategy. This function is slightly convoluted due to handling `0.x.y` versions. See [`Version.next_breaking`][versions.version.Version.next_breaking] for more information. Example: ```python >>> from versions import next_caret_breaking, parse_version >>> version = parse_version(\"1.0.0\") >>> version <Version (1.0.0)> >>> next_caret_breaking(version) <Version (2.0.0)> ``` Arguments: version: The version to find next breaking version of. Returns: The next breaking version according to the `version`. \"\"\" return version . next_breaking ()","title":"next_caret_breaking()"},{"location":"reference/#versions.operators.next_tilde_equal_breaking","text":"Returns the next breaking version according to the tilde-equal ( ~= ) strategy. This function simply bumps the last part of the release. Example >>> from versions import next_tilde_equal_breaking , parse_version >>> version = parse_version ( \"1.2.2\" ) >>> version < Version ( 1.2.2 ) > >>> next_tilde_equal_breaking ( version ) < Version ( 1.2.3 ) > Parameters: Name Type Description Default version V The version to find the next breaking version of. required Returns: Type Description V The next breaking Version according to the version . Source code in versions/operators.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 def next_tilde_equal_breaking ( version : V ) -> V : \"\"\"Returns the next breaking version according to the *tilde-equal* (`~=`) strategy. This function simply bumps the last part of the release. Example: ```python >>> from versions import next_tilde_equal_breaking, parse_version >>> version = parse_version(\"1.2.2\") >>> version <Version (1.2.2)> >>> next_tilde_equal_breaking(version) <Version (1.2.3)> ``` Arguments: version: The version to find the next breaking version of. Returns: The next breaking [`Version`][versions.version.Version] according to the `version`. \"\"\" index = version . last_index if index : return version . to_stable () . next_at ( index - 1 ) raise ValueError # TODO: message?","title":"next_tilde_equal_breaking()"},{"location":"reference/#versions.operators.next_tilde_breaking","text":"Returns the next breaking version according to the tilde ( ~ ) strategy. This function simply bumps the minor part of the version if it is present, otherwise the major part is bumped. Example >>> from versions import next_tilde_equal_breaking , parse_version >>> version = parse_version ( \"2.0.0\" ) >>> version < Version ( 2.1.0 ) > >>> next_tilde_breaking ( version ) < Version ( 2.2.0 ) > Parameters: Name Type Description Default version V The version to find the next breaking version of. required Returns: Type Description V The next breaking Version according to the version . Source code in versions/operators.py 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 def next_tilde_breaking ( version : V ) -> V : \"\"\"Returns the next breaking version according to the *tilde* (`~`) strategy. This function simply bumps the minor part of the version if it is present, otherwise the major part is bumped. Example: ```python >>> from versions import next_tilde_equal_breaking, parse_version >>> version = parse_version(\"2.0.0\") >>> version <Version (2.1.0)> >>> next_tilde_breaking(version) <Version (2.2.0)> ``` Arguments: version: The version to find the next breaking version of. Returns: The next breaking [`Version`][versions.version.Version] according to the `version`. \"\"\" if version . has_minor (): return version . next_minor () return version . next_major ()","title":"next_tilde_breaking()"},{"location":"reference/#versions.operators.next_wildcard_breaking","text":"Returns the next breaking version according to the wildcard ( * ) strategy. There are three cases to handle: If the wildcard is used within the pre part of the version, next breaking version has the same release with pre part removed. For example, x.y.z-rc.* is bumped to x.y.z . If the wildcard is used within the post part of the version, next breaking version has the last part of the release bumped. For instance, x.y.z-post.* is bumped to x.y.z' , where z' = z + 1 . Otherwise, the second to last part of the release is bumped. For example, x.y.* is bumped to x.y'.0 , where y' = y + 1 . Note that this function returns None if the given version is * . Example >>> from versions import next_wildcard_breaking , parse_version >>> version = parse_version ( \"4.2.0\" ) >>> version < Version ( 4.2.0 ) > >>> next_wildcard_breaking ( version ) < Version ( 4.3.0 ) > >>> other = parse_version ( \"1.2.3-rc.0\" ) >>> other < Version ( 1.2.3 - rc .0 ) > >>> next_wildcard_breaking ( other ) < Version ( 1.2.3 ) > >>> another = parse_version ( \"0.6.8-post.0\" ) >>> another < Version ( 0.6.8 - post .0 ) > >>> next_wildcard_breaking ( another ) < Version ( 0.6.9 ) > # nice Parameters: Name Type Description Default version V The version to find the next breaking version of. required Returns: Type Description Optional [ V ] The next breaking Version according to the version , or None . Source code in versions/operators.py 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 def next_wildcard_breaking ( version : V ) -> Optional [ V ]: \"\"\"Returns the next breaking version according to the *wildcard* (`*`) strategy. There are three cases to handle: - If the wildcard is used within the `pre` part of the version, next breaking version has the same release with `pre` part removed. For example, `x.y.z-rc.*` is bumped to `x.y.z`. - If the wildcard is used within the `post` part of the version, next breaking version has the last part of the release bumped. For instance, `x.y.z-post.*` is bumped to `x.y.z'`, where `z' = z + 1`. - Otherwise, the second to last part of the release is bumped. For example, `x.y.*` is bumped to `x.y'.0`, where `y' = y + 1`. Note that this function returns [`None`][None] if the given version is `*`. Example: ```python >>> from versions import next_wildcard_breaking, parse_version >>> version = parse_version(\"4.2.0\") >>> version <Version (4.2.0)> >>> next_wildcard_breaking(version) <Version (4.3.0)> >>> other = parse_version(\"1.2.3-rc.0\") >>> other <Version (1.2.3-rc.0)> >>> next_wildcard_breaking(other) <Version (1.2.3)> >>> another = parse_version(\"0.6.8-post.0\") >>> another <Version (0.6.8-post.0)> >>> next_wildcard_breaking(another) <Version (0.6.9)> # nice ``` Arguments: version: The version to find the next breaking version of. Returns: The next breaking [`Version`][versions.version.Version] according to the `version`, or [`None`][None]. \"\"\" index = version . last_index if version . is_stable () and not version . is_post_release (): # the wildcard was used within the release segment if not index : return None index -= 1 return version . next_at ( index ) # this will take care of unstable releases","title":"next_wildcard_breaking()"},{"location":"reference/#versions.operators.matches_caret","text":"Checks if the version matches the caret ( ^ ) specification. This is functionally the same as: against <= version < next_caret_breaking ( against ) Parameters: Name Type Description Default version Version The version to check. required against Version The version to check version against. required Returns: Type Description bool Whether the version matches against . Source code in versions/operators.py 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 def matches_caret ( version : Version , against : Version ) -> bool : \"\"\"Checks if the `version` matches the *caret* (`^`) specification. This is functionally the same as: ```python against <= version < next_caret_breaking(against) ``` Arguments: version: The version to check. against: The version to check `version` against. Returns: Whether the `version` matches `against`. \"\"\" return against <= version < next_caret_breaking ( against )","title":"matches_caret()"},{"location":"reference/#versions.operators.matches_tilde_equal","text":"Checks if the version matches the tilde-equal ( ~= ) specification. This is functionally the same as: against <= version < next_tilde_equal_breaking ( against ) Parameters: Name Type Description Default version Version The version to check. required against Version The version to check version against. required Returns: Type Description bool Whether the version matches against . Source code in versions/operators.py 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 def matches_tilde_equal ( version : Version , against : Version ) -> bool : \"\"\"Checks if the `version` matches the *tilde-equal* (`~=`) specification. This is functionally the same as: ```python against <= version < next_tilde_equal_breaking(against) ``` Arguments: version: The version to check. against: The version to check `version` against. Returns: Whether the `version` matches `against`. \"\"\" return against <= version < next_tilde_equal_breaking ( against )","title":"matches_tilde_equal()"},{"location":"reference/#versions.operators.matches_tilde","text":"Checks if the version matches the tilde ( ~ ) specification. This is functionally the same as: against <= version < next_tilde_breaking ( against ) Parameters: Name Type Description Default version Version The version to check. required against Version The version to check version against. required Returns: Type Description bool Whether the version matches against . Source code in versions/operators.py 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 def matches_tilde ( version : Version , against : Version ) -> bool : \"\"\"Checks if the `version` matches the *tilde* (`~`) specification. This is functionally the same as: ```python against <= version < next_tilde_breaking(against) ``` Arguments: version: The version to check. against: The version to check `version` against. Returns: Whether the `version` matches `against`. \"\"\" return against <= version < next_tilde_breaking ( against )","title":"matches_tilde()"},{"location":"reference/#versions.operators.matches_equal","text":"Checks if the version matches the equal ( == ) specification. This is functionally the same as: version == against Parameters: Name Type Description Default version Version The version to check. required against Version The version to check version against. required Returns: Type Description bool Whether the version matches against . Source code in versions/operators.py 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 def matches_equal ( version : Version , against : Version ) -> bool : \"\"\"Checks if the `version` matches the *equal* (`==`) specification. This is functionally the same as: ```python version == against ``` Arguments: version: The version to check. against: The version to check `version` against. Returns: Whether the `version` matches `against`. \"\"\" return version == against","title":"matches_equal()"},{"location":"reference/#versions.operators.matches_not_equal","text":"Checks if the version matches the not-equal ( != ) specification. This is functionally the same as: version != against Parameters: Name Type Description Default version Version The version to check. required against Version The version to check version against. required Returns: Type Description bool Whether the version matches against . Source code in versions/operators.py 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 def matches_not_equal ( version : Version , against : Version ) -> bool : \"\"\"Checks if the `version` matches the *not-equal* (`!=`) specification. This is functionally the same as: ```python version != against ``` Arguments: version: The version to check. against: The version to check `version` against. Returns: Whether the `version` matches `against`. \"\"\" return version != against","title":"matches_not_equal()"},{"location":"reference/#versions.operators.matches_less","text":"Checks if the version matches the less ( < ) specification. This is functionally the same as: version < against Parameters: Name Type Description Default version Version The version to check. required against Version The version to check version against. required Returns: Type Description bool Whether the version matches against . Source code in versions/operators.py 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 def matches_less ( version : Version , against : Version ) -> bool : \"\"\"Checks if the `version` matches the *less* (`<`) specification. This is functionally the same as: ```python version < against ``` Arguments: version: The version to check. against: The version to check `version` against. Returns: Whether the `version` matches `against`. \"\"\" return version < against","title":"matches_less()"},{"location":"reference/#versions.operators.matches_less_or_equal","text":"Checks if the version matches the less-or-equal ( <= ) specification. This is functionally the same as: version <= against Parameters: Name Type Description Default version Version The version to check. required against Version The version to check version against. required Returns: Type Description bool Whether the version matches against . Source code in versions/operators.py 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 def matches_less_or_equal ( version : Version , against : Version ) -> bool : \"\"\"Checks if the `version` matches the *less-or-equal* (`<=`) specification. This is functionally the same as: ```python version <= against ``` Arguments: version: The version to check. against: The version to check `version` against. Returns: Whether the `version` matches `against`. \"\"\" return version <= against","title":"matches_less_or_equal()"},{"location":"reference/#versions.operators.matches_greater","text":"Checks if the version matches the greater ( > ) specification. This is functionally the same as: version > against Parameters: Name Type Description Default version Version The version to check. required against Version The version to check version against. required Returns: Type Description bool Whether the version matches against . Source code in versions/operators.py 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 def matches_greater ( version : Version , against : Version ) -> bool : \"\"\"Checks if the `version` matches the *greater* (`>`) specification. This is functionally the same as: ```python version > against ``` Arguments: version: The version to check. against: The version to check `version` against. Returns: Whether the `version` matches `against`. \"\"\" return version > against","title":"matches_greater()"},{"location":"reference/#versions.operators.matches_greater_or_equal","text":"Checks if the version matches the greater-or-equal ( >= ) specification. This is functionally the same as: version >= against Parameters: Name Type Description Default version Version The version to check. required against Version The version to check version against. required Returns: Type Description bool Whether the version matches against . Source code in versions/operators.py 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 def matches_greater_or_equal ( version : Version , against : Version ) -> bool : \"\"\"Checks if the `version` matches the *greater-or-equal* (`>=`) specification. This is functionally the same as: ```python version >= against ``` Arguments: version: The version to check. against: The version to check `version` against. Returns: Whether the `version` matches `against`. \"\"\" return version >= against","title":"matches_greater_or_equal()"},{"location":"reference/#versions.operators.matches_wildcard_equal","text":"Checks if the version matches the wildcard-equal ( == * ) specification. This is functionally the same as: wildcard = next_wildcard_breaking ( against ) wildcard is None or against <= version < wildcard Parameters: Name Type Description Default version Version The version to check. required against Version The version to check version against. required Returns: Type Description bool Whether the version matches against . Source code in versions/operators.py 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 def matches_wildcard_equal ( version : Version , against : Version ) -> bool : \"\"\"Checks if the `version` matches the *wildcard-equal* (`== *`) specification. This is functionally the same as: ```python wildcard = next_wildcard_breaking(against) wildcard is None or against <= version < wildcard ``` Arguments: version: The version to check. against: The version to check `version` against. Returns: Whether the `version` matches `against`. \"\"\" wildcard = next_wildcard_breaking ( against ) if wildcard is None : return True return against <= version < wildcard","title":"matches_wildcard_equal()"},{"location":"reference/#versions.operators.matches_wildcard_not_equal","text":"Checks if the version matches the wildcard-not-equal ( != * ) specification. This is functionally the same as: wildcard = next_wildcard_breaking ( against ) wildcard is not None and ( version < against or version >= wildcard ) Parameters: Name Type Description Default version Version The version to check. required against Version The version to check version against. required Returns: Type Description bool Whether the version matches against . Source code in versions/operators.py 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 def matches_wildcard_not_equal ( version : Version , against : Version ) -> bool : \"\"\"Checks if the `version` matches the *wildcard-not-equal* (`!= *`) specification. This is functionally the same as: ```python wildcard = next_wildcard_breaking(against) wildcard is not None and (version < against or version >= wildcard) ``` Arguments: version: The version to check. against: The version to check `version` against. Returns: Whether the `version` matches `against`. \"\"\" return not matches_wildcard_equal ( version , against )","title":"matches_wildcard_not_equal()"},{"location":"reference/#versions.operators.translate_caret","text":"Translate the version into a version set according to the caret ( ^ ) strategy. This function returns the [version, next_caret_breaking(version)) range. Parameters: Name Type Description Default version Version The version to translate. required Returns: Type Description VersionRange The version set representing the caret specification. Source code in versions/operators.py 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 def translate_caret ( version : Version ) -> VersionRange : \"\"\"Translate the `version` into a version set according to the *caret* (`^`) strategy. This function returns the `[version, next_caret_breaking(version))` range. Arguments: version: The version to translate. Returns: The version set representing the *caret* specification. \"\"\" return VersionRange ( min = version , max = next_caret_breaking ( version ), include_min = True , include_max = False , )","title":"translate_caret()"},{"location":"reference/#versions.operators.translate_tilde_equal","text":"Translate the version into a version set according to the tilde-equal ( ~= ) strategy. This function returns the [version, next_tilde_equal_breaking(version)) range. Parameters: Name Type Description Default version Version The version to translate. required Returns: Type Description VersionRange The version set representing the tilde-equal specification. Source code in versions/operators.py 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 def translate_tilde_equal ( version : Version ) -> VersionRange : \"\"\"Translate the `version` into a version set according to the *tilde-equal* (`~=`) strategy. This function returns the `[version, next_tilde_equal_breaking(version))` range. Arguments: version: The version to translate. Returns: The version set representing the *tilde-equal* specification. \"\"\" return VersionRange ( min = version , max = next_tilde_equal_breaking ( version ), include_min = True , include_max = False , )","title":"translate_tilde_equal()"},{"location":"reference/#versions.operators.translate_tilde","text":"Translate the version into a version set according to the tilde ( ~ ) strategy. This function returns the [version, next_tilde_breaking(version)) range. Parameters: Name Type Description Default version Version The version to translate. required Returns: Type Description VersionRange The version set representing the tilde-equal specification. Source code in versions/operators.py 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 def translate_tilde ( version : Version ) -> VersionRange : \"\"\"Translate the `version` into a version set according to the *tilde* (`~`) strategy. This function returns the `[version, next_tilde_breaking(version))` range. Arguments: version: The version to translate. Returns: The version set representing the *tilde-equal* specification. \"\"\" return VersionRange ( min = version , max = next_tilde_breaking ( version ), include_min = True , include_max = False , )","title":"translate_tilde()"},{"location":"reference/#versions.operators.translate_equal","text":"Translate the version into a version set according to the equal ( == ) strategy. This function returns the [version, version] range (aka version point). Parameters: Name Type Description Default version Version The version to translate. required Returns: Type Description VersionPoint The version set representing the equal specification. Source code in versions/operators.py 514 515 516 517 518 519 520 521 522 523 524 525 def translate_equal ( version : Version ) -> VersionPoint : \"\"\"Translate the `version` into a version set according to the *equal* (`==`) strategy. This function returns the `[version, version]` range (aka `version` point). Arguments: version: The version to translate. Returns: The version set representing the *equal* specification. \"\"\" return VersionPoint ( version )","title":"translate_equal()"},{"location":"reference/#versions.operators.translate_not_equal","text":"Translate the version into a version set according to the not-equal ( != ) strategy. This function returns the (e, version) | (version, w) union. Parameters: Name Type Description Default version Version The version to translate. required Returns: Type Description VersionUnion The version set representing the not-equal specification. Source code in versions/operators.py 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 def translate_not_equal ( version : Version ) -> VersionUnion : \"\"\"Translate the `version` into a version set according to the *not-equal* (`!=`) strategy. This function returns the `(e, version) | (version, w)` union. Arguments: version: The version to translate. Returns: The version set representing the *not-equal* specification. \"\"\" result = translate_equal ( version ) . complement () if is_version_union ( result ): return result raise InternalError # TODO: message?","title":"translate_not_equal()"},{"location":"reference/#versions.operators.translate_less","text":"Translate the version into a version set according to the less ( < ) strategy. This function returns the (e, version) range. Parameters: Name Type Description Default version Version The version to translate. required Returns: Type Description VersionRange The version set representing the less specification. Source code in versions/operators.py 547 548 549 550 551 552 553 554 555 556 557 558 def translate_less ( version : Version ) -> VersionRange : \"\"\"Translate the `version` into a version set according to the *less* (`<`) strategy. This function returns the `(e, version)` range. Arguments: version: The version to translate. Returns: The version set representing the *less* specification. \"\"\" return VersionRange ( max = version , include_max = False )","title":"translate_less()"},{"location":"reference/#versions.operators.translate_less_or_equal","text":"Translate the version into a version set according to the less-or-equal ( <= ) strategy. This function returns the (e, version] range. Parameters: Name Type Description Default version Version The version to translate. required Returns: Type Description VersionRange The version set representing the less-or-equal specification. Source code in versions/operators.py 561 562 563 564 565 566 567 568 569 570 571 572 def translate_less_or_equal ( version : Version ) -> VersionRange : \"\"\"Translate the `version` into a version set according to the *less-or-equal* (`<=`) strategy. This function returns the `(e, version]` range. Arguments: version: The version to translate. Returns: The version set representing the *less-or-equal* specification. \"\"\" return VersionRange ( max = version , include_max = True )","title":"translate_less_or_equal()"},{"location":"reference/#versions.operators.translate_greater","text":"Translate the version into a version set according to the greater ( > ) strategy. This function returns the (version, w) range. Parameters: Name Type Description Default version Version The version to translate. required Returns: Type Description VersionRange The version set representing the greater specification. Source code in versions/operators.py 575 576 577 578 579 580 581 582 583 584 585 586 def translate_greater ( version : Version ) -> VersionRange : \"\"\"Translate the `version` into a version set according to the *greater* (`>`) strategy. This function returns the `(version, w)` range. Arguments: version: The version to translate. Returns: The version set representing the *greater* specification. \"\"\" return VersionRange ( min = version , include_min = False )","title":"translate_greater()"},{"location":"reference/#versions.operators.translate_greater_or_equal","text":"Translate the version into a version set according to the greater-or-equal ( >= ) strategy. This function returns the [version, w) range. Parameters: Name Type Description Default version Version The version to translate. required Returns: Type Description VersionRange The version set representing the greater-or-equal specification. Source code in versions/operators.py 589 590 591 592 593 594 595 596 597 598 599 600 601 def translate_greater_or_equal ( version : Version ) -> VersionRange : \"\"\"Translate the `version` into a version set according to the *greater-or-equal* (`>=`) strategy. This function returns the `[version, w)` range. Arguments: version: The version to translate. Returns: The version set representing the *greater-or-equal* specification. \"\"\" return VersionRange ( min = version , include_min = True )","title":"translate_greater_or_equal()"},{"location":"reference/#versions.operators.translate_wildcard_equal","text":"Translate the version into a version set according to the wildcard-equal ( == * ) strategy. This function returns the [version, next_wildcard_version(version)) range in most cases, except for when the version is * : then the (e, w) range is returned. Parameters: Name Type Description Default version Version The version to translate. required Returns: Type Description VersionRange The version set representing the wildcard-equal specification. Source code in versions/operators.py 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 def translate_wildcard_equal ( version : Version ) -> VersionRange : \"\"\"Translate the `version` into a version set according to the *wildcard-equal* (`== *`) strategy. This function returns the `[version, next_wildcard_version(version))` range in most cases, except for when the version is `*`: then the `(e, w)` range is returned. Arguments: version: The version to translate. Returns: The version set representing the *wildcard-equal* specification. \"\"\" wildcard = next_wildcard_breaking ( version ) if wildcard is None : return VersionRange () return VersionRange ( min = version , max = wildcard , include_min = True , include_max = False )","title":"translate_wildcard_equal()"},{"location":"reference/#versions.operators.translate_wildcard_not_equal","text":"Translate the version into a version set according to the wildcard-not-equal ( != * ) strategy. This function returns the (e, version) | (next_wildcard_breaking(version), w) union in most cases, except for when the version is * : then the {} empty set is returned. Parameters: Name Type Description Default version Version The version to translate. required Returns: Type Description Union [ VersionEmpty , VersionUnion ] The version set representing the wildcard-not-equal specification. Source code in versions/operators.py 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 def translate_wildcard_not_equal ( version : Version ) -> Union [ VersionEmpty , VersionUnion ]: \"\"\"Translate the `version` into a version set according to the *wildcard-not-equal* (`!= *`) strategy. This function returns the `(e, version) | (next_wildcard_breaking(version), w)` union in most cases, except for when the version is `*`: then the `{}` empty set is returned. Arguments: version: The version to translate. Returns: The version set representing the *wildcard-not-equal* specification. \"\"\" result = translate_wildcard_equal ( version ) . complement () if is_version_empty ( result ) or is_version_union ( result ): return result raise InternalError # TODO: message?","title":"translate_wildcard_not_equal()"},{"location":"reference/#versions.errors.ParseError","text":"Bases: ValueError Parsing has failed. Source code in versions/errors.py 10 11 class ParseError ( ValueError ): \"\"\"Parsing has failed.\"\"\"","title":"ParseError"},{"location":"reference/#versions.errors.ParseSpecificationError","text":"Bases: ParseError Parsing a specification has failed. Source code in versions/errors.py 14 15 class ParseSpecificationError ( ParseError ): \"\"\"Parsing a specification has failed.\"\"\"","title":"ParseSpecificationError"},{"location":"reference/#versions.errors.ParseTagError","text":"Bases: ParseError Parsing a version tag has failed. Source code in versions/errors.py 18 19 class ParseTagError ( ParseError ): \"\"\"Parsing a version tag has failed.\"\"\"","title":"ParseTagError"},{"location":"reference/#versions.errors.ParseVersionError","text":"Bases: ParseError Parsing a version has failed. Source code in versions/errors.py 22 23 class ParseVersionError ( ParseError ): \"\"\"Parsing a version has failed.\"\"\"","title":"ParseVersionError"},{"location":"reference/#versions.errors.InternalError","text":"Bases: RuntimeError An internal error has occured. Source code in versions/errors.py 26 27 class InternalError ( RuntimeError ): \"\"\"An internal error has occured.\"\"\"","title":"InternalError"},{"location":"security/","text":"Security Policy Reporting Thank you for taking the time to responsibly disclose any problems you find. Do not file public issues as they are open for everyone to see! All security vulnerabilities in versions should be reported by email to security@nekit.dev . Your report will be acknowledged within 24 hours, and you will receive a more detailed response within 48 hours indicating the next steps in handling your report. You can encrypt your report using our public key: BB2D8194464001E0B9B60EB8741A1EAD20FFDE8A . This key is also available on MIT's Key Server and reproduced below . After the initial reply to your report, the core team will try to keep you informed of the progress being made towards a fix and official announcement. These updates will be sent at least every five days. In reality, this is more likely to be every 24-48 hours. Disclosure Policy versions has a 5-step disclosure process: The security report is received and is assigned a primary handler. This person will coordinate the fix and release process. The problem is confirmed and a list of all affected versions is determined. Code is audited to find any potential similar problems. Fixes are prepared for all releases which are still under maintenance. These fixes are not committed to the public repository but rather held locally pending the announcement. On the embargo date, the changes are pushed to the public repository and new builds are deployed. This process can take some time, especially when coordination is required with maintainers of other projects. Every effort will be made to handle the issue in as timely a manner as possible, however it is important that we follow the release process above to ensure that the disclosure is handled in a consistent manner. Security Key -----BEGIN PGP PUBLIC KEY BLOCK----- mQINBGKJEuEBEAC37iPX5u8sN+DZQ8c4Of+85u/hboSqNLp7VtTGgr/d8RCFhGZk 25ZwqGWeJbhnlPuzT6u96CZFRe3TMHYJR+A2NZBVjAQQjDRGbIGgaS6/9lvMLcRx D+hFQNPgwUTfPhSHIan+9EuYK/Bz+jyyIplwTrIBq1Mo0NG+cUNvAB+he22xhBQ7 y/Xal+sapHfYedqywhYEQUgP94IGURIMiBlAB7nKW+qs7YiQBShBbfxxffMgK6W6 sNNSybUQDqjj1AWkOBj5uizkA6FLF80xULypbhe1gbqsIt4d1Lj/mxI5zvj84wy5 oQ6QOpYlBUQwl8kqfszYaqKCviflA+riAFMAE8NVL+5BuVN0QSvQb6cRzIV1SL0p MCA6s2+plK/9K+JyR5yyjY7FxvatYNLW5LsubmS+YeBdO4l4A7YEElOGMexUb61H 3ejlb/9UUrZ7hd09Hsi1J6nthrI26o0XBdB8UJ9QAdfoHWka3fgSgopBBcI+S3tU iWGngFrUhiXcBS+0xHjrk4USKwFyFr8fmL4Y8Yu31ViHRFj6gVjC/PHP0apCnakB UEEMHnAQfztodH9o2ew2kew77+q9VblDGpb3BYaiptl4c6h6WBcEULpRfWERfB8H St4L49Ob6CCNpVw9qgsDfNw2fFjUIsT6OGwJxhv9StIFW2JEhgxEvfHr1wARAQAB tC9OaWtpdGEgVGlraG9ub3YgKHNlY3VyaXR5KSA8c2VjdXJpdHlAbmVraXQuZGV2 PokCUgQTAQgAPAIbAwIXgAIeBxYhBLstgZRGQAHgubYOuHQaHq0g/96KBQJiiR6G BQsJCAcCAyICAQYVCgkICwIEFgIDAQAKCRB0Gh6tIP/einfmD/9y69eqwjRfdmnW s0ph8Rh99JHtgA+zm1akRl+eymiqLuJwmZge7PPFb68Wj4lI6s1M1dIkyRuYMtIM 3rEcMmGUlcVnPldx/wdcPyhYZDUXnYCK64dsloftrWFWoSr5a/AILyVh/L6Fkf+L RU9h3KPMXhLTyK127ZF5WuzpjSJms0hDMDV/idfiDeWn/VGaZz1Wiks4l8R9kisR LI3RKNR537f0KFS8jkqlI41Lj9XQTUdqMRp+eqi/zUMM7OZzKQg1ohDsLi4MR6wa bXIu7LeAp1M0XlB+MO09KOxR8i19ST89EapAp4gHprbG5hJyV3XHK4txcWHG0YjB g5/fOvytljf/ue5YGe5nQUcxucq6i4d6jsB66Gk/4nnKutlMG2ZtVyIZZZActPZ5 qKI64HQJOpag+ERXwrv0optEhTC7RHOFRuZ4pCKuVjdJE9W7ZpAIAi8yHeVvpgJY glo+DqZH1/kLD1u2Jb/8yUuMeCYc3aBlfZswO6IeMFeXbPaMtIHzY5q7blIdKIAb YxS5KCYn8VHG6Nz8lFMu2z4jpH4QY9vTaxZnG3Xp23uxbP0pznih4DMiHIACyCBP WgRReZTCVU6Z9FvBq8t/hcrwli33lTa5hkuuzqcojn80+1g9st7DOzxVFtR2MoSS Wkv8ss8apRyeLNZAM5M8v+AiiyVCrLkCDQRiiRLhARAApEJFgvQVDMYpuo754cRK WC/17DH1BQ9y78h/0MXmOOf/0MpzJBkPjn4++BdXQGoOCBleHrWmbtmfYLcQFmZ/ eiUzxFDS/pkC7aZUb+YA7JzcwZQP2yOhlMfFK0qCoQKw/45q+AkOUR+Z+VGExkM1 5+PAcQ+7cQRiyina6/MG7FHAOcvuEwjiyt/0zBm3izeWmXL0Gngisl1jvd8bGn4T bK68q2d09NNHdXJ9UDFdGJ+FVIqJCyLyBl0ZfWazSkD/4ZNchdjFcSOzTTMvqWWn 6i5awbVyMPZkKS88vRVwTtcjk4+hrzaIyNbTw7y55qQxFe0NEoj4SK+iMwCkax19 njGQeB8GqmieC+0WYUSt10xXZ6tDf6a9F2cg6zv1ZklOuYU9x8GYwU7zvhrGhvXU Un1ZtP/OaHoQsS/+AS7KJtm/NWHGsfjd8vwDirIoZ31D7X52QrN07NQ0H7+uqtDL c7BAhsLI1G/r9Kz0+P0nC/6bMWvQWiomB1BSwUTfXLkT0RoKZ3Yub8XMk46N9XKE RtTk5x0/rZ40uOg8wzT1GvwYFA4tpavAqLejOftE05lKXAb5tQhYRupZywzXM6HN DR7CbP1e26g0p8GAuz1aFny6cN8T3wTHHyYn7aQk7i1BboV8zFpVlF6EmoHNCZtG hkl28kYa0Yvu+9mw0SPNiIsAEQEAAYkCNgQYAQgAIBYhBLstgZRGQAHgubYOuHQa Hq0g/96KBQJiiRLhAhsMAAoJEHQaHq0g/96KeCoP/3i3A629wvjPn7m3y7pTcV8p riTlH5OeXhg4jCORgJrgL4PSoeFCITA0u0djtcvctmCrHMsZe0hyH5+X+/B9Bsf6 eFQKWXLidqkxD/M6lnE6t34d17DvaWCP27MsS/f0u0FsLom11TTFgp4wGKZfRBNH vX5xuhjoYXYwZwWqCYyEXFTbsUTDce2oaqc7Yw/GmM3fCodLX0/0eYh5u2fiKA57 7VuUWD74/TkgcEOMa/IZ/jPmJHuHOteaIJR0pYUvLQ1EJh3jI4LhmH8DqxoUrmKy 8z2VM0iLIiev86EXM+yzqTpRIFnm6Ts+47L18rb9D5IUo68gr5B2bMKPOfvMVzdN /vw2RKdCVJ70nh3qqRis5RsJrn/3T8H1CQtuPvsAd/oB86YGWPpWBtpTyI+VBp+x +XR434K8D9QXFst73wTCnQwSX6j0sIotQC5GsPJEKky2Wijg3BlxqTxtYjLhwKWg x3e63TEw7IgU+lE/ybzWLJ7EndbKsC7stZh+Lyh5b3YHgI3cfJUxjZNFpniKr/Fy 4EjjLZzFf3QRmNNJ/7VlYLYztGZsOWxRsLk7QfUPSZY4iHUr8aiwfL7IFwnAlzIo 36HDjJi80UakMlf45UcxRaJwWiaj7G4x3h1D1BZLtMiypiaw/mesrithmfHg+KYu 1oYi7ft0FnZ67Wnk5+E+ =VRe2 -----END PGP PUBLIC KEY BLOCK----- Attribution This Security Policy is adapted from Rust's Security Policy .","title":"Security"},{"location":"security/#security-policy","text":"","title":"Security Policy"},{"location":"security/#reporting","text":"Thank you for taking the time to responsibly disclose any problems you find. Do not file public issues as they are open for everyone to see! All security vulnerabilities in versions should be reported by email to security@nekit.dev . Your report will be acknowledged within 24 hours, and you will receive a more detailed response within 48 hours indicating the next steps in handling your report. You can encrypt your report using our public key: BB2D8194464001E0B9B60EB8741A1EAD20FFDE8A . This key is also available on MIT's Key Server and reproduced below . After the initial reply to your report, the core team will try to keep you informed of the progress being made towards a fix and official announcement. These updates will be sent at least every five days. In reality, this is more likely to be every 24-48 hours.","title":"Reporting"},{"location":"security/#disclosure-policy","text":"versions has a 5-step disclosure process: The security report is received and is assigned a primary handler. This person will coordinate the fix and release process. The problem is confirmed and a list of all affected versions is determined. Code is audited to find any potential similar problems. Fixes are prepared for all releases which are still under maintenance. These fixes are not committed to the public repository but rather held locally pending the announcement. On the embargo date, the changes are pushed to the public repository and new builds are deployed. This process can take some time, especially when coordination is required with maintainers of other projects. Every effort will be made to handle the issue in as timely a manner as possible, however it is important that we follow the release process above to ensure that the disclosure is handled in a consistent manner.","title":"Disclosure Policy"},{"location":"security/#security-key","text":"-----BEGIN PGP PUBLIC KEY BLOCK----- mQINBGKJEuEBEAC37iPX5u8sN+DZQ8c4Of+85u/hboSqNLp7VtTGgr/d8RCFhGZk 25ZwqGWeJbhnlPuzT6u96CZFRe3TMHYJR+A2NZBVjAQQjDRGbIGgaS6/9lvMLcRx D+hFQNPgwUTfPhSHIan+9EuYK/Bz+jyyIplwTrIBq1Mo0NG+cUNvAB+he22xhBQ7 y/Xal+sapHfYedqywhYEQUgP94IGURIMiBlAB7nKW+qs7YiQBShBbfxxffMgK6W6 sNNSybUQDqjj1AWkOBj5uizkA6FLF80xULypbhe1gbqsIt4d1Lj/mxI5zvj84wy5 oQ6QOpYlBUQwl8kqfszYaqKCviflA+riAFMAE8NVL+5BuVN0QSvQb6cRzIV1SL0p MCA6s2+plK/9K+JyR5yyjY7FxvatYNLW5LsubmS+YeBdO4l4A7YEElOGMexUb61H 3ejlb/9UUrZ7hd09Hsi1J6nthrI26o0XBdB8UJ9QAdfoHWka3fgSgopBBcI+S3tU iWGngFrUhiXcBS+0xHjrk4USKwFyFr8fmL4Y8Yu31ViHRFj6gVjC/PHP0apCnakB UEEMHnAQfztodH9o2ew2kew77+q9VblDGpb3BYaiptl4c6h6WBcEULpRfWERfB8H St4L49Ob6CCNpVw9qgsDfNw2fFjUIsT6OGwJxhv9StIFW2JEhgxEvfHr1wARAQAB tC9OaWtpdGEgVGlraG9ub3YgKHNlY3VyaXR5KSA8c2VjdXJpdHlAbmVraXQuZGV2 PokCUgQTAQgAPAIbAwIXgAIeBxYhBLstgZRGQAHgubYOuHQaHq0g/96KBQJiiR6G BQsJCAcCAyICAQYVCgkICwIEFgIDAQAKCRB0Gh6tIP/einfmD/9y69eqwjRfdmnW s0ph8Rh99JHtgA+zm1akRl+eymiqLuJwmZge7PPFb68Wj4lI6s1M1dIkyRuYMtIM 3rEcMmGUlcVnPldx/wdcPyhYZDUXnYCK64dsloftrWFWoSr5a/AILyVh/L6Fkf+L RU9h3KPMXhLTyK127ZF5WuzpjSJms0hDMDV/idfiDeWn/VGaZz1Wiks4l8R9kisR LI3RKNR537f0KFS8jkqlI41Lj9XQTUdqMRp+eqi/zUMM7OZzKQg1ohDsLi4MR6wa bXIu7LeAp1M0XlB+MO09KOxR8i19ST89EapAp4gHprbG5hJyV3XHK4txcWHG0YjB g5/fOvytljf/ue5YGe5nQUcxucq6i4d6jsB66Gk/4nnKutlMG2ZtVyIZZZActPZ5 qKI64HQJOpag+ERXwrv0optEhTC7RHOFRuZ4pCKuVjdJE9W7ZpAIAi8yHeVvpgJY glo+DqZH1/kLD1u2Jb/8yUuMeCYc3aBlfZswO6IeMFeXbPaMtIHzY5q7blIdKIAb YxS5KCYn8VHG6Nz8lFMu2z4jpH4QY9vTaxZnG3Xp23uxbP0pznih4DMiHIACyCBP WgRReZTCVU6Z9FvBq8t/hcrwli33lTa5hkuuzqcojn80+1g9st7DOzxVFtR2MoSS Wkv8ss8apRyeLNZAM5M8v+AiiyVCrLkCDQRiiRLhARAApEJFgvQVDMYpuo754cRK WC/17DH1BQ9y78h/0MXmOOf/0MpzJBkPjn4++BdXQGoOCBleHrWmbtmfYLcQFmZ/ eiUzxFDS/pkC7aZUb+YA7JzcwZQP2yOhlMfFK0qCoQKw/45q+AkOUR+Z+VGExkM1 5+PAcQ+7cQRiyina6/MG7FHAOcvuEwjiyt/0zBm3izeWmXL0Gngisl1jvd8bGn4T bK68q2d09NNHdXJ9UDFdGJ+FVIqJCyLyBl0ZfWazSkD/4ZNchdjFcSOzTTMvqWWn 6i5awbVyMPZkKS88vRVwTtcjk4+hrzaIyNbTw7y55qQxFe0NEoj4SK+iMwCkax19 njGQeB8GqmieC+0WYUSt10xXZ6tDf6a9F2cg6zv1ZklOuYU9x8GYwU7zvhrGhvXU Un1ZtP/OaHoQsS/+AS7KJtm/NWHGsfjd8vwDirIoZ31D7X52QrN07NQ0H7+uqtDL c7BAhsLI1G/r9Kz0+P0nC/6bMWvQWiomB1BSwUTfXLkT0RoKZ3Yub8XMk46N9XKE RtTk5x0/rZ40uOg8wzT1GvwYFA4tpavAqLejOftE05lKXAb5tQhYRupZywzXM6HN DR7CbP1e26g0p8GAuz1aFny6cN8T3wTHHyYn7aQk7i1BboV8zFpVlF6EmoHNCZtG hkl28kYa0Yvu+9mw0SPNiIsAEQEAAYkCNgQYAQgAIBYhBLstgZRGQAHgubYOuHQa Hq0g/96KBQJiiRLhAhsMAAoJEHQaHq0g/96KeCoP/3i3A629wvjPn7m3y7pTcV8p riTlH5OeXhg4jCORgJrgL4PSoeFCITA0u0djtcvctmCrHMsZe0hyH5+X+/B9Bsf6 eFQKWXLidqkxD/M6lnE6t34d17DvaWCP27MsS/f0u0FsLom11TTFgp4wGKZfRBNH vX5xuhjoYXYwZwWqCYyEXFTbsUTDce2oaqc7Yw/GmM3fCodLX0/0eYh5u2fiKA57 7VuUWD74/TkgcEOMa/IZ/jPmJHuHOteaIJR0pYUvLQ1EJh3jI4LhmH8DqxoUrmKy 8z2VM0iLIiev86EXM+yzqTpRIFnm6Ts+47L18rb9D5IUo68gr5B2bMKPOfvMVzdN /vw2RKdCVJ70nh3qqRis5RsJrn/3T8H1CQtuPvsAd/oB86YGWPpWBtpTyI+VBp+x +XR434K8D9QXFst73wTCnQwSX6j0sIotQC5GsPJEKky2Wijg3BlxqTxtYjLhwKWg x3e63TEw7IgU+lE/ybzWLJ7EndbKsC7stZh+Lyh5b3YHgI3cfJUxjZNFpniKr/Fy 4EjjLZzFf3QRmNNJ/7VlYLYztGZsOWxRsLk7QfUPSZY4iHUr8aiwfL7IFwnAlzIo 36HDjJi80UakMlf45UcxRaJwWiaj7G4x3h1D1BZLtMiypiaw/mesrithmfHg+KYu 1oYi7ft0FnZ67Wnk5+E+ =VRe2 -----END PGP PUBLIC KEY BLOCK-----","title":"Security Key"},{"location":"security/#attribution","text":"This Security Policy is adapted from Rust's Security Policy .","title":"Attribution"},{"location":"usage/","text":"Usage","title":"Usage"},{"location":"usage/#usage","text":"","title":"Usage"}]}